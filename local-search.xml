<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode 6.4-6.11</title>
    <link href="/2023/06/12/leetcode6.4-6.11/"/>
    <url>/2023/06/12/leetcode6.4-6.11/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode6-4-6-11"><a href="#leetcode6-4-6-11" class="headerlink" title="leetcode6.4-6.11"></a>leetcode6.4-6.11</h1><p>最近是二叉树专题</p><h2 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h2><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表 "></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">114. 二叉树展开为链表 </a></h3><p>数的问题有两种思维模式，一种是遍历的思维模式，另一种是分解问题的思维模式。拿到题目后根据题目选择思维模式。</p><p>这道题首先想到的是保存前序遍历的结果然后对保存的结果（即每个节点）做处理。但是也用了额外的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        vector&lt;TreeNode*&gt; res;<br>        <span class="hljs-built_in">firsttravel</span>(root,res);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            res[i]-&gt;left=<span class="hljs-literal">nullptr</span>;<br>            res[i]-&gt;right=res[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">firsttravel</span><span class="hljs-params">(TreeNode* root,vector&lt;TreeNode*&gt;&amp; r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        r.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-built_in">firsttravel</span>(root-&gt;left,r);<br>        <span class="hljs-built_in">firsttravel</span>(root-&gt;right,r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看了题解后得到了一种比较好的解法—-用分解问题的思维模式</p><blockquote><p>定义：输入节点 root，然后 root 为根的二叉树就会被拉平为一条链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span></span>;<br></code></pre></td></tr></table></figure><p>对于一个节点 <code>x</code>，可以执行以下流程：</p><p>1、先利用 <code>flatten(x.left)</code> 和 <code>flatten(x.right)</code> 将 <code>x</code> 的左右子树拉平。</p><p>2、将 <code>x</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义：将以 root 为根的树拉平为链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 利用定义，把左右子树拉平</span><br>    <span class="hljs-built_in">flatten</span>(root-&gt;left);<br>    <span class="hljs-built_in">flatten</span>(root-&gt;right);<br><br>    <span class="hljs-comment">/**** 后序遍历位置 ****/</span><br>    <span class="hljs-comment">// 1、左右子树已经被拉平成一条链表</span><br>    TreeNode* left = root-&gt;left;<br>    TreeNode* right = root-&gt;right;<br><br>    <span class="hljs-comment">// 2、将左子树作为右子树</span><br>    root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    root-&gt;right = left;<br><br>    <span class="hljs-comment">// 3、将原先的右子树接到当前右子树的末端</span><br>    TreeNode* p = root;<br>    <span class="hljs-keyword">while</span> (p-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>        p = p-&gt;right;<br>    &#125;<br>    p-&gt;right = right;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p><h2 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h2><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树 "></a><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 </a></h3><p>用分解问题的思维模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> index=<span class="hljs-number">-1</span>,max=INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;max)&#123;<br>                max=nums[i];<br>                index=i;<br>            &#125;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(max);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left1</span><span class="hljs-params">(nums.begin(), nums.begin() + index)</span></span>;<br>        root-&gt;left=<span class="hljs-built_in">constructMaximumBinaryTree</span>(left1);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right1</span><span class="hljs-params">(nums.begin()+index+<span class="hljs-number">1</span>, nums.end())</span></span>;<br>        root-&gt;right=<span class="hljs-built_in">constructMaximumBinaryTree</span>(right1);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要注意max要设置为最小整数，因为设置成0的话，有数组中用例&#x3D;0时，index&#x3D;-1没有被覆盖，left1构造的时候会报错</p><h2 id="6-6"><a href="#6-6" class="headerlink" title="6.6"></a>6.6</h2><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树 "></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 </a></h3><p>一看到题，绝对经典，基本都碰到过这样的一道数据结构题。现在让你写出算法解决</p><p>看了题解后才会做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<br>                        inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> prestart,<span class="hljs-type">int</span> preend,</span></span><br><span class="hljs-params"><span class="hljs-function">                    vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> instart,<span class="hljs-type">int</span> inend)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (prestart &gt; preend || instart &gt; inend)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootval=preorder[prestart];<br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=instart;i&lt;=inend;i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i]==rootval)&#123;<br>                index=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        root-&gt;left=<span class="hljs-built_in">build</span>(preorder,prestart+<span class="hljs-number">1</span>,prestart+index-instart,<br>                        inorder,instart,index<span class="hljs-number">-1</span>);<br>        root-&gt;right=<span class="hljs-built_in">build</span>(preorder,prestart+index-instart+<span class="hljs-number">1</span>,preend,<br>                         inorder,index+<span class="hljs-number">1</span>,inend);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一开始的时候没有加这样的一个判断条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span> (prestart &gt; preend || instart &gt; inend)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br></code></pre></td></tr></table></figure><p>导致了报了数组越界的错误，后面一想如果没有这个判断不仅会导致递归过程中数组的越界，也没有设置递归的终止条件，这个判断必须得有。</p><hr><p>这道题也是用分解问题的思维模式去做</p><p>根节点是前序遍历数组的第一个</p><p>关键点在于通过根节点的值，得到左子树前序和中序的新数组，右子数前序和中序的新数组</p><p><img src="/image/leetcode-3.PNG"></p><ul><li>得到根节点的值之后就可以在中序数组中确认左子树的数组和该数组的大小</li><li>通过这个大小可以在前序中确认左子树的数组</li></ul><h2 id="6-7"><a href="#6-7" class="headerlink" title="6.7"></a>6.7</h2><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树 "></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 </a></h3><p>同昨天的题一个系列，这次是中序和后序，后面还有前序和后序</p><p>思路和前一题一样，中序和后序确认新数组的方式有所区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bulid</span>(inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,postorder,<span class="hljs-number">0</span>,postorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">bulid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> instart,<span class="hljs-type">int</span> inend,</span></span><br><span class="hljs-params"><span class="hljs-function">                    vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder,<span class="hljs-type">int</span> poststart,<span class="hljs-type">int</span> postend)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(instart&gt;inend||poststart&gt;postend)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> rootval=postorder[postend];<br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=instart;i&lt;=inend;i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i]==rootval)&#123;<br>                index=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        root-&gt;left=<span class="hljs-built_in">bulid</span>(inorder,instart,index<span class="hljs-number">-1</span>,<br>                        postorder,poststart,poststart+index-instart<span class="hljs-number">-1</span>);<br>        root-&gt;right=<span class="hljs-built_in">bulid</span>(inorder,index+<span class="hljs-number">1</span>,inend,<br>                        postorder,poststart+index-instart,postend<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树 "></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/">889. 根据前序和后序遍历构造二叉树 </a></h3><p>首先要注意的是前序和后序不能确定唯一的二叉树，所以返回任意一种可能的答案。</p><p>于前面两题有所区别的是，在通过前序得到根节点后，怎么判断该节点属于左子树的全部节点是数组的那一部分即无法确切的知道左右子树有哪些节点。</p><p><strong>1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值</strong>。</p><p><strong>2、然后把前序遍历结果的第二个元素作为左子树的根节点的值</strong>。</p><p><strong>3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,postorder,<span class="hljs-number">0</span>,postorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> prestart,<span class="hljs-type">int</span> preend,</span></span><br><span class="hljs-params"><span class="hljs-function">                    vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder,<span class="hljs-type">int</span> poststart,<span class="hljs-type">int</span> postend)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(prestart&gt;preend||poststart&gt;postend)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(prestart==preend)&#123;          <span class="hljs-comment">//注意，与前两题不同，这里必须要有这样的以一个判断，如果数组长度为1，那么后面prestart+1会越界</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[prestart]);<br>        &#125;<br>        <span class="hljs-type">int</span> rootval=preorder[prestart];<br>        TreeNode* root =<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lefti=preorder[prestart+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=poststart;i&lt;=postend;i++)&#123;<br>            <span class="hljs-keyword">if</span>(postorder[i]==lefti)&#123;<br>                index=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        root-&gt;left=<span class="hljs-built_in">build</span>(preorder,prestart+<span class="hljs-number">1</span>,prestart+index-poststart+<span class="hljs-number">1</span>,<br>                        postorder,poststart,index);<br>        root-&gt;right=<span class="hljs-built_in">build</span>(preorder,prestart+index-poststart+<span class="hljs-number">2</span>,preend,<br>                         postorder,index+<span class="hljs-number">1</span>,postend<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-8"><a href="#6-8" class="headerlink" title="6.8"></a>6.8</h2><h3 id="652-寻找重复的子树-力扣（Leetcode）"><a href="#652-寻找重复的子树-力扣（Leetcode）" class="headerlink" title="652. 寻找重复的子树 - 力扣（Leetcode）"></a><a href="https://leetcode.cn/problems/find-duplicate-subtrees/description/">652. 寻找重复的子树 - 力扣（Leetcode）</a></h3><p>说实话这题题目都没怎么看懂，根本没有思路，上题解</p><p>1.如何知道以这个节点为根的二叉树长什么样</p><p>需要在后序位置写代码，因为得先知道<strong>该节点的左右子树</strong>长什么样，然后就是将遍历结果序列化，可以用前序顺序或者后序顺序拼接字符串，但是不能用中序顺序</p><p>2.以其他节点为根的子树长什么样</p><p>借助unordered_map把每个节点的序列化结果保存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string,<span class="hljs-type">int</span>&gt; map;<br>    vector&lt;TreeNode*&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">serialize</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">string  <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br><br>        &#125;<br>        string left=<span class="hljs-built_in">serialize</span>(root-&gt;left);<br>        string right=<span class="hljs-built_in">serialize</span>(root-&gt;right);<br>        string res=<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&quot;,&quot;</span>+left+<span class="hljs-string">&quot;,&quot;</span>+right;<br>        map[res]++;<br>        <span class="hljs-keyword">if</span>(map[res]==<span class="hljs-number">2</span>) ans.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-9"><a href="#6-9" class="headerlink" title="6.9"></a>6.9</h2><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（Leetcode）</a></p><p>算法部分感觉还好，输入输出的处理有点麻烦，输入输出是数组型的字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-attr">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-built_in">string</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">TreeNode* root</span>) &#123;<br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-title function_">serialize</span>(root,res); <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">TreeNode*&amp; root,<span class="hljs-built_in">string</span>&amp; s</span>)&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-variable constant_">NULL</span>)&#123;<br>            s+=<span class="hljs-string">&quot;null,&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        s+=<span class="hljs-title function_">to_string</span>(root-&gt;val)+<span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-title function_">serialize</span>(root-&gt;left,s);<br>        <span class="hljs-title function_">serialize</span>(root-&gt;right,s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-title class_">TreeNode</span>* <span class="hljs-title function_">deserialize</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> data</span>) &#123;<br>        list&lt;<span class="hljs-built_in">string</span>&gt; dataArray;<br>        <span class="hljs-built_in">string</span> str;<br>        <span class="hljs-keyword">for</span>(auto&amp; ch :data) &#123;<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>                dataArray.<span class="hljs-title function_">push_back</span>(str);<br>                str.<span class="hljs-title function_">clear</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                str.<span class="hljs-title function_">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!str.<span class="hljs-title function_">empty</span>())&#123;<br>            dataArray.<span class="hljs-title function_">push_back</span>(str);<br>            str.<span class="hljs-title function_">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rdeserialize</span>(dataArray);<br>    &#125;<br>    <span class="hljs-title class_">TreeNode</span>* <span class="hljs-title function_">rdeserialize</span>(<span class="hljs-params">list&lt;<span class="hljs-built_in">string</span>&gt;&amp; dataArray</span>)&#123;<br>        <span class="hljs-keyword">if</span>(dataArray.<span class="hljs-title function_">front</span>()==<span class="hljs-string">&quot;null&quot;</span>)&#123;<br>            dataArray.<span class="hljs-title function_">erase</span>(dataArray.<span class="hljs-title function_">begin</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NULL</span>;<br>        &#125;<br>        <span class="hljs-title class_">TreeNode</span>* root =<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title function_">stoi</span>(dataArray.<span class="hljs-title function_">front</span>()));<br>        dataArray.<span class="hljs-title function_">erase</span>(dataArray.<span class="hljs-title function_">begin</span>());<br>        root-&gt;left=<span class="hljs-title function_">rdeserialize</span>(dataArray);<br>        root-&gt;right=<span class="hljs-title function_">rdeserialize</span>(dataArray);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用的是前序，有一点要注意</p><ol><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，那么你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你会给出<strong>两种</strong>遍历顺序，分两种情况：</p><p>2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。</p><p>2.2. 如果你给出前序和后序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树。</p></li><li><p>如果你的序列化结果中<strong>包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，也要分两种情况：</p><p>3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。</p><p>3.2. 如果你给出的是中序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树。</p></li></ol><h2 id="6-10"><a href="#6-10" class="headerlink" title="6.10"></a>6.10</h2><h2 id="6-11"><a href="#6-11" class="headerlink" title="6.11"></a>6.11</h2><p>这两天忙租房的事情，断了两天。。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6模块化&amp;Promise&amp;EventLoop</title>
    <link href="/2023/06/08/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <url>/2023/06/08/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6模块化和异步编程高级用法"><a href="#ES6模块化和异步编程高级用法" class="headerlink" title="ES6模块化和异步编程高级用法"></a>ES6模块化和异步编程高级用法</h1><h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><h3 id="node中如何实现模块化"><a href="#node中如何实现模块化" class="headerlink" title="node中如何实现模块化"></a>node中如何实现模块化</h3><p>node.js 遵循了 CommonJS 的模块化规范。其中：</p><ul><li>导入其它模块使用 require() 方法</li><li>模块对外共享成员使用 module.exports 对象</li></ul><h3 id="前端模块化的分类"><a href="#前端模块化的分类" class="headerlink" title="前端模块化的分类"></a>前端模块化的分类</h3><blockquote><p>在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范。</p><p>但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化</p><p>标准，例如：</p><ul><li>AMD 和 CMD 适用于浏览器端的 Javascript 模块化</li><li>CommonJS 适用于服务器端的 Javascript 模块化</li></ul><p>太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，大一统的 ES6 模块化规范诞生了！</p></blockquote><h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学</p><p>习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。</p><p>ES6 模块化规范中定义：</p><ul><li>每个 js 文件都是一个独立的模块</li><li>导入其它模块成员使用 import 关键字</li><li>向外共享模块成员使用 export 关键字</li></ul><blockquote><p>node.js 中默认仅支持 CommonJS 模块化规范，若想基于 node.js 体验与学习 ES6 的模块化语法，可以按照</p><p>如下两个步骤进行配置：</p><p>① 确保安装了 v14.15.1 或更高版本的 node.js</p><p>② 在 package.json 的根节点中添加 “type”: “module” 节点</p></blockquote><h3 id="ES6模块化的基本语法"><a href="#ES6模块化的基本语法" class="headerlink" title="ES6模块化的基本语法"></a>ES6模块化的基本语法</h3><blockquote><p>ES6 的模块化主要包含如下 3 种用法：</p><p>① 默认导出与默认导入</p><p>② 按需导出与按需导入</p><p>③ 直接导入并执行模块中的代码</p></blockquote><h4 id="1-1默认导出"><a href="#1-1默认导出" class="headerlink" title="1.1默认导出"></a>1.1默认导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 默认导出的成员<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> n2 = <span class="hljs-number">20</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  n1,<br>  show<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>每个模块中，只允许使用唯一的一次 export default，否则会报错！</p><p>​</p></li></ul><h4 id="1-1默认导入"><a href="#1-1默认导入" class="headerlink" title="1.1默认导入"></a>1.1默认导入</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> xxx <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;&#x27;</span>       <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./01.默认导出.js&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1)<br></code></pre></td></tr></table></figure><ul><li>默认导入时的接收名称可以任意名称，只要是合法的成员名称即可</li></ul><h4 id="2-1按需导出"><a href="#2-1按需导出" class="headerlink" title="2.1按需导出"></a>2.1按需导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> 按需导出的成员<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&#x27;ccc&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-按需导入"><a href="#2-2-按需导入" class="headerlink" title="2.2 按需导入"></a>2.2 按需导入</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; s1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;模块标识符&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; s1, s2, say &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./03.按需导出.js&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-注意事项"><a href="#2-3-注意事项" class="headerlink" title="2.3 注意事项"></a>2.3 注意事项</h4><p>① 每个模块中可以使用多次按需导出</p><p>② 按需导入的成员名称必须和按需导出的名称保持一致</p><p>③ 按需导入时，可以使用 as 关键字进行重命名</p><p>④ 按需导入可以和默认导入一起使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> info, &#123; s1, s2 <span class="hljs-keyword">as</span> str2, say &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./03.按需导出.js&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="直接导入并执行模块中的代码"><a href="#直接导入并执行模块中的代码" class="headerlink" title="直接导入并执行模块中的代码"></a>直接导入并执行模块中的代码</h4><p>如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模</p><p>块代码</p><p><img src="/image/es6-1.PNG"></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><blockquote><p>异步任务<br>与之相对应的概念是“同步任务”，同步任务在主线程上排队执行，只有前一个任务执行完毕，才能执行下一个任务。异步任务不进入主线程，而是进入异步队列，前一个任务是否执行完毕不影响下一个任务的执行。同样，还拿定时器作为异步任务举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ja">setTimeout(function()&#123;<br>    console.log(&#x27;执行了回调函数&#x27;);<br>&#125;,3000)<br>console.log(&#x27;111&#x27;);<br><br></code></pre></td></tr></table></figure><p>先输出111</p></blockquote><p>存在异步任务的代码，不能保证能按照顺序执行，那如果我们非要代码顺序执行呢</p><p>比如我要说一句话，语序必须是下面这样的：武林要以和为贵，要讲武德，不要搞窝里斗。<br>我必须要这样操作，才能保证顺序正确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">//第一层</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;武林要以和为贵&#x27;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">//第二程</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;要讲武德&#x27;</span>);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">//第三层</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;不要搞窝里斗&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;, <span class="hljs-number">3000</span>)<br><br></code></pre></td></tr></table></figure><p>可以看到，代码中的回调函数套回调函数，居然套了3层，这种回调函数中嵌套回调函数的情况就叫做回调地狱</p><p>回调地狱的缺点：</p><ul><li>代码耦合性太强，牵一发而动全身，难以维护</li><li>大量冗余的代码相互嵌套，代码的可读性变差</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>① <strong>Promise 是一个构造函数</strong></p><ul><li>我们可以创建 Promise 的实例 const p &#x3D; new Promise()</li><li>new 出来的 Promise 实例对象，代表一个异步操作</li></ul><p>② <strong>Promise.prototype 上包含一个 .then() 方法</strong></p><ul><li>每一次 new Promise() 构造函数得到的实例对象，</li><li>都可以通过原型链的方式访问到 .then() 方法，例如 p.then()</li></ul><p>③ <strong>.then() 方法用来预先指定成功和失败的回调函数</strong></p><ul><li>p.then(成功的回调函数，失败的回调函数)</li><li>p.then(result &#x3D;&gt; { }, error &#x3D;&gt; { })</li><li>调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的</li></ul><h3 id="基于-then-fs-读取文件内容"><a href="#基于-then-fs-读取文件内容" class="headerlink" title="基于 then-fs 读取文件内容"></a>基于 then-fs 读取文件内容</h3><p>由于 node.js 官方提供的 fs 模块仅支持以回调函数的方式读取文件，不支持 Promise 的调用方式。因此，需</p><p>要先运行如下的命令，安装 then-fs 这个第三方包，从而支持我们基于 Promise 的方式读取文件的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install then-fs<br></code></pre></td></tr></table></figure><p>调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因</p><p>此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)&#125;)<br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)&#125;)<br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)&#125;)<br></code></pre></td></tr></table></figure><p>但是上述的代码不能保证按顺序执行</p><h3 id="then-方法的特性"><a href="#then-方法的特性" class="headerlink" title=".then()方法的特性"></a>.then()方法的特性</h3><p>如果上一个 .then() 方法中返回了一个新的 Promise 实例对象，则可以通过下一个 .then() 继续进行处理。通</p><p>过 .then() 方法的链式调用，就解决了回调地狱的问题</p><h3 id="基于Promise按顺序读取文件的内容"><a href="#基于Promise按顺序读取文件的内容" class="headerlink" title="基于Promise按顺序读取文件的内容"></a>基于Promise按顺序读取文件的内容</h3><p>Promise 支持链式调用，从而来解决回调地狱的问题。示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br>thenFs<br>  .<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)  <span class="hljs-comment">//1.返回值是Promise的实例对象</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;                    <span class="hljs-comment">//2.通过.then为第一个Promise实例指定成功之后的回调函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-comment">//3.在第一个then中返回一个新的Promise对象</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;                 <span class="hljs-comment">//4.继续调用.then为上一个.then返回的Promise对象指定回调函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>  &#125;)<br><br></code></pre></td></tr></table></figure><h3 id="通过-catch捕获错误"><a href="#通过-catch捕获错误" class="headerlink" title="通过.catch捕获错误"></a>通过.catch捕获错误</h3><p>在 Promise 的链式操作中如果发生了错误，可以使用 Promise.prototype.catch 方法进行捕获和处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br>thenFs<br>  .<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)  <span class="hljs-comment">//</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;                    <span class="hljs-comment">//2.通过.then为第一个Promise实例指定成功之后的回调函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-comment">//3.在第一个then中返回一个新的Promise对象</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;                 <span class="hljs-comment">//4.继续调用.then为上一个.then返回的Promise对象指定回调函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>假设文件不存在导致读取失败，后面3个then不执行</p><p>如果不希望前面的错误导致后续的 .then 无法正常执行，则可以将 .catch 的调用提前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br>thenFs<br>  .<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;                       <span class="hljs-comment">//错误已经被处理，不影响后续.then执行</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>  &#125;)<br><br></code></pre></td></tr></table></figure><hr><p>学到这里产生了一个疑问，then是异步操作吗，如果在执行前有别的同步操作会怎样</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>  resolve(<span class="hljs-number">5</span>);<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(val);<br>&#125;);<br><br>promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>&#125;);<br>执行结果<span class="hljs-number">124536</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span> <span class="hljs-keyword">new</span>的时候会立即执行里面的代码 <span class="hljs-keyword">then</span>是微任务 会在本次任务执行完的时候执行 <span class="hljs-built_in">setTimeout</span>是宏任务 会在下次任务执行的时候执行<br></code></pre></td></tr></table></figure><blockquote><p><code>resolve(&quot;Async operation completed&quot;)</code> 是 Promise 中的方法，用于将 Promise 对象的状态从 “pending”（进行中）转变为 “fulfilled”（已完成），同时传递一个结果值（在这里是字符串 “Async operation completed”）。</p><p>在上述示例中，<code>resolve(&quot;Async operation completed&quot;)</code> 是在 Promise 的执行器函数内部执行的，具体来说是在 <code>new Promise((resolve, reject) =&gt; &#123;...&#125;)</code> 中的回调函数内部执行的。这个回调函数会在 Promise 对象被创建时立即执行。</p><p>当 Promise 的执行器函数内部调用 <code>resolve</code> 方法时，Promise 对象的状态就会变为 “fulfilled”，同时传递的结果值会成为该 Promise 对象的终值（fulfillment value）。</p><p>在示例中，<code>resolve(&quot;Async operation completed&quot;)</code> 是在 Promise 对象创建后的某个时间点（例如，在调用 <code>new Promise(...)</code> 之后立即调用）执行的。这是因为 <strong>Promise 的执行器函数是同步执行</strong>的（但是这个函数里面如果执行了异步的操作，那么那个操作仍然是异步的，这里只是说这个函数是同步的，但是不能保证里面的操作，可以看下面的那个案例），它会立即执行回调函数，并在回调函数中调用 <code>resolve</code> 或 <code>reject</code> 方法来改变 Promise 的状态。</p></blockquote><h3 id="执行器函数"><a href="#执行器函数" class="headerlink" title="执行器函数"></a>执行器函数</h3><p>在Promise中，执行器函数（executor function）是作为参数传递给Promise构造函数的一个函数。执行器函数在创建Promise对象时立即执行，它负责定义异步操作，并通过调用resolve或reject来改变Promise的状态。</p><p>执行器函数接受两个参数：resolve和reject。这些参数都是函数，由Promise构造函数提供，并且由JavaScript引擎在Promise对象创建时自动传递给执行器函数。</p><p>通常情况下，执行器函数包含异步操作（如网络请求、文件读取等），并在异步操作完成时调用resolve方法来表示操作成功，或调用reject方法来表示操作失败。通过调用这些方法，执行器函数可以决定Promise对象的最终状态和终值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> randomNum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();<br>    <span class="hljs-keyword">if</span> (randomNum &lt; <span class="hljs-number">0.5</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Operation succeeded&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Operation failed&quot;</span>);<br>    &#125;<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上述示例中，Promise的执行器函数包含了一个异步操作（使用setTimeout模拟），在2秒后随机生成一个数，并通过比较来决定调用resolve或reject。如果生成的数小于0.5，则调用resolve表示操作成功，否则调用reject表示操作失败。</p><p>通过这种方式，执行器函数可以定义Promise的行为和异步操作的逻辑，以及在异步操作完成后如何改变Promise的状态和传递最终的结果。</p><h3 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a>Promise.all()方法</h3><p>Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then </p><p>操作（等待机制）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br><span class="hljs-keyword">const</span> promiseArr = [<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>]<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promiseArr).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><span class="hljs-comment">//result是包含所以解析值的数组</span><br><span class="hljs-comment">//返回一个新的Promise对象，该对象在promiseArr中的所有Promise对象都被解析时才被解析，并提供一个包含所有解析值的数组作为回调函数的参数</span><br></code></pre></td></tr></table></figure><h3 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race()方法"></a>Promise.race()方法</h3><p>Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的</p><p>.then 操作（赛跑机制）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br><span class="hljs-keyword">const</span> promiseArr = [<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>]<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(promiseArr).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br></code></pre></td></tr></table></figure><p>调用<code>Promise.race(promiseArr)</code>，返回一个新的Promise对象。这个新的Promise对象将会在<code>promiseArr</code>中最快完成的Promise对象被解析时被解析</p><h3 id="基于Promise封装读文件方法"><a href="#基于Promise封装读文件方法" class="headerlink" title="基于Promise封装读文件方法"></a>基于Promise封装读文件方法</h3><p>① 方法的名称要定义为 getFile</p><p>② 方法接收一个形参 fpath，表示要读取的文件的路径</p><p>③ 方法的返回值为 Promise 实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(fpath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(err)<br>      <span class="hljs-title function_">resolve</span>(dataStr)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">getFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>))<br></code></pre></td></tr></table></figure><p>一般直接使用.catch()做错误处理而不用then中第二个参数</p><h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>(语法糖)</p><p>async&#x2F;await 是 ES8（ECMAScript 2017）引入的新语法，用来简化Promise 异步操作。在 async&#x2F;await 出现之前，开发者只能通过链式 .then() 的方式处理 Promise 异步操作。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>① 如果在 function 中使用了 await，则 function 必须被 async 修饰</p><p>② 在 async 方法中，第一个 await 之前的代码会同步执行，await 之后的代码会异步执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllFile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>)<br>  <span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">await</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>  <span class="hljs-keyword">const</span> r2 = <span class="hljs-keyword">await</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br>  <span class="hljs-keyword">const</span> r3 = <span class="hljs-keyword">await</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;D&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">getAllFile</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>（await相当于.then()方法，thenFs.readFile(‘.&#x2F;files&#x2F;1.txt’, ‘utf8’)这个promise把终值给了await）</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>可以参考<a href="https://juejin.cn/post/6844903512845860872#heading-0">这一次，彻底弄懂 JavaScript 执行机制 - 掘金 (juejin.cn)</a></p><p>JS是单线程执行的编程语言</p><p>为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类：</p><p>① 同步任务（synchronous）</p><ul><li>又叫做非耗时任务，指的是在主线程上排队执行的那些任务</li><li>只有前一个任务执行完毕，才能执行后一个任务</li></ul><p>② 异步任务（asynchronous）</p><ul><li>又叫做耗时任务，异步任务由 JavaScript 委托给宿主环境进行执行</li><li>当异步任务执行完成后，会通知 JavaScript 主线程执行异步任务的回调函数</li></ul><p><img src="/image/es6-2.PNG"></p><p>(图来自黑马程序员)</p><p>任务队列根据宏任务和微任务有对应的宏任务队列和微任务队列</p><blockquote><p>JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。</p></blockquote><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是：</p><p>① 宏任务（macrotask）</p><ul><li><p>整体代码script</p></li><li><p>异步 Ajax 请求、</p></li><li><p>setTimeout、setInterval、</p></li><li><p>文件操作</p></li><li><p>I&#x2F;O</p></li><li><p>UI交互事件（比如DOM）</p></li><li><p>其它宏任务</p></li></ul><p>② 微任务（microtask）</p><ul><li><p>Promise.then、.catch 和 .finally</p></li><li><p>process.nextTick（Node独有，注册函数的优先级比Promise回调函数要高）</p><blockquote><p>因为node中的event loop和浏览器中的event loop运行方式不一样。<br>浏览器中的机制就像作者说的那样：一个宏，所有微；再一个宏，再所有微 这样的去执行事件循环（也可以理解为微任务在宏任务之间的间隙去执行）。<br>而node中，是一类一系列这样子去执行的。是一类宏，然后本次循环所有微；再一类宏，所有微 这样子的。<br>然后题中两个setTimeout属于一类，即使他们每个宏中又各自有微，也是先执行完这一类所有setTimeout之后才执行本次剩下的微任务的。所以是这个结果。当然，node中nextTick的执行优先级高于then的。</p></blockquote><p>(高版本的node就和浏览器一样了)</p></li><li><p>其它微任务</p></li></ul><p>引入了这两个概念之后，事件循环就变成这样了：</p><p>1.整个script代码作为第一个宏任务开始执行，同步任务立即执行，遇到宏任务后推到宏任务队列，遇到微任务推到微任务队列，</p><p>2.当第一次事件循环中的执行栈为空时，就去执行微任务队列中的事件，微任务队列为空时开始第二次事件循环，</p><p>3.第二次事件循环会将宏任务队列中最顶端的事件加入到执行栈中执行，执行过程中遇到微任务则推入到微任务队列中，如果遇到宏任务则把宏任务推入到宏任务队列中，当执行栈为空时，再去执行微任务队列中的事件，直到微任务队列为空，重复第3步中的操作开始下一次事件循环，直到所有宏任务，微任务都为空为止</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS异步</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6</tag>
      
      <tag>promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-req.params&amp;req.query&amp;req.body</title>
    <link href="/2023/06/05/Node%E4%B8%ADreq.params%EF%BC%8Creq.query%EF%BC%8Creq.body/"/>
    <url>/2023/06/05/Node%E4%B8%ADreq.params%EF%BC%8Creq.query%EF%BC%8Creq.body/</url>
    
    <content type="html"><![CDATA[<h1 id="Node中req-params，req-query，req-body"><a href="#Node中req-params，req-query，req-body" class="headerlink" title="Node中req.params，req.query，req.body"></a>Node中req.params，req.query，req.body</h1><h2 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h2><p>通常用来解析POST请求中的数据<br>req.body不是nodejs默认提供的，需要载入中间件body-parser中间件才可以使用req.body</p><h2 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h2><p>由nodejs默认提供，无需载入中间件，此方法多适用于GET请求，解析GET请求中的参数<br>包含在路由中每个查询字符串参数属性的对象，如果没有则为{}</p><h2 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h2><p>nodejs默认提供，无需载入其他中间件</p><p>req.params包含路由参数（在URL的路径部分），而req.query包含URL的查询参数（在URL的？后的参数）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">包含映射到指定的路线“参数”属性的对象。<br>例如，如果你有route/<span class="hljs-keyword">user</span>/：<span class="hljs-type">name</span>，那么“<span class="hljs-type">name</span>”属性可作为req.params.name。<br>该对象默认为&#123;&#125;。<br></code></pre></td></tr></table></figure><h2 id="一个url中有动态参数的接口的例子"><a href="#一个url中有动态参数的接口的例子" class="headerlink" title="一个url中有动态参数的接口的例子"></a>一个url中有动态参数的接口的例子</h2><p><img src="/image/node-other-1.PNG"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-5-session&amp;jwt</title>
    <link href="/2023/06/05/node.js-5/"/>
    <url>/2023/06/05/node.js-5/</url>
    
    <content type="html"><![CDATA[<h1 id="node-js-5"><a href="#node-js-5" class="headerlink" title="node.js-5"></a>node.js-5</h1><h2 id="Web开发模式"><a href="#Web开发模式" class="headerlink" title="Web开发模式"></a>Web开发模式</h2><h3 id="服务端渲染的-Web-开发模式"><a href="#服务端渲染的-Web-开发模式" class="headerlink" title="服务端渲染的 Web 开发模式"></a>服务端渲染的 Web 开发模式</h3><p>服务端渲染的概念：服务器发送给客户端的 HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用 Ajax这样的技术额外请求页面的数据。</p><p><img src="/image/node.js-5-1.PNG"></p><p>优点：</p><p>① 前端耗时少。因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。</p><p>② 有利于SEO。因为服务器端响应的是完整的HTML页面内容，所以爬虫更容易爬取获得信息，更有利于SEO。</p><p>缺点：</p><p>① 占用服务器端资源。即服务器端完成HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</p><p>② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。</p><h3 id="前后端分离的-Web-开发模式"><a href="#前后端分离的-Web-开发模式" class="headerlink" title="前后端分离的 Web 开发模式"></a>前后端分离的 Web 开发模式</h3><p>  前后端分离的概念：前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。简而言之，前后端分离的 Web开发模式，就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式。</p><p>优点：</p><p>① 开发体验好。前端专注于UI页面的开发，后端专注于api的开发，且前端有更多的选择性。</p><p>② 用户体验好。Ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。</p><p>③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。</p><p>缺点：</p><p>① 不利于 SEO。因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用Vue、React等前端框架的SSR（serverside render）技术能够很好的解决SEO问题！）</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p><p>① 服务端渲染推荐使用Session 认证机制</p><p>② 前后端分离推荐使用JWT 认证机制</p><h3 id="Session-认证机制"><a href="#Session-认证机制" class="headerlink" title="Session 认证机制"></a>Session 认证机制</h3><p>HTTP协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。</p><h4 id="突破HTTP协议的无状态性：cookie"><a href="#突破HTTP协议的无状态性：cookie" class="headerlink" title="突破HTTP协议的无状态性：cookie"></a>突破HTTP协议的无状态性：cookie</h4><p>Cookie是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p><p>不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。</p><p>Cookie的几大特性：</p><p>①自动发送</p><p>②域名独立</p><p>③过期时限</p><p>④4KB限制</p><h4 id="cookie在身份认证中的作用"><a href="#cookie在身份认证中的作用" class="headerlink" title="cookie在身份认证中的作用"></a>cookie在身份认证中的作用</h4><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动将Cookie保存在浏览器中。</p><p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。</p><p><img src="/image/node.js-5-2.PNG"></p><p>由于Cookie是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此Cookie 很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过Cookie的形式发送给浏览器。</p><blockquote><p>cookie是一种客户端的状态管理技术</p><p>当浏览器向服务器发送请求时，服务器会将少量的数据以set-cookie消息头的方式发送给浏览器</p><p>浏览器会将这些数据保存下来。当浏览器再次访问服务器时，会将这些数据以cookie消息头的方式发送给服务器。</p></blockquote><h4 id="session的工作原理"><a href="#session的工作原理" class="headerlink" title="session的工作原理"></a>session的工作原理</h4><p><img src="/image/node.js-5-3.PNG"></p><blockquote><p>session是一种服务器端的状态管理技术。</p><p>当浏览器访问服务器时，服务器创建一个session对象(该对象有一个唯一的id号，称之为sessionId),服务器在默认情况下，会将sessionId以cookie的方式(set-cookie消息头)发送给浏览器,浏览器会将sessionId保存到内存。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可找到之前创建的session对象。</p></blockquote><h3 id="在express中使用session认证"><a href="#在express中使用session认证" class="headerlink" title="在express中使用session认证"></a>在express中使用session认证</h3><p>1.在Express项目中，只需要安装express-session 中间件，即可在项目中使用 Session 认证：</p><p><img src="/image/node.js-5-4.PNG"></p><p>2.express-session 中间件安装成功后，需要通过app.use() 来注册 session 中间件，示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// TODO_01：请配置 Session 中间件</span><br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-title function_">session</span>(&#123;<br>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;itheima&#x27;</span>,<br>    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>,<br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><p><strong>需要在路由之前配置</strong></p><p>3.当 express-session中间件配置成功后，即可通过req.session 来访问和使用session对象，从而存储用户的关键信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 判断用户提交的登录信息是否正确</span><br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">body</span>.<span class="hljs-property">username</span> !== <span class="hljs-string">&#x27;admin&#x27;</span> || req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span> !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录失败&#x27;</span> &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// TODO_02：请将登录成功后的用户信息，保存到 Session 中</span><br>  <span class="hljs-comment">// 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span> = req.<span class="hljs-property">body</span> <span class="hljs-comment">// 用户的信息</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 用户的登录状态</span><br><br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>4.可以直接从 req.session 对象上获取之前存储的数据，示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// TODO_03：请从 Session 中获取用户的名称，响应给客户端</span><br>  <span class="hljs-keyword">if</span> (!req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;fail&#x27;</span> &#125;)<br>  &#125;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>    <span class="hljs-attr">username</span>: req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">username</span>,<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>5.调用req.session.destroy() 函数，即可清空服务器保存的session信息。</p><p>(清空当前用户对应的session)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 退出登录的接口</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// TODO_04：清空 Session 信息</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>()<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;退出登录成功&#x27;</span>,<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h3><h4 id="session局限性"><a href="#session局限性" class="headerlink" title="session局限性"></a>session局限性</h4><p>Session认证机制需要配合 Cookie 才能实现。由于Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session认证。</p><p>注意：</p><ul><li><p>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</p></li><li><p>当前端需要跨域请求后端接口的时候，不推荐使用 Session身份认证机制，推荐使用JWT认证机制。</p></li></ul><p>JWT（英文全称：JSONWeb Token）是目前最流行的跨域认证解决方案。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="/image/node.js-5-5.PNG"></p><p>总结：用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。</p><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p>JWT通常由三部分组成，分别是Header（头部）、Payload（有效荷载）、Signature（签名）。</p><p>三者之间使用英文的“.”分隔，格式如下：</p><p><img src="/image/node.js-5-6.PNG"></p><p>JWT的三个组成部分，从前到后分别是Header、Payload、Signature。</p><p>其中：</p><ul><li>Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。</li><li>Header 和Signature是安全性相关的部分，只是为了保证Token的安全性。</li></ul><p><img src="/image/node.js-5-7.PNG"></p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>客户端收到服务器返回的JWT之后，通常会将它储存在localStorage或sessionStorage中。</p><p>此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下：</p><p><img src="/image/node.js-5-8.PNG"></p><h4 id="在expresss中使用jwt"><a href="#在expresss中使用jwt" class="headerlink" title="在expresss中使用jwt"></a>在expresss中使用jwt</h4><h5 id="1-安装相关的包"><a href="#1-安装相关的包" class="headerlink" title="1.安装相关的包"></a>1.安装相关的包</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jsonwebtoken </span>express-<span class="hljs-keyword">jwt</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>jsonwebtoken 用于生成 JWT 字符串</li><li>express-jwt 用于将 JWT 字符串解析还原成 JSON 对象</li></ul><h5 id="2-导入相关的包"><a href="#2-导入相关的包" class="headerlink" title="2.导入相关的包"></a>2.导入相关的包</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><span class="hljs-keyword">const</span> expressJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br></code></pre></td></tr></table></figure><h5 id="3-定义secret-密钥"><a href="#3-定义secret-密钥" class="headerlink" title="3.定义secret 密钥"></a>3.定义secret 密钥</h5><p>为了保证 JWT 字符串的安全性，防止 JWT字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的secret密钥：</p><p>①当生成 JWT字符串的时候，需要使用secret密钥对用户的信息进行加密，最终得到加密好的JWT字符串</p><p>②当把 JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey</span><br><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;jason1332 No1 ^_^&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="4-在登录成功后生成-JWT-字符串-在登录接口中处理"><a href="#4-在登录成功后生成-JWT-字符串-在登录接口中处理" class="headerlink" title="4.在登录成功后生成 JWT 字符串(在登录接口中处理)"></a>4.在登录成功后生成 JWT 字符串(在登录接口中处理)</h5><p>调用 jsonwebtoken 包提供的sign()方法，将用户的信息加密成JWT字符串，响应给客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// 将 req.body 请求体中的数据，转存为 userinfo 常量</span><br>  <span class="hljs-keyword">const</span> userinfo = req.<span class="hljs-property">body</span><br>  <span class="hljs-comment">// 登录失败</span><br>  <span class="hljs-keyword">if</span> (userinfo.<span class="hljs-property">username</span> !== <span class="hljs-string">&#x27;admin&#x27;</span> || userinfo.<span class="hljs-property">password</span> !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录失败！&#x27;</span>,<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 登录成功</span><br>  <span class="hljs-comment">// TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端</span><br>  <span class="hljs-comment">// 参数1：用户的信息对象</span><br>  <span class="hljs-comment">// 参数2：加密的秘钥</span><br>  <span class="hljs-comment">// 参数3：配置对象，可以配置当前 token 的有效期</span><br>  <span class="hljs-comment">// 记住：千万不要把密码加密到 token 字符中</span><br>  <span class="hljs-keyword">const</span> tokenStr = jwt.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-attr">username</span>: userinfo.<span class="hljs-property">username</span> &#125;, secretKey, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;30s&#x27;</span> &#125;)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录成功！&#x27;</span>,<br>    <span class="hljs-attr">token</span>: tokenStr, <span class="hljs-comment">// 要发送给客户端的 token 字符串</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="5-将JWT-字符串还原为-JSON-对象-设置中间件"><a href="#5-将JWT-字符串还原为-JSON-对象-设置中间件" class="headerlink" title="5.将JWT 字符串还原为 JSON 对象(设置中间件)"></a>5.将JWT 字符串还原为 JSON 对象(设置中间件)</h5><p>这一步非常关键</p><p>使用 unless() 方法指定某些路径不需要进行 token 验证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件</span><br><span class="hljs-comment">// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;))<br></code></pre></td></tr></table></figure><p>注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上</p><p>(一定要放在路由之前)</p><h5 id="6-使用req-user-获取用户信息"><a href="#6-使用req-user-获取用户信息" class="headerlink" title="6.使用req.user 获取用户信息"></a>6.使用req.user 获取用户信息</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/admin/getinfo&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">user</span>)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;获取用户信息成功！&#x27;</span>,<br>    <span class="hljs-attr">data</span>: req.<span class="hljs-property">user</span>, <span class="hljs-comment">// 要发送给客户端的用户信息</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7.错误处理"></a>7.错误处理</h5><p>当使用 express-jwt解析Token字符串时，如果客户端发送过来的Token字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。我们可以通过Express 的错误中间件，捕获这个错误并进行相关的处理，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 这次错误是由 token 解析失败导致的</span><br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-number">401</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;无效的token&#x27;</span>,<br>    &#125;)<br>  &#125;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;未知的错误&#x27;</span>,<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="8-案例"><a href="#8-案例" class="headerlink" title="8.案例"></a>8.案例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><span class="hljs-keyword">const</span> expressJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br><br><span class="hljs-comment">// 允许跨域资源共享</span><br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br><br><span class="hljs-comment">// 解析 post 表单数据的中间件</span><br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br><br><span class="hljs-comment">// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey</span><br><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;jason213 No1 ^_^&#x27;</span><br><br><span class="hljs-comment">// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件</span><br><span class="hljs-comment">// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;))<br><br><span class="hljs-comment">// 登录接口</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// 将 req.body 请求体中的数据，转存为 userinfo 常量</span><br>  <span class="hljs-keyword">const</span> userinfo = req.<span class="hljs-property">body</span><br>  <span class="hljs-comment">// 登录失败</span><br>  <span class="hljs-keyword">if</span> (userinfo.<span class="hljs-property">username</span> !== <span class="hljs-string">&#x27;admin&#x27;</span> || userinfo.<span class="hljs-property">password</span> !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录失败！&#x27;</span>,<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 登录成功</span><br>  <span class="hljs-comment">// TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端</span><br>  <span class="hljs-comment">// 参数1：用户的信息对象</span><br>  <span class="hljs-comment">// 参数2：加密的秘钥</span><br>  <span class="hljs-comment">// 参数3：配置对象，可以配置当前 token 的有效期</span><br>  <span class="hljs-comment">// 记住：千万不要把密码加密到 token 字符中</span><br>  <span class="hljs-keyword">const</span> tokenStr = jwt.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-attr">username</span>: userinfo.<span class="hljs-property">username</span> &#125;, secretKey, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;30s&#x27;</span> &#125;)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录成功！&#x27;</span>,<br>    <span class="hljs-attr">token</span>: tokenStr, <span class="hljs-comment">// 要发送给客户端的 token 字符串</span><br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 这是一个有权限的 API 接口</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/admin/getinfo&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">user</span>)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;获取用户信息成功！&#x27;</span>,<br>    <span class="hljs-attr">data</span>: req.<span class="hljs-property">user</span>, <span class="hljs-comment">// 要发送给客户端的用户信息</span><br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 这次错误是由 token 解析失败导致的</span><br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-number">401</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;无效的token&#x27;</span>,<br>    &#125;)<br>  &#125;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;未知的错误&#x27;</span>,<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1:8888&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>res.send只能发送一次</p><blockquote><p>在代码中，<code>/admin/getinfo</code> 是一个有权限的 API 接口，需要进行身份验证才能访问。这是通过使用 express-jwt 中间件来实现的。</p><p>在以下代码片段中，<code>expressJWT(&#123; secret: secretKey &#125;)</code> 中间件被应用到整个 Express 应用程序，并配置了一个密钥 <code>secretKey</code> 用于验证 JWT 令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;))<br></code></pre></td></tr></table></figure><p>这里使用了 <code>unless()</code> 方法指定了一个例外条件，即以 <code>/api/</code> 开头的路径不需要进行 JWT 令牌验证。因此，只有不以 <code>/api/</code> 开头的路径需要进行验证。</p><p>对于 <code>/admin/getinfo</code> 接口，它没有被排除在 JWT 验证之外，因此在访问该接口时，中间件会首先解析请求头中的 JWT 令牌，并验证其有效性和完整性。如果令牌验证通过，中间件会将解析后的用户信息存储在 <code>req.user</code> 属性中，然后继续执行后续的路由处理程序，从而允许用户访问受限资源。</p><p>如果令牌验证失败（令牌无效、过期或签名不匹配等），中间件会抛出一个 <code>UnauthorizedError</code>，并由全局错误处理中间件捕获。在全局错误处理中间件中，可以根据错误类型返回相应的错误响应。</p><p>总之，<code>/admin/getinfo</code> 接口需要进行身份验证是因为它没有被例外条件排除在 JWT 验证之外，并且只有通过 JWT 令牌验证的用户才能成功访问该接口。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-4-express&amp;cors&amp;mysql</title>
    <link href="/2023/06/03/node.js-4/"/>
    <url>/2023/06/03/node.js-4/</url>
    
    <content type="html"><![CDATA[<h1 id="node-js-4"><a href="#node-js-4" class="headerlink" title="node.js-4"></a>node.js-4</h1><h2 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据</span><br>  <span class="hljs-comment">// 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p>自己手动模拟一个类似于express.urlencoded这样的中间件，来解析 POST 提交到服务器的表单数据。</p><p>实现步骤：</p><p>①定义中间件</p><p>②监听 req的data事件</p><p>③监听 req的end事件</p><p>④使用 querystring模块解析<strong>请求体</strong>数据</p><p>⑤将解析出来的数据对象挂载为 req.body</p><p>⑥将自定义中间件封装为模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 Node.js 内置的 querystring 模块</span><br><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bodyParser</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 定义中间件具体的业务逻辑</span><br>  <span class="hljs-comment">// 1. 定义一个 str 字符串，专门用来存储客户端发送过来的请求体数据</span><br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-comment">// 2. 监听 req 的 data 事件</span><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    str += chunk<br>  &#125;)<br>  <span class="hljs-comment">// 3. 监听 req 的 end 事件</span><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在 str 中存放的是完整的请求体数据</span><br>    <span class="hljs-comment">// console.log(str)</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 把字符串格式的请求体数据，解析成对象格式</span><br>    <span class="hljs-keyword">const</span> body = qs.<span class="hljs-title function_">parse</span>(str)<br>    req.<span class="hljs-property">body</span> = body<br>    <span class="hljs-title function_">next</span>()<br>  &#125;)<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = bodyParser<br><br></code></pre></td></tr></table></figure><p>qs.parse是把字符串转换成对象</p><h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><h3 id="基于cors解决接口跨域问题"><a href="#基于cors解决接口跨域问题" class="headerlink" title="基于cors解决接口跨域问题"></a>基于cors解决接口跨域问题</h3><p>cors是Express的一个第三方中间件。通过安装和配置cors中间件，可以很方便地解决跨域问题。</p><p>使用步骤分为如下3步：</p><p>①运行 npm install cors 安装中间件</p><p>②使用 const cors &#x3D; require(‘cors’) 导入中间件</p><p>③在路由之前调用 app.use(cors()) 配置中间件</p><h4 id="什么是cors"><a href="#什么是cors" class="headerlink" title="什么是cors"></a>什么是cors</h4><p>CORS（Cross-OriginResource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。</p><p>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。</p><p><img src="/image/node.js-4-1.PNG"></p><p>①CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS的接口。</p><p>②CORS 在浏览器中有兼容性。只有支持XMLHttpRequestLevel2 的浏览器，才能正常访问开启了CORS的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</p><h4 id="CORS响应头部"><a href="#CORS响应头部" class="headerlink" title="CORS响应头部"></a>CORS响应头部</h4><p>Access-Control-Allow-Origin</p><p><img src="/image/node.js-4-2.PNG"></p><p>Access-Control-Allow-Headers</p><p><img src="/image/node.js-4-3.PNG"></p><p>Access-Control-Allow-Methods</p><p><img src="/image/node.js-4-4.PNG"></p><h4 id="请求的分类"><a href="#请求的分类" class="headerlink" title="请求的分类"></a>请求的分类</h4><p>客户端在请求CORS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是：</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>同时满足以下两大条件的请求，就属于简单请求：</p><p>① 请求方式：GET、POST、HEAD三者之一</p><p>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width、Content-Type（只有三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）</p><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>只要符合以下任何一个条件的请求，都需要进行预检请求：</p><p>① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型</p><p>② 请求头中包含自定义头部字段</p><p>③ 向服务器发送了 application&#x2F;json 格式的数据</p><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><h3 id="基于JSONP-在前面Ajax笔记中有提到"><a href="#基于JSONP-在前面Ajax笔记中有提到" class="headerlink" title="基于JSONP(在前面Ajax笔记中有提到)"></a>基于JSONP(在前面Ajax笔记中有提到)</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xquery">JSONP（JSON with Padding）是一种使用<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">元素进行跨域请求的方法，它可以绕过同源策略的限制。<span class="hljs-title class_">JSON</span>P通过在页面中动态创建</span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">元素，将需要请求的数据封装在一个回调函数中，然后将该回调函数的名称作为参数传递给服务器。</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">以下是<span class="hljs-title class_">JSON</span>P的工作原理步骤：</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-number">1.</span>在页面中创建一个</span></span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>元素，并将其src属性设置为目标服务器上的URL。该URL包含需要请求的数据以及回调函数的名称作为参数。</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">2.目标服务器接收到请求后，解析URL参数中的回调函数名称，并将需要返回的数据作为参数传递给该回调函数。</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">3.目标服务器返回的响应是一个JavaScript函数调用，该函数调用会执行在页面中事先定义好的回调函数。</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">4.在页面中定义的回调函数会在响应返回时被调用，从而可以在函数内部处理返回的数据。</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">由于</span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">元素的src属性不受同源策略的限制，因此可以从任何域加载脚本。这样就允许你通过在目标服务器上动态生成包装了数据的<span class="hljs-title class_">JavaScript</span>代码，并在浏览器中执行。</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">需要注意的是，<span class="hljs-title class_">JSON</span>P存在一些安全风险，因为它要求你信任目标服务器上返回的代码。恶意的服务器可能会返回恶意代码，导致安全问题。因此，在使用<span class="hljs-title class_">JSON</span>P时，你应该确保只向可信任的服务器发出请求，并仔细验证返回的数据。另外，由于<span class="hljs-title class_">JSON</span>P只支持<span class="hljs-variable constant_">GET</span>请求，不支持<span class="hljs-variable constant_">POST</span>等其他类型的请求。</span></span></span></span><br></code></pre></td></tr></table></figure><h2 id="在项目中操作MySQL"><a href="#在项目中操作MySQL" class="headerlink" title="在项目中操作MySQL"></a>在项目中操作MySQL</h2><p>①安装操作 MySQL数据库的第三方模块（mysql）</p><p>②通过 mysql模块连接到 MySQL 数据库</p><p>③通过 mysql模块执行 SQL 语句</p><p><img src="/image/node.js-4-5.PNG"></p><h3 id="安装MySQL模块"><a href="#安装MySQL模块" class="headerlink" title="安装MySQL模块"></a>安装MySQL模块</h3><p>mysql模块是托管于npm上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> mysql<br></code></pre></td></tr></table></figure><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><p>在使用 mysql模块操作MySQL数据库之前，必须先对 mysql 模块进行必要的配置，主要的配置步骤如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 mysql 模块</span><br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><span class="hljs-comment">// 2. 建立与 MySQL 数据库的连接关系</span><br><span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-comment">// 数据库的 IP 地址</span><br>  <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-comment">// 登录数据库的账号</span><br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin123&#x27;</span>, <span class="hljs-comment">// 登录数据库的密码</span><br>  <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;m_db_01&#x27;</span>, <span class="hljs-comment">// 指定要操作哪个数据库</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="测试mysql-模块能否正常工作"><a href="#测试mysql-模块能否正常工作" class="headerlink" title="测试mysql 模块能否正常工作"></a>测试mysql 模块能否正常工作</h3><p>调用db.query()函数，指定要执行的SQL语句，通过回调函数拿到执行的结果：</p><p><img src="/image/node.js-4-6.PNG"></p><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查询 users 表中所有的数据</span><br><span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;select * from users&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlStr, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 查询数据失败</span><br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 查询数据成功</span><br>  <span class="hljs-comment">// 注意：如果执行的是 select 查询语句，则执行的结果是数组</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br>&#125;) <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向 users 表中，新增一条数据，其中 username 的值为 Spider-Man，password 的值为 pcc123</span><br>/<span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;Spider-Man&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;pcc123&#x27;</span> &#125;<br><span class="hljs-comment">// 定义待执行的 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;insert into users (username, password) values (?, ?)&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr, [user.<span class="hljs-property">username</span>, user.<span class="hljs-property">password</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行 SQL 语句失败了</span><br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 成功了</span><br>  <span class="hljs-comment">// 注意：如果执行的是 insert into 插入语句，则 results 是一个对象</span><br>  <span class="hljs-comment">// 可以通过 affectedRows 属性，来判断是否插入数据成功</span><br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入数据成功!&#x27;</span>)<br>  &#125;<br>&#125;) <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 演示插入数据的便捷方式</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;Spider-Man2&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;pcc4321&#x27;</span> &#125;<br><span class="hljs-comment">// 定义待执行的 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;insert into users set ?&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr, user, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入数据成功&#x27;</span>)<br>  &#125;<br>&#125;) <br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 演示如何更新用户的信息</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;000&#x27;</span> &#125;<br><span class="hljs-comment">// 定义 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;update users set username=?, password=? where id=?&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr, [user.<span class="hljs-property">username</span>, user.<span class="hljs-property">password</span>, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 注意：执行了 update 语句之后，执行的结果，也是一个对象，可以通过 affectedRows 判断是否更新成功</span><br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新成功&#x27;</span>)<br>  &#125;<br>&#125;) <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 演示更新数据的便捷方式</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;aaaa&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;0000&#x27;</span> &#125;<br><span class="hljs-comment">// 定义 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;update users set ? where id=?&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr, [user, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新数据成功&#x27;</span>)<br>  &#125;<br>&#125;) <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除 id 为 5 的用户</span><br> <span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;delete from users where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlStr, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 注意：执行 delete 语句之后，结果也是一个对象，也会包含 affectedRows 属性</span><br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除数据成功&#x27;</span>)<br>  &#125;<br>&#125;) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm命令</title>
    <link href="/2023/05/31/%E5%85%B3%E4%BA%8Enpm%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/05/31/%E5%85%B3%E4%BA%8Enpm%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="关于npm的一些命令"><a href="#关于npm的一些命令" class="headerlink" title="关于npm的一些命令"></a>关于npm的一些命令</h1><blockquote><p>这方面的命令经常忘记，每次都需要查询，因此将每次查询的一些命令做一个记录，方便以后快速回忆</p></blockquote><h2 id="npm和node"><a href="#npm和node" class="headerlink" title="npm和node"></a>npm和node</h2><h3 id="1-版本查看"><a href="#1-版本查看" class="headerlink" title="1.版本查看"></a>1.版本查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node">1. node -v<br>2. npm -v<br></code></pre></td></tr></table></figure><h3 id="2-安装常用命令"><a href="#2-安装常用命令" class="headerlink" title="2.安装常用命令"></a>2.安装常用命令</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>全局安装<br><span class="hljs-code">   npm install 模块名 -g    </span><br><span class="hljs-bullet">- </span>本地安装<br><span class="hljs-code">   npm install 模块名  </span><br><span class="hljs-bullet">- </span>一次性安装多个<br><span class="hljs-code">   npm install 模块名 模块名    </span><br><span class="hljs-bullet">- </span>安装开发时依赖包<br><span class="hljs-code">   npm install 模块名 --save-dev</span><br><span class="hljs-bullet">- </span>安装运行时依赖包<br><span class="hljs-code">   npm install 模块名 --save</span><br></code></pre></td></tr></table></figure><h3 id="查看已安装的包（全局、和本地）"><a href="#查看已安装的包（全局、和本地）" class="headerlink" title="查看已安装的包（全局、和本地）"></a>查看已安装的包（全局、和本地）</h3><h4 id="查看全局已安装（-g-的意思是-global-全局的意思）"><a href="#查看全局已安装（-g-的意思是-global-全局的意思）" class="headerlink" title="查看全局已安装（-g 的意思是 global 全局的意思）"></a>查看全局已安装（<code>-g</code> 的意思是 <code>global</code> 全局的意思）</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm <span class="hljs-built_in">ls</span> <span class="hljs-literal">-g</span><br></code></pre></td></tr></table></figure><p>会发现，会把包的所有依赖也显示出来</p><p>加上层级控制显示深度：<code>--depth 0</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ npm <span class="hljs-keyword">ls</span> -g <span class="hljs-params">--depth</span> 0<br></code></pre></td></tr></table></figure><hr><h4 id="查看项目中已安装"><a href="#查看项目中已安装" class="headerlink" title="查看项目中已安装"></a>查看项目中已安装</h4><p>查看当前项目已安装包（项目跟目录必须有 <a href="https://so.csdn.net/so/search?q=package&spm=1001.2101.3001.7020">package</a>.json 文件）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>同样也是会把所有包的依赖显示出来。同上，加上 <code>--depth 0</code> 就好了。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ npm <span class="hljs-keyword">ls</span> <span class="hljs-params">--depth</span> 0<br><br></code></pre></td></tr></table></figure><p>如果只想显示生产环境依赖的包</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ npm <span class="hljs-keyword">ls</span> <span class="hljs-params">--depth</span> 0 <span class="hljs-params">--prod</span><br></code></pre></td></tr></table></figure><p>只显示开发环境依赖的包</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ npm <span class="hljs-keyword">ls</span> <span class="hljs-params">--depth</span> 0 <span class="hljs-params">--dev</span><br></code></pre></td></tr></table></figure><p>未完待续…</p><h2 id="使用NVM进行node版本管理"><a href="#使用NVM进行node版本管理" class="headerlink" title="使用NVM进行node版本管理"></a>使用NVM进行node版本管理</h2><p>安装的时候需要把电脑上原有的node卸载</p><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>相关命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">nvm off                     <span class="hljs-regexp">//</span> 禁用node.js版本管理(不卸载任何东西)<br>nvm on                      <span class="hljs-regexp">//</span> 启用node.js版本管理<br>nvm install &lt;version&gt;       <span class="hljs-regexp">//</span> 安装node.js的命名 version是版本号 例如：nvm install <span class="hljs-number">8.12</span>.<span class="hljs-number">0</span><br>nvm uninstall &lt;version&gt;     <span class="hljs-regexp">//</span> 卸载node.js是的命令，卸载指定版本的nodejs，当安装失败时卸载使用<br>nvm ls                      <span class="hljs-regexp">//</span> 显示所有安装的node.js版本<br>nvm list available          <span class="hljs-regexp">//</span> 显示可以安装的所有node.js的版本<br>nvm use &lt;version&gt;           <span class="hljs-regexp">//</span> 切换到使用指定的nodejs版本<br>nvm v                       <span class="hljs-regexp">//</span> 显示nvm版本<br>nvm install stable          <span class="hljs-regexp">//</span> 安装最新稳定版<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五月笔试准备（之前忘记上传了）</title>
    <link href="/2023/05/31/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E5%92%8C%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/05/31/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E5%92%8C%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="关于前端笔试和面试的一些知识点"><a href="#关于前端笔试和面试的一些知识点" class="headerlink" title="关于前端笔试和面试的一些知识点"></a>关于前端笔试和面试的一些知识点</h1><h2 id="1-NaN"><a href="#1-NaN" class="headerlink" title="1.NaN"></a>1.NaN</h2><p><img src="/image/prepare-1.PNG"></p><h2 id="2-一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？"><a href="#2-一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？" class="headerlink" title="2.一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？"></a>2.一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">假设出沙漠时有1000根萝卜，那么在出沙漠之前一定不只1000根，那么至少要驮两次才会出沙漠，那样从出发地到沙漠边缘都会有往返的里程，那所走的路程将大于3000公里，故最后能卖出萝卜的数量一定是小于1000根的。<br>那么在走到某一个位置的时候萝卜的总数会恰好是1000根。<br>因为驴每次最多驮1000，那么为了最大的利用驴，第一次卸下的地点应该是使萝卜的数量为2000的地点。<br>因为一开始有3000萝卜，当胡萝卜数大于2000时，路程必须来回三趟，第三趟不用回去，驴必须要驮三次，设驴走X公里第一次卸下萝卜<br>则：<span class="hljs-attribute">5X</span>=1000（吃萝卜的数量，也等于所行走的公里数）<br><span class="hljs-attribute">X</span>=200，也就是说第一次只走200公里<br>验算：驴驮1000根走200公里时剩800根，卸下600根，返回出发地<br>前两次就囤积了1200根，第三次不用返回则剩800根，则总共是2000根萝卜了。<br>第二次驴只需要驮两次，胡萝卜数大于1000时，路程必须来回二趟，第二趟不用回去，设驴走Y公里第二次卸下萝卜<br>则：<span class="hljs-attribute">3Y</span>=1000， <span class="hljs-attribute">Y</span>=333.3<br>验算：驴驮1000根走333.3公里时剩667根，卸下334根，返回第一次卸萝卜地点<br>第二次在途中会吃掉334根萝卜，到第二次卸萝卜地点是加上卸下的334根，刚好是1000根。<br>而此时总共走了：200+333.<span class="hljs-attribute">3</span>=533.3公里，而剩下的466.7公里只需要吃466根萝卜<br>所以可以卖萝卜的数量就是<span class="hljs-attribute">1000-466</span>=534<br></code></pre></td></tr></table></figure><h2 id="3-立即执行函数的实际应用"><a href="#3-立即执行函数的实际应用" class="headerlink" title="3.立即执行函数的实际应用"></a>3.立即执行函数的实际应用</h2><p>这个点可以结合var和let的区别来看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123; <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  <br> &#125;,<span class="hljs-number">1000</span>);  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们的预期结果是0，1，2，3，4，5</p><p>但是实际上打印处理6个6</p><blockquote><p>这是因为var是全局作用域，而setimeout是一个异步函数，for循环又是一个同步执行的。<strong>记住一个口诀 同步 &#x3D;&gt; 异步 &#x3D;&gt; 回调</strong>，所以for循环先执行又因为i是用var定义的。所以同步执行完后i&#x3D;6，接下来执行异步函数输出6个6</p></blockquote><h3 id="用立即执行函数解决这个问题"><a href="#用立即执行函数解决这个问题" class="headerlink" title="用立即执行函数解决这个问题"></a>用立即执行函数解决这个问题</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">lockindex</span>)&#123;<br>    setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(lockindex)<br>    &#125;,<span class="hljs-number">500</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管循环执行结束，i值已经变成了6。但因遇到了自执行函数，当时的i值已经被 lockedIndex锁住了。也可以理解为 自执行函数属于for循环一部分，每次遍历i，自执行函数也会立即执行。所以尽管有延时器，但依旧会保留住立即执行时的i值.<br>简单理解当同步执行的时候把for循环i的值,传递给了延时器,让延时器也能保留i的值,当执行到setimeout时候也能打印出i的值</p><blockquote><p>这里使用IIFE的目的是使用闭包。每一层循环执行IIFE相当于为每一层循环都创建了一个函数作用域</p></blockquote><h3 id="用let的块级作用域解决这个问题"><a href="#用let的块级作用域解决这个问题" class="headerlink" title="用let的块级作用域解决这个问题"></a>用let的块级作用域解决这个问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;     <span class="hljs-comment">//let 代替 var</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  <br> &#125;,<span class="hljs-number">1000</span>);  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量</p><p>setTimeout的回调函数的词法作用域是for循环内部的块作用域，而这个回调函数会作为异步代码在同步代码之后执行，因此它会在词法作用域之外调用；并且当它被调用的时候js引擎会对i进行RHS引用，因此即使for循环已经执行完毕，其每一层循环的作用域依旧被() &#x3D;&gt; console.log(i)维持，因此setTimeout在执行的时候可以访问到每一层循环的i。这实际上形成了我们常说的[闭包]（一个函数在其被定义的词法作用域以外被调用，并且维持着对其被定义的词法作用域中变量的引用）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>let的方法和闭包的方法原理类似，都是每一轮循环产生一个私有的作用域，（LET块级作用域），保存住当前循环i的值，以供后期调用</p><h2 id="4-输入URL回车后经过哪些过程"><a href="#4-输入URL回车后经过哪些过程" class="headerlink" title="4.输入URL回车后经过哪些过程"></a>4.输入URL回车后经过哪些过程</h2><ol><li>解析 URL，判断是否命中缓存（DNS prefetch）</li><li>访问 DNS 服务器，将域名解析获取 IP 地址</li><li>三次握手建立 TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ol><h2 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h2><h3 id><a href="#" class="headerlink" title></a></h3><ol><li><p>var有变量提升机制，把变量的声明提升到作用域的上面，只提升声明不提升调用；</p><p>​</p></li></ol><p>（function也有提升，只提升声明不提升调用）</p><ol start="2"><li><p>var允许重复声明变量，let不允许重复声明变量</p><p>所谓重复就是：不管之前通过什么方法，只要当前栈内存中存在了这个变量，我们使用<code>let/const</code>等重复再声明这个变量就是语法错误。</p></li></ol><blockquote><p>​     在浏览器开辟栈内存供代码自上而下执行之前，不仅有变量提升的操作，还有很多其他的操作 &#x3D;&gt; “词法解析”或者“词法检测”：就是检测当前即将要执行的代码是否会出现“语法错误 SyntaxError”，如果出现错误，代码将不会再执行（第一行都不会执行）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// =&gt; 这行代码就已经不会执行了</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">12</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">13</span>      <span class="hljs-comment">// =&gt; 此行出错：SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><br><br></code></pre></td></tr></table></figure><p>3.let能解决typeof检测时出现的暂时性死区问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br><span class="hljs-comment">// =&gt; ReferenceError: a is not defined</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a)<br><span class="hljs-comment">// =&gt;  &#x27;undefined&#x27; 这是浏览器的bug，本应报错，因为没有a（暂时性死区）</span><br><br></code></pre></td></tr></table></figure><p>用了let后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a)<br><span class="hljs-comment">// =&gt; ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><span class="hljs-keyword">let</span> a<br><br></code></pre></td></tr></table></figure><ol start="4"><li>let创建的全局变量没有给window设置对应的属性</li></ol><p><img src="/image/prepare-2.PNG"></p><ol start="5"><li>let会产生块级作用域</li></ol><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>项目                       css布局上            路由上</p><p>css flex 和grid </p><p>原型链</p><p>节流和防抖</p><p>元素垂直居中</p><p>html 5</p><p>es6</p><p>webpack</p><p>面试官您好，我叫王佳晨，来自杭州电子科技大学计算机学院，计算机科学与技术专业，我求职方向是web前端方向，掌握html,css,js,jquery,ajax,了解过node.js,用vue2开发过一个基于深度学习的美学评价系统，有一个自己的技术博客</p><p>主要实现了两个功能：指定风格的图片生成和图片评分</p><p>输入想要生成的风格，发起get请求，后端处理后给出生成的图片              axios</p><p>导入本地的图片,发起get请求，后端处理给出得分</p><p>在项目中主要是两个大的界面,界面中有根据头部，主体，底部分为三个sfc组件</p><p>通过vue的路由实现跳转</p><p>数组常用方法</p><p>数组遍历方式</p><p>面完了：</p><p>感觉很好，但是很不安，面试主要就问了项目，怎么用vue2去开发的这个项目，我大概介绍了项目的功能模块，包括用到的几个SFC,结合了vue里面的一些知识点介绍了项目。后面就直接问了我有没有参加什么社团，有什么爱好（很奇怪技术岗会问这个，我提到了健身后甚至问了我健身房的价格），后面问我大学时期做得最有成就的一件事是什么，是哪人，有没有女朋友，然后问我每天大概多少多少时间学vue，我说我目前在看node.js，然后近期在开发一个项目，我介绍了功能需求，之后就结束了，换我问，我问了公司的业务现在是vue2还是vue3,然后问了前端方面还有哪些可以努力的地方。</p><p>整体面下来，没有问八股，没有问具体的前端的知识，比如什么是闭包这类，这是最奇怪的。</p>]]></content>
    
    
    <categories>
      
      <category>前端面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-3-express</title>
    <link href="/2023/05/27/node.js-3/"/>
    <url>/2023/05/27/node.js-3/</url>
    
    <content type="html"><![CDATA[<h1 id="node-js-3"><a href="#node-js-3" class="headerlink" title="node.js-3"></a>node.js-3</h1><h2 id="Express简介"><a href="#Express简介" class="headerlink" title="Express简介"></a>Express简介</h2><p>官方给出的概念：Express是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</p><p>通俗的理解：Express的作用和Node.js内置的http模块类似，是专门用来创建 Web服务器的。</p><p>Express 的本质：就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法。</p><p>对于前端程序员来说，最常见的两种服务器，分别是：</p><ul><li>Web 网站服务器：专门对外提供Web网页资源的服务器。</li><li>API 接口服务器：专门对外提供API接口的服务器。</li></ul><p>使用Express，我们可以方便、快速的创建Web 网站的服务器或API 接口的服务器。</p><p>(http内置模块用起来很复杂，开发效率低；Express是基于内置的http模块进一步封装出来的，能够极大的提高开发效率。)</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web 服务器</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象</span><br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span> &#125;)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过 req.query 可以获取到客户端发送过来的 查询参数</span><br>  <span class="hljs-comment">// 注意：默认情况下，req.query 是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<br>&#125;)<br><span class="hljs-comment">// 注意：这里的 :id 是一个动态的参数</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:ids/:username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.params 是动态匹配到的 URL 参数，默认也是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br><br><span class="hljs-comment">// 3. 启动 web 服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>上面的动态参数这样发起请求</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/user/</span><span class="hljs-number">1</span>/<span class="hljs-number">2</span>        <br></code></pre></td></tr></table></figure><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><h4 id="express-static"><a href="#express-static" class="headerlink" title="express.static()"></a>express.static()</h4><p>express提供了一个非常好用的函数，叫做express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public目录下的图片、CSS文件、JavaScript文件对外开放访问了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure><p>现在，你就可以访问 public 目录中的所有文件了：</p><p><code>http://localhost:3000/images/bg.jpg</code></p><p><code>http://localhost:3000/css/style.css</code></p><p><code>http://localhost:3000/js/login.js</code></p><p>注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。</p><p>因此，存放静态文件的目录名不会出现在URL中。</p><h4 id="托管多个静态资源目录"><a href="#托管多个静态资源目录" class="headerlink" title="托管多个静态资源目录"></a>托管多个静态资源目录</h4><p>如果要托管多个静态资源目录，请多次调用express.static()函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>))<br></code></pre></td></tr></table></figure><p>访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。</p><h4 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h4><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public&#x27;</span>,express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>在编写调试Node.js项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐。</p><p>现在，我们可以使用nodemon（<a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a>）这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon会自动帮我们重启项目，极大方便了开发和调试。</p><p><img src="/image/node.js-3-1.PNG"></p><h2 id="Express路由"><a href="#Express路由" class="headerlink" title="Express路由"></a>Express路由</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>广义上讲，<strong>路由就是映射关系</strong>。</p><p>在Express中，路由指的是<strong>客户端的请求与服务器处理函数之间的映射关系</strong>。</p><p>Express中的路由分3部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">METHOD</span>(<span class="hljs-variable constant_">PATH</span>,<span class="hljs-variable constant_">HANDLER</span>)<br></code></pre></td></tr></table></figure><h4 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h4><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。</p><p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则Express会将这次请求，转交给对应的function函数进行处理。</p><p><img src="/image/node.js-3-3.PNG"></p><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><h4 id="最简单的使用方式"><a href="#最简单的使用方式" class="headerlink" title="最简单的使用方式"></a>最简单的使用方式</h4><p>在Express中使用路由最简单的方式，就是把路由挂载到app上，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 挂载路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world.&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Post Request.&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h4><p>为了方便对路由进行模块化的管理，Express不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块。</p><p>将路由抽离为单独模块的步骤如下：</p><p>①创建路由模块对应的 .js文件</p><p>②调用 express.Router()函数创建路由对象</p><p>③向路由对象上挂载具体的路由</p><p>④使用 module.exports 向外共享路由对象</p><p>⑤使用 app.use()函数注册路由模块</p><p>创建1-4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是路由模块</span><br><span class="hljs-comment">// 1. 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建路由对象</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br><span class="hljs-comment">// 3. 挂载具体的路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)<br>&#125;)<br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 4. 向外导出路由对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br><br></code></pre></td></tr></table></figure><p>注册5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// app.use(&#x27;/files&#x27;, express.static(&#x27;./files&#x27;))</span><br><br><span class="hljs-comment">// 1. 导入路由模块</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./03.router&#x27;</span>)<br><span class="hljs-comment">// 2. 注册路由模块</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<br><br><span class="hljs-comment">// 注意： app.use() 函数的作用，就是来注册全局中间件</span><br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>添加前缀</p><p>类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：</p><p><img src="/image/node.js-3-4.PNG"></p><h2 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>中间件（Middleware），特指业务流程的中间处理环节。</p><h4 id="中间件的调用流程"><a href="#中间件的调用流程" class="headerlink" title="中间件的调用流程"></a>中间件的调用流程</h4><p>当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p><p><img src="/image/node.js-3-5.PNG"></p><h4 id="Express中间件的格式"><a href="#Express中间件的格式" class="headerlink" title="Express中间件的格式"></a>Express中间件的格式</h4><p>Express的中间件，本质上就是一个function 处理函数，Express中间件的格式如下：</p><p><img src="/image/node.js-3-6.PNG"></p><p>注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含req 和 res。</p><h4 id="next函数的作用"><a href="#next函数的作用" class="headerlink" title="next函数的作用"></a>next函数的作用</h4><p>next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。</p><p><img src="/image/node.js-3-7.PNG"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="定义中间件函数"><a href="#定义中间件函数" class="headerlink" title="定义中间件函数"></a>定义中间件函数</h4><p><img src="/image/node.js-3-8.PNG"></p><h4 id="全局生效的中间件"><a href="#全局生效的中间件" class="headerlink" title="全局生效的中间件"></a>全局生效的中间件</h4><p>客户端发起的&#x3D;&#x3D;任何请求，到达服务器之后，都会触发的中间件&#x3D;&#x3D;，叫做全局生效的中间件。</p><p>通过调用app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下：</p><p><img src="/image/node.js-3-9.PNG"></p><h4 id="定义全局生效的中间件的简化形式"><a href="#定义全局生效的中间件的简化形式" class="headerlink" title="定义全局生效的中间件的简化形式"></a>定义全局生效的中间件的简化形式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是最简单的中间件函数&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h4><p>多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为req或res<br>对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</p><p><img src="/image/node.js-3-10.PNG"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 这是定义全局中间件的简化形式</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取到请求到达服务器的时间</span><br>  <span class="hljs-keyword">const</span> time = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>  <span class="hljs-comment">// 为 req 对象，挂载自定义属性，从而把时间共享给后面的所有路由</span><br>  req.<span class="hljs-property">startTime</span> = time<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span> + req.<span class="hljs-property">startTime</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span> + req.<span class="hljs-property">startTime</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//可以简化代码</span><br></code></pre></td></tr></table></figure><h4 id="定义多个全局中间件"><a href="#定义多个全局中间件" class="headerlink" title="定义多个全局中间件"></a>定义多个全局中间件</h4><p>可以使用app.use()连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 定义第一个全局中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第1个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><span class="hljs-comment">// 定义第二个全局中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第2个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br><span class="hljs-comment">// 定义一个路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="局部生效的中间件"><a href="#局部生效的中间件" class="headerlink" title="局部生效的中间件"></a>局部生效的中间件</h4><p>不使用 app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw1</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-comment">// 2. 创建路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, mw1, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="定义多个局部生效的中间件"><a href="#定义多个局部生效的中间件" class="headerlink" title="定义多个局部生效的中间件"></a>定义多个局部生效的中间件</h4><p><img src="/image/node.js-3-11.PNG"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>①一定要在路由之前注册中间件(除了错误级别)</p><p>②客户端发送过来的请求，可以连续调用多个中间件进行处理</p><p>③执行完中间件的业务代码之后，不要忘记调用 next()函数</p><p>④为了防止代码逻辑混乱，调用 next()函数后不要再写额外的代码</p><p>⑤连续调用多个中间件时，多个中间件之间，共享req和res对象</p><h3 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h3><h4 id="①应用级别的中间件"><a href="#①应用级别的中间件" class="headerlink" title="①应用级别的中间件"></a>①应用级别的中间件</h4><p>通过app.use() 或app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第1个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="②-路由级别的中间件"><a href="#②-路由级别的中间件" class="headerlink" title="② 路由级别的中间件"></a>② 路由级别的中间件</h4><p>绑定到express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app实例上，路由级别中间件绑定到 router<br>实例上，代码示例如下：</p><p><img src="/image/node.js-3-12.PNG"></p><h4 id="③-错误级别的中间件"><a href="#③-错误级别的中间件" class="headerlink" title="③ 错误级别的中间件"></a>③ 错误级别的中间件</h4><p>错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。</p><p>格式：错误级别中间件的function处理函数中，必须有 4 个形参，形参顺序从前到后，分别是</p><p>(err,req, res, next)。</p><p><strong>注意：错误级别的中间件，必须注册在所有路由之后！</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 1. 定义路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 1.1 人为的制造错误</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;服务器内部发生了错误！&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发生了错误！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Error：&#x27;</span> + err.<span class="hljs-property">message</span>)<br>&#125;)<br><br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h4 id="④-Express-内置的中间件"><a href="#④-Express-内置的中间件" class="headerlink" title="④ Express 内置的中间件"></a>④ Express 内置的中间件</h4><p>自Express4.16.0 版本开始，Express内置了3 个常用的中间件，极大的提高了Express项目的开发效率和体验：</p><p>① express.static 快速托管静态资源的内置中间件，例如：HTML 文件、图片、CSS样式等（无兼容性）</p><p>② express.json 解析JSON格式的请求体数据（有兼容性，仅在4.16.0+版本中可用）</p><p>③ express.urlencoded 解析URL-encoded格式的请求体数据（有兼容性，仅在4.16.0+版本中可用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置</span><br><span class="hljs-comment">// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>())<br><span class="hljs-comment">// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据</span><br>  <span class="hljs-comment">// 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/book&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="⑤-第三方的中间件"><a href="#⑤-第三方的中间件" class="headerlink" title="⑤ 第三方的中间件"></a>⑤ 第三方的中间件</h4><p>非Express官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。</p><p>例如：在<a href="mailto:&#x65;&#120;&#112;&#x72;&#x65;&#x73;&#115;&#x40;&#x34;&#46;&#x31;&#54;&#x2e;&#48;">&#x65;&#120;&#112;&#x72;&#x65;&#x73;&#115;&#x40;&#x34;&#46;&#x31;&#54;&#x2e;&#48;</a>之前的版本中，经常使用body-parser这个第三方中间件，来解析请求体数据。使用步骤如下：</p><p>①运行 npm install body-parser安装中间件</p><p>②使用 require 导入中间件</p><p>③调用 app.use()注册并使用中间件</p><p>注意：Express内置的express.urlencoded中间件，就是基于body-parser这个第三方中间件进一步封装出来的。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五月</title>
    <link href="/2023/05/26/%E8%AE%AD%E7%BB%83%E8%90%A5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/05/26/%E8%AE%AD%E7%BB%83%E8%90%A5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="训练营项目总结"><a href="#训练营项目总结" class="headerlink" title="训练营项目总结"></a>训练营项目总结</h1><p>首先还是特别感谢恒生和学校开展这样的一个训练营，给我提供了一段宝贵的项目经历。我的代码水平比较弱，也没有特别丰富的项目开发经验，开发这样的一个项目对我来讲还是有着诸多挑战。但是这次我作为我们组的组长，必须承担好我这一部分开发的职责，作好项目分工，更进项目进度，确保最终答辩时能够呈现一个完整的项目。</p><p>整个项目周期除去中间的五一假期大概一个月左右，这一个月的学习对我真的有很大的提升。在项目初期的时候，我对项目用到的技术栈都比较陌生，但是为了后期能够比较顺利的进行开发，我前期看了很多前端的知识，迫使自己去学习前端。deadline是第一生产力，这个项目使我学习前端的进度大大加快，提高了我学习的效率，可能也是这个原因，在项目期间我也拿到了实习的offer。</p><p>在整个开发过程中我也认识到了团队协作的重要性，作为一个前后端分离的项目，前后端之间的沟通尤为重要，作为前端，我必须和后端开发成员进行良好的沟通以确保接口的正确性。</p><p>另外感谢一下我们的组员，大家都特别棒，技术水平也很高，和他们共事的过程中我也获得了很大的提升。</p><p>5.25补充</p><p>项目的相关材料打包提交了，我写的前端算是基本上实现了系统的功能。后端有38个接口，由于前端有一个产品的模块由后端的一位队友协助，所以我负责的接口大概是30个，这对我来讲真的是特别大的挑战。可以说我之前完全没有完整的做过前后端结合的项目，唯一的一个智能美学系统也只是做了前端的页面（当时的大部分时间都花在了后端的算法上面，所以那个系统没有接口，也不知道怎么开发接口）。因此，这对我来讲是全新的领域，还好的一点时我在正式进入开发阶段之前已经学完js，jquery,ajax,node-js学了一半，vue2.0学了重点（这些基本都是我4月份到5月初跟着黑马程序员学的），在相关的原理上可以说算是了解了，但是为了赶进度，基本没有亲自写什么前端的代码，看到是看了不少前端的代码，但是和自己实际去写还是有很大的区别。所以后面在正式开发时问题就出现了，写代码的进度很慢，一开始甚至不知道从哪下手，要开发的功能模块很多，前端又只有我一个人，刚开始真的很痛苦。所以在后端没有开发出接口之前，我只能根据自己对这些功能的理解，去慢慢的搭建前端的框架，hui框架的路由问题解决了3天（期间看完了vue2.0的路由部分），后面借助了chatgpt去设计每一个模块的大致框架（1天），研究了两天公司提供的产品模块的参考代码。在后端产出接口时，也就是上个星期五，大致的自己根据参考代码写了产品。后面就开始根据接口不断的修改组件，那几天背还特别疼（莫名其妙的），当时缺乏经验，调接口都是用了yapi的假接口（只有假数据），和真实有很大的出入，直到这周一晚上，我才知道怎么真正的去调用接口（这里也存在没有和后端及时沟通的原因）。好了，那完蛋了，还剩3天时间，这怎么来得及，当时已经想着写好假数据，用固定的数据去演示系统的功能了（前面两年的摸鱼使我在这方面有一手，属于干起了老本行了）。但是后面组员的push，然后加上自己也没有摸鱼，开始疯狂的调接口，改bug。呼，结果还不错，基本的功能都实现了，而且中间还因为和后端的设想不同重新改了部分的逻辑（昨天改的我人麻了），虽然前端应该还存在一些bug，但是对于我这个水平来讲，我对这段时间的自己还挺满意的，毕竟，这只是开始。</p><p>​       chatgpt虽然有取代我的风险，但是真的极大的提高了我搜索的效率，加快了我改bug的进度，respect.</p><p>​       有一点遗憾的是前端的部分还没有部署到线上，今天下午搞了挺久，果然对服务器，计算机网络这块真的比较陌生，终究还是要为摸鱼付出代价😭</p><p>5.26</p><p>​       今天答辩很顺利，我们完成了项目发布时提供的全部需求，并且后端的大佬做了很多创新点，我们比较顺利的拿下了，第一次当队长，碰到的队友很棒，我学到了很多东西。漫漫秋招路，开了一个好头，才刚开始呢，还不能懈怠，这两天<strong>git的用法</strong>得再去熟悉一下，这次前端主要我一个人开发，版本控制上面没有遇到什么问题，但是以后团队开发就不一样了，还是得熟练的使用git，这个事情不能拖。打算出去玩两天，在去实习之前完成vue和node.js的系统学习，leetcode得重新刷起来了，加油，才开始呢…</p>]]></content>
    
    
    <categories>
      
      <category>一点心路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些感概</title>
    <link href="/2023/05/16/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%A6%82/"/>
    <url>/2023/05/16/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%A6%82/</url>
    
    <content type="html"><![CDATA[<h1 id="一些感概"><a href="#一些感概" class="headerlink" title="一些感概"></a>一些感概</h1><p>首先真的特别高兴的一件事是 ——终于拿到了暑期实习的offer,感谢恒生！！！</p><p>   这段时间在开发金融训练营的项目，在开发过程中每天都会遇到一些新的问题，不过，一切相对还是比较的顺利。遇到的关于路由的问题通过看完b站相关的知识后有了初步的思路，然后在请教了他人之后得以顺利的解决。整个过程我现在进行复盘可能觉得没有这么困难，但是中间的一些过程确实还是比较的痛苦，面对未知的情况，有时候真的不知道从何下手，这种时候，换以前的我可能就放弃了，但是我发现必须得push自己，然后用各种方法去尝试，不行就换一种方法，最后实在不行求助他人（因为有时候没有方向的时候你不知道从哪里问起），用时间对搞这些问题，最后总会有所突破，但是不能硬怼，还是得讲究方法。总的来说，做一个完整的项目，然后一直坚持一开始的标准去做，对自己确实有很大的提升。这几天的效率还行，希望继续保持，并有所进步。后面项目开发顺利。</p><p>哈哈哈，拿到offer真的很开心</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>一点心路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack介绍</title>
    <link href="/2023/05/12/webpack/"/>
    <url>/2023/05/12/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><ul><li>模块化（js 的模块化、css 的模块化、资源的模块化）</li><li>组件化（复用现有的 UI 结构、样式、行为）</li><li>规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、 Git 分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><h2 id="webpack-1"><a href="#webpack-1" class="headerlink" title="webpack"></a>webpack</h2><p>webpack 是前端项目工程化的具体解决方案</p><p>主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性<br>能优化等强大的功能。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="创建列表隔行变色项目"><a href="#创建列表隔行变色项目" class="headerlink" title="创建列表隔行变色项目"></a>创建列表隔行变色项目</h4><p>① 新建项目空白目录，并运行 npm init –y 命令，初始化包管理配置文件 package.json<br>② 新建 src 源代码目录<br>③ 新建 src -&gt; index.html 首页和 src -&gt; index.js 脚本文件<br>④ 初始化首页基本的结构<br>⑤ 运行 npm install jquery –S 命令，安装 jQuery<br>⑥ 通过 ES6 模块化的方式导入 jQuery，实现列表隔行变色效果</p><h4 id="在项目中安装-webpack"><a href="#在项目中安装-webpack" class="headerlink" title="在项目中安装 webpack"></a>在项目中安装 webpack</h4><p><code>npm install webpack webpack-cli -D</code>           (-D表示记录到 devDependencies节点中)</p><h4 id="在项目中配置webpack"><a href="#在项目中配置webpack" class="headerlink" title="在项目中配置webpack"></a>在项目中配置webpack</h4><p><img src="/image/vue2.0-1-1.PNG"></p><p>mode 节点的可选值有两个，分别是：<br>① development</p><ul><li>开发环境</li><li>不会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度快，适合在开发阶段使用</li></ul><p>② production</p><ul><li>生产环境</li><li>会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度很慢，仅适合在项目发布阶段使用</li></ul><hr><p>webpack.config.js 是 webpack 的配置文件。webpack 在真正开始打包构建之前，会先读取这个配置文件，<br>从而基于给定的配置，对项目进行打包。<br>注意：由于 webpack 是基于 node.js 开发出来的打包工具，因此在它的配置文件中，支持使用 node.js 相关<br>的语法和模块进行 webpack 的个性化配置</p><h4 id="webpack中的默认约定"><a href="#webpack中的默认约定" class="headerlink" title="webpack中的默认约定"></a>webpack中的默认约定</h4><p>在 webpack 4.x 和 5.x 的版本中，有如下的默认约定：<br>① 默认的打包入口文件为 src -&gt; index.js<br>② 默认的输出文件路径为 dist -&gt; main.js</p><p>注意：可以在 webpack.config.js 中修改打包的默认约定</p><p><img src="/image/vue2.0-1-2.PNG"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的<br>webpack 插件有如下两个：<br>① webpack-dev-server</p><ul><li>类似于 node.js 阶段用到的 nodemon 工具</li><li>每当修改了源代码，webpack 会自动进行项目的打包和构建</li></ul><p>② html-webpack-plugin</p><ul><li>webpack 中的 HTML 插件（类似于一个模板引擎插件）</li><li>可以通过此插件自定制 index.html 页面的内容</li></ul><p>（了解即可，因为vue-cli帮助完成了webpack的相关配置）</p><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块，<br>webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！<br>loader 加载器的作用：协助 webpack 打包处理特定的文件模块。比如：</p><ul><li>css-loader 可以打包处理 .css 相关的文件</li><li>less-loader 可以打包处理 .less 相关的文件</li><li>babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法</li></ul><h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><p>项目开发完成之后，需要使用 webpack 对项目进行打包发布，主要原因有以下两点：<br>① 开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件<br>② 开发环境下，打包生成的文件不会进行代码压缩和性能优化<br>为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布。</p><h4 id="配置webpack的打包发布"><a href="#配置webpack的打包发布" class="headerlink" title="配置webpack的打包发布"></a>配置webpack的打包发布</h4><p>在 package.json 文件的 scripts 节点下，新增 build 命令如下：</p><p><img src="/image/vue2.0-1-3.PNG"></p><p>–model 是一个参数项，用来指定 webpack 的运行模式。production 代表生产环境，会对打包生成的文件<br>进行代码压缩和性能优化。<br>注意：通过 –model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项</p><h4 id="把-JavaScript-文件统一生成到-js-目录中"><a href="#把-JavaScript-文件统一生成到-js-目录中" class="headerlink" title="把 JavaScript 文件统一生成到 js 目录中"></a>把 JavaScript 文件统一生成到 js 目录中</h4><p><img src="/image/vue2.0-1-4.PNG"></p><h4 id="把图片文件统一生成到-image-目录中"><a href="#把图片文件统一生成到-image-目录中" class="headerlink" title="把图片文件统一生成到 image 目录中"></a>把图片文件统一生成到 image 目录中</h4><p>修改 webpack.config.js 中的 url-loader 配置项，新增 outputPath 选项即可指定图片文件的输出路径：</p><p><img src="/image/vue2.0-1-5.PNG"></p><h4 id="自动清理-dist-目录下的旧文件"><a href="#自动清理-dist-目录下的旧文件" class="headerlink" title="自动清理 dist 目录下的旧文件"></a>自动清理 dist 目录下的旧文件</h4><p><img src="/image/vue2.0-1-6.PNG"></p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>Source Map 就是一个信息文件，里面储存着位置信息。也就是说，Source Map 文件中存储着压缩混淆后的<br>代码，所对应的转换前的位置。<br>有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试.</p><p>① 开发环境下：</p><ul><li>建议把 devtool 的值设置为 eval-source-map</li><li>好处：可以精准定位到具体的错误行</li></ul><p>② 生产环境下：</p><ul><li>建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map</li><li>好处：防止源码泄露，提高网站的安全性</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-2-模块</title>
    <link href="/2023/05/09/Node.js-2/"/>
    <url>/2023/05/09/Node.js-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-2"><a href="#Node-js-2" class="headerlink" title="Node.js-2"></a>Node.js-2</h1><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>Node.js中根据模块来源的不同，将模块分为了3 大类，分别是：</p><ul><li>内置模块（内置模块是由Node.js官方提供的，例如fs、path、http等）</li><li>自定义模块（用户创建的每个.js文件，都是自定义模块）</li><li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</li></ul><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如</p><p><img src="/image/node.js-2-1.PNG"></p><p>（后缀名可以省略，node自动补全）</p><p>.</p><h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。</p><p><img src="/image/node.js-2-2.PNG"></p><p>防止全局变量污染</p><h3 id="向外共享模块作用域中的成员"><a href="#向外共享模块作用域中的成员" class="headerlink" title="向外共享模块作用域中的成员"></a>向外共享模块作用域中的成员</h3><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息，打印如下：</p><p><img src="/image/node.js-2-3.PNG"></p><h4 id="module-exports-对象"><a href="#module-exports-对象" class="headerlink" title="module.exports 对象"></a>module.exports 对象</h4><p>在外界使用require导入一个自定义模块的时候，得到module.exports指向的对象</p><p><img src="/image/node.js-2-4.PNG"></p><h4 id="exports对象"><a href="#exports对象" class="headerlink" title="exports对象"></a>exports对象</h4><p>由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了exports对象。默认情况下，exports 和module.exports 指向同一个对象。最终共享的结果，还是以 &#x3D;&#x3D;module.exports指向的对象&#x3D;&#x3D;为准。</p><p><img src="/image/node.js-2-5.PNG"></p><h3 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h3><p>Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖。</p><p>CommonJS规定：</p><p>①每个模块内部，module 变量代表当前模块。</p><p>②module 变量是一个对象，它的exports属性（即module.exports）是对外的接口。</p><p>③加载某个模块，其实是加载该模块的 module.exports属性。require() 方法用于加载模块。</p><h2 id="npm与包"><a href="#npm与包" class="headerlink" title="npm与包"></a>npm与包</h2><p>Node.js中的第三方模块又叫做包。</p><p>就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。</p><blockquote><p>由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时，效率很低。</p><p>包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。</p><p>包和内置模块之间的关系，类似于jQuery和浏览器内置 API 之间的关系。</p></blockquote><p>注意：</p><ul><li>从 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索自己所需要的包</li><li>从 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>  服务器上下载自己需要的包(服务器地址)</li></ul><h3 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h3><p>npm 包管理工具，这个包管理工具随着Node.js的安装包一起被安装到了用户的电脑上。</p><p>npm-v</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p><img src="/image/node.js-2-6.PNG"></p><p>初次装包完成后，在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json 的配置文件。</p><p>其中：</p><p>node_modules 文件夹用来存放所有已安装到项目中的包。require()导入第三方包时，就是从这个目录中查找并加载包。</p><p>package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</p><p>注意：程序员不要手动修改node_modules或package-lock.json文件中的任何代码，npm包管理工具会自动维护它们。</p><h4 id="安装指定版本的包"><a href="#安装指定版本的包" class="headerlink" title="安装指定版本的包"></a>安装指定版本的包</h4><p>默认情况下，使用npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本，例如：</p><p>npm i <a href="mailto:&#x6d;&#111;&#x6d;&#101;&#x6e;&#x74;&#64;&#50;&#46;&#x32;&#50;&#46;&#x32;">&#x6d;&#111;&#x6d;&#101;&#x6e;&#x74;&#64;&#50;&#46;&#x32;&#50;&#46;&#x32;</a></p><h4 id="包的版本规范"><a href="#包的版本规范" class="headerlink" title="包的版本规范"></a>包的版本规范</h4><p>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如2.24.0</p><p>其中每一位数字所代表的的含义如下：</p><p>第1位数字：大版本</p><p>第2位数字：功能版本</p><p>第3位数字：Bug修复版本</p><p>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。</p><h3 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h3><p>npm规定，在项目根目录中，必须提供一个叫做<strong>package.json</strong> 的包管理配置文件。用来记录与项目有关的一些配置信息。例如：</p><ul><li>项目的名称、版本号、描述等</li><li>&#x3D;&#x3D;项目中都用到了哪些包&#x3D;&#x3D;</li><li>哪些包只在开发期间会用到</li></ul><p>那些包在开发和部署时都需要用到</p><h4 id="多人协作问题"><a href="#多人协作问题" class="headerlink" title="多人协作问题"></a>多人协作问题</h4><p>第三方包的体积过大，不方便团队成员之间共享项目源代码。</p><p>解决方案：共享时剔除node_modules</p><h4 id="那么如何记录项目中安装了哪些包"><a href="#那么如何记录项目中安装了哪些包" class="headerlink" title="那么如何记录项目中安装了哪些包"></a>那么如何记录项目中安装了哪些包</h4><p>在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除node_modules目录之后，在团队成员之间共享项目的源代码。</p><p>注意：今后在项目开发中，一定要把node_modules文件夹，添加到.gitignore忽略文件中。</p><h4 id="快速创建-package-json"><a href="#快速创建-package-json" class="headerlink" title="快速创建 package.json"></a>快速创建 package.json</h4><p>npm<br>包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json<br>这个包管理配置文件：</p><p><code>npm init -y</code></p><p>注意：</p><p>①上述命令只能在<strong>英文</strong>的目录下成功运行！所以，<strong>项目文件夹</strong>的名称一定要使用英文命名，不要使用中文，<strong>不能出现空格</strong>。</p><p>②运行 npminstall 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。</p><h4 id="dependencies节点"><a href="#dependencies节点" class="headerlink" title="dependencies节点"></a>dependencies节点</h4><p>package.json文件中，有一个<strong>dependencies</strong>节点，专门用来记录您使用npm install 命令安装了哪些包。</p><h4 id="一次性安装所有的包"><a href="#一次性安装所有的包" class="headerlink" title="一次性安装所有的包"></a>一次性安装所有的包</h4><p>当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。</p><p><img src="/image/node.js-2-7.PNG"></p><h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><p>可以运行npm uninstall 命令，来卸载指定的包：</p><p><code>npm uninstall 包名字</code></p><p>注意：npm uninstall 命令执行成功后，会把卸载的包，自动从package.json的 dependencies中移除掉。</p><h4 id="devDependencies节点"><a href="#devDependencies节点" class="headerlink" title="devDependencies节点"></a>devDependencies节点</h4><p>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies节点中。</p><p>与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中。</p><p>您可以使用如下的命令，将包记录到devDependencies节点中：</p><p><img src="/image/node.js-2-8.PNG"></p><h3 id="解决下包慢的问题"><a href="#解决下包慢的问题" class="headerlink" title="解决下包慢的问题"></a>解决下包慢的问题</h3><p>从淘宝NPM镜像服务器下载</p><h4 id="切换npm的镜像源"><a href="#切换npm的镜像源" class="headerlink" title="切换npm的镜像源"></a>切换npm的镜像源</h4><p>下包的镜像源，指的就是下包的服务器地址。</p><p>npm config get registry</p><p>查看当前下包的镜像地址</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> npm config <span class="hljs-keyword">set</span> registry <span class="hljs-comment">http:</span>//<span class="hljs-comment">registry.npmmirror.com</span><br></code></pre></td></tr></table></figure><p>将下包的镜像源切换成淘宝的镜像源</p><p>npm config get registry</p><p>检查是否下载成功</p><h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><p>为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源。</p><p><img src="/image/node.js-2-9.PNG"></p><p>但是安装的时候报错了</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">Error [ERR_REQUIRE_ESM]: <span class="hljs-built_in">require</span>() of ES Module <span class="hljs-name">C</span>:\Users\JiaChenWang\AppData\Roaming\npm\node_modules\nrm\node_modules\open\index.js <span class="hljs-keyword">from</span> <span class="hljs-name">C</span>:\Users\JiaChenWang\AppData\Roaming\npm\node_modules\nrm\cli.js <span class="hljs-keyword">not</span> supported.<br>Instead change the <span class="hljs-built_in">require</span> of index.js <span class="hljs-keyword">in</span> <span class="hljs-name">C</span>:\Users\JiaChenWang\AppData\Roaming\npm\node_modules\nrm\cli.js to a dynamic <span class="hljs-keyword">import</span>() which is available <span class="hljs-keyword">in</span> all CommonJS modules.<br>    at Object.&lt;anonymous&gt; (<span class="hljs-name">C</span>:\Users\JiaChenWang\AppData\Roaming\npm\node_modules\nrm\cli.<span class="hljs-name">js</span>:<span class="hljs-number">9</span>:<span class="hljs-number">14</span>) &#123;<br>  <span class="hljs-name">code</span>: <span class="hljs-string">&#x27;ERR_REQUIRE_ESM&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个错误消息是由于在使用<code>nrm</code>时，<code>cli.js</code>文件尝试引入一个使用ES模块语法的文件（<code>open/index.js</code>），从而导致错误。在Node.js中，ES模块（ESM）和CommonJS模块是不同的规范，不能混合使用。因此在CommonJS模块中使用<code>require()</code>引入一个ES模块会报错。</p><p>为了解决这个错误，我们需要将<code>cli.js</code>文件中对<code>open/index.js</code>文件的引入方式更改为使用<code>import()</code>来动态引入。举个例子：</p><p>将这行代码：</p><p><code>const open = require(&#39;open&#39;);</code></p><p>改为：</p><p><code>import(&#39;open&#39;).then((open) =&gt; &#123;/*代码操作*/&#125;);</code></p><h3 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h3><h4 id="项目包"><a href="#项目包" class="headerlink" title="项目包"></a>项目包</h4><p>那些被安装到项目的 node_modules目录中的包，都是项目包。</p><p>项目包又分为两类，分别是：</p><ul><li>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</li><li>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li></ul><p><img src="/image/node.js-2-10.PNG"></p><h4 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h4><p>在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。</p><p>全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。</p><p><img src="/image/node.js-2-11.PNG"></p><p>注意：</p><p>①只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</p><p>②判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</p><h4 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h4><p>一个规范的包，它的组成结构，必须符合以下3点要求：</p><p>①包必须以单独的目录而存在</p><p>②包的顶级目录下要必须包含 package.json 这个包管理配置文件</p><p>③package.json 中必须包含name，version，main这三个属性，分别代表包的名字、版本号、包的入口。</p><p>注意：以上3点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：</p><p><a href="https://yarnpkg.com/zh-Hans/docs/package-json">https://yarnpkg.com/zh-Hans/docs/package-json</a></p><h3 id="开发自己的包"><a href="#开发自己的包" class="headerlink" title="开发自己的包"></a>开发自己的包</h3><h4 id="初始化包的基本结构"><a href="#初始化包的基本结构" class="headerlink" title="初始化包的基本结构"></a>初始化包的基本结构</h4><p>①新建 itheima-tools 文件夹，作为包的根目录</p><p>②在 itheima-tools 文件夹中，新建如下三个文件：</p><ul><li>package.json （包管理配置文件）</li><li>index.js          （包的入口文件）</li><li>README.md  （包的说明文档）</li></ul><h4 id="初始化-package-json"><a href="#初始化-package-json" class="headerlink" title="初始化 package.json"></a>初始化 package.json</h4><p><img src="/image/node.js-2-12.PNG"></p><h4 id="在index-js中定义方法"><a href="#在index-js中定义方法" class="headerlink" title="在index.js中定义方法"></a>在index.js中定义方法</h4><h4 id="将不同的功能进行模块化拆分"><a href="#将不同的功能进行模块化拆分" class="headerlink" title="将不同的功能进行模块化拆分"></a>将不同的功能进行模块化拆分</h4><p>①将格式化时间的功能，拆分到 src -&gt; dateFormat.js 中</p><p>②将处理 HTML 字符串的功能，拆分到 src -&gt; htmlEscape.js 中</p><p>③在 index.js 中，导入两个模块，得到需要向外共享的方法</p><p>④在 index.js 中，使用 module.exports把对应的方法共享出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./src/dateFormat&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">escape</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./src/htmlEscape&#x27;</span>)<br><br><span class="hljs-comment">// 向外暴露需要的成员</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  ...date,<br>  ...<span class="hljs-built_in">escape</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>用<code>...</code>将对象里面的功能展开</p><h4 id="编写说明文档"><a href="#编写说明文档" class="headerlink" title="编写说明文档"></a>编写说明文档</h4><p>包根目录中的 README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以markdown 的格式写出来，方便用户参考。</p><p>README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。</p><p>我们所创建的这个包的 README.md 文档中，会包含以下 6 项内容：</p><p>安装方式、导入方式、格式化时间、转义HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议</p><h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><h3 id="优先从缓存中加载"><a href="#优先从缓存中加载" class="headerlink" title="优先从缓存中加载"></a>优先从缓存中加载</h3><p>模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。</p><p>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p><h3 id="内置模块的加载机制"><a href="#内置模块的加载机制" class="headerlink" title="内置模块的加载机制"></a>内置模块的加载机制</h3><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。</p><p>例如，require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p><h3 id="自定义模块的加载机制"><a href="#自定义模块的加载机制" class="headerlink" title="自定义模块的加载机制"></a>自定义模块的加载机制</h3><p>使用 require() 加载自定义模块时，必须指定以.&#x2F; 或 ..&#x2F; 开头的路径标识符。在加载自定义模块时，如果没有指定 .&#x2F; 或 ..&#x2F; 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p><p>同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则Node.js 会按顺序分别尝试加载以下的文件：</p><p>①按照确切的文件名进行加载</p><p>②补全 .js 扩展名进行加载</p><p>③补全 .json 扩展名进行加载</p><p>④补全 .node 扩展名进行加载</p><p>⑤加载失败，终端报错</p><h3 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h3><p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以‘.&#x2F;’ 或 ‘..&#x2F;’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从&#x2F;node_modules 文件夹中加载第三方模块。</p><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</p><p>例如，假设在 ‘C:\Users\itheima\project\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p><p>① C:\Users\itheima\project\node_modules\tools</p><p>② C:\Users\itheima\node_modules\tools</p><p>③ C:\Users\node_modules\tools</p><p>④ C:\node_modules\tools</p><h3 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h3><p>当把目录作为模块标识符，传递给require() 进行加载的时候，有三种加载方式：</p><p>①在被加载的目录下查找一个叫做package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</p><p>②如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</p><p>③如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannotfind module ‘xxx’</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-1</title>
    <link href="/2023/05/08/Node.js-1/"/>
    <url>/2023/05/08/Node.js-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-1"><a href="#Node-js-1" class="headerlink" title="Node.js-1"></a>Node.js-1</h1><h2 id="初识Node-js"><a href="#初识Node-js" class="headerlink" title="初识Node.js"></a>初识Node.js</h2><p>为什么JS可以在浏览器中被执行</p><p><img src="/image/node.js-1-1.PNG"></p><p>为什么JS可以操作DOM和BOM</p><p>每个浏览器都内置了 DOM、BOM这样的API函数，因此，浏览器中的JavaScript才可以调用它们。</p><p><img src="/image/node.js-1-2.PNG"></p><h3 id="浏览器中的JS运行环境"><a href="#浏览器中的JS运行环境" class="headerlink" title="浏览器中的JS运行环境"></a>浏览器中的JS运行环境</h3><p><img src="/image/node.js-1-3.PNG"></p><p>运行环境是指代码正常运行所需的必要环境</p><p>①V8 引擎负责解析和执行JavaScript代码。</p><p>②内置 API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用。</p><h3 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是Node.js</h3><p><strong>Node.js</strong>是一个基于Chrome V8引擎的<strong>JavaScript运行环境</strong></p><p><img src="/image/node.js-1-4.PNG"></p><p>①浏览器是JavaScript的前端运行环境。</p><p>②Node.js是JavaScript的后端运行环境。</p><p>③Node.js 中无法调用 DOM和BOM等浏览器内置 API。</p><h3 id="在-Node-js-环境中执行-JavaScript-代码"><a href="#在-Node-js-环境中执行-JavaScript-代码" class="headerlink" title="在 Node.js 环境中执行 JavaScript 代码"></a>在 Node.js 环境中执行 JavaScript 代码</h3><p>①打开终端</p><p>②输入 node要执行的js文件的路径</p><p>在Windows的powershell或cmd终端中，我们可以通过如下快捷键，来提高终端的操作效率：</p><p>①使用 ↑键，可以快速定位到上一次执行的命令</p><p>②使用 tab键，能够快速补全路径</p><p>③使用 esc键，能够快速清空当前已输入的命令</p><p>④输入 cls命令，可以清空终端</p><h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><blockquote><p>fs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求使fs模块来操作文件，则需要先导入</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="读取指定文件中的内容"><a href="#读取指定文件中的内容" class="headerlink" title="读取指定文件中的内容"></a>读取指定文件中的内容</h3><p>使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(path[,options],callback)<br></code></pre></td></tr></table></figure><ul><li>参数1：必选参数，字符串，表示文件的路径。</li><li>参数2：可选参数，表示以什么编码格式来读取文件。</li><li>参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件成功！&#x27;</span> + dataStr)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="向指定文件写入对应内容"><a href="#向指定文件写入对应内容" class="headerlink" title="向指定文件写入对应内容"></a>向指定文件写入对应内容</h3><p>使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFile</span>(file,data[,options],callback)<br></code></pre></td></tr></table></figure><p>参数解读：</p><ul><li>参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。</li><li>参数2：必选参数，表示要写入的内容。</li><li>参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。</li><li>参数4：必选参数，文件写入完成后的回调函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 fs 文件系统模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 2. 调用 fs.writeFile() 方法，写入文件的内容</span><br><span class="hljs-comment">//    参数1：表示文件的存放路径</span><br><span class="hljs-comment">//    参数2：表示要写入的内容</span><br><span class="hljs-comment">//    参数3：回调函数</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-comment">// 2.1 如果文件写入成功，则 err 的值等于 null</span><br>  <span class="hljs-comment">// 2.2 如果文件写入失败，则 err 的值等于一个 错误对象</span><br>  <span class="hljs-comment">// console.log(err)</span><br><br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功！&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><blockquote><p>1.“&#x2F;”，斜杠表示根目录；</p><p>2.“.&#x2F;”，点斜杠表示当前目录；</p><p>3.“..&#x2F;”，点点斜杠表示父级目录，也就是当前目录的上一级目录。</p></blockquote><h3 id="路径动态拼接问题"><a href="#路径动态拼接问题" class="headerlink" title="路径动态拼接问题"></a>路径动态拼接问题</h3><p>在使用fs模块操作文件时，如果提供的操作路径是以.&#x2F; 或..&#x2F; 开头的相对路径时，很容易出现路径动态拼接错误的问题。</p><p>原因：&#x3D;&#x3D;代码在运行的时候，会以<strong>执行 node 命令时所处的目录</strong>，动态拼接出被操作文件的完整路径。&#x3D;&#x3D;</p><p>解决方案：在使用fs模块操作文件时，直接提供完整的路径，不要提供 .&#x2F;或..&#x2F;开头的相对路径，从而防止路径动态拼接的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件成功！&#x27;</span> + dataStr)<br>&#125;)<br></code></pre></td></tr></table></figure><p>__dirname 表示当前文件所处的目录(两个下划线)</p><h2 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h2><p>path 模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><h3 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h3><p>使用path.join()方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">join</span>([...paths])<br></code></pre></td></tr></table></figure><p>参数解读：</p><ul><li>…paths<code>&lt;string&gt; </code>路径片段的序列</li><li>返回值:<code>&lt;string&gt;</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.<span class="hljs-title function_">readFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./files/1.txt&#x27;</span>), <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理。不要直接使用+进行字符串的拼接</p><h2 id="获取路径中的文件名"><a href="#获取路径中的文件名" class="headerlink" title="获取路径中的文件名"></a>获取路径中的文件名</h2><p>使用 path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">basename</span>(path[,ext])<br></code></pre></td></tr></table></figure><ul><li>path<string> 必选参数，表示一个路径的字符串</string></li><li>ext<string> 可选参数，表示文件扩展名</string></li><li>返回:<string> 表示路径中的最后一部分</string></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 定义文件的存放路径</span><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><br><span class="hljs-comment">// const fullName = path.basename(fpath)</span><br><span class="hljs-comment">// console.log(fullName)</span><br><br><span class="hljs-keyword">const</span> nameWithoutExt = path.<span class="hljs-title function_">basename</span>(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameWithoutExt)<br><br></code></pre></td></tr></table></figure><h3 id="获取路径中的文件扩展名"><a href="#获取路径中的文件扩展名" class="headerlink" title="获取路径中的文件扩展名"></a>获取路径中的文件扩展名</h3><p>使用path.extname()方法，可以获取路径中的扩展名部分，语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">extname</span>(path)<br></code></pre></td></tr></table></figure><ul><li>path<code>&lt;string&gt;</code>必选参数，表示一个路径的字符串</li><li>返回:<code>&lt;string&gt;</code> 返回得到的扩展名字符串</li></ul><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><p>服务器和普通电脑的区别在于，服务器上安装了web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web服务器。</p><p>在Node.js中，我们不需要使用 IIS、Apache等这些第三方 web 服务器软件。因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。</p><h3 id="用HTTP模块创建web服务器"><a href="#用HTTP模块创建web服务器" class="headerlink" title="用HTTP模块创建web服务器"></a>用HTTP模块创建web服务器</h3><p>①导入 http 模块</p><p>②创建 web 服务器实例</p><p>③为服务器实例绑定 request 事件，监听客户端的请求</p><p>④启动服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><span class="hljs-comment">// 3. 为服务器实例绑定 request 事件，监听客户端的请求 服务器实例的.ON()方法</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Someone visit our web server.&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 4. 启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//sever.listen(端口号，cb回调)</span><br></code></pre></td></tr></table></figure><h4 id="req请求对象"><a href="#req请求对象" class="headerlink" title="req请求对象"></a>req请求对象</h4><p><img src="/image/node.js-1-5.PNG"></p><h4 id="res响应对象"><a href="#res响应对象" class="headerlink" title="res响应对象"></a>res响应对象</h4><p><img src="/image/node.js-1-6.PNG"></p><h4 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h4><p><img src="/image/node.js-1-7.PNG"></p><h3 id="根据不同url响应不同html"><a href="#根据不同url响应不同html" class="headerlink" title="根据不同url响应不同html"></a>根据不同url响应不同html</h3><p>①获取请求的 url 地址</p><p>②设置默认的响应内容为 404 Not found</p><p>③判断用户请求的是否为 &#x2F; 或 &#x2F;index.html首页</p><p>④判断用户请求的是否为 &#x2F;about.html 关于页面</p><p>⑤设置 Content-Type 响应头，防止中文乱码</p><p>⑥使用 res.end()把内容响应给客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 1. 获取请求的 url 地址</span><br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// 2. 设置默认的响应内容为 404 Not found</span><br>  <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br>  <span class="hljs-comment">// 3. 判断用户请求的是否为 / 或 /index.html 首页</span><br>  <span class="hljs-comment">// 4. 判断用户请求的是否为 /about.html 关于页面</span><br>  <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/&#x27;</span> || url === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/about.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br>  &#125;<br>  <span class="hljs-comment">// 5. 设置 Content-Type 响应头，防止中文乱码</span><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  <span class="hljs-comment">// 6. 使用 res.end() 把内容响应给客户端</span><br>  res.<span class="hljs-title function_">end</span>(content)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 5.1-5.7</title>
    <link href="/2023/05/07/leetcode5.1-5.7/"/>
    <url>/2023/05/07/leetcode5.1-5.7/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode5-1-5-7"><a href="#leetcode5-1-5-7" class="headerlink" title="leetcode5.1-5.7"></a>leetcode5.1-5.7</h1><h2 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    bool <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">string ransomNote, string magazine</span>) &#123;<br>        unordered_map&lt;int,int&gt; m;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;magazine.<span class="hljs-title function_">size</span>();i++)&#123;<br>            m[magazine[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;ransomNote.<span class="hljs-title function_">size</span>();i++)&#123;<br>            m[ransomNote[i]]--;<br>            <span class="hljs-keyword">if</span>(m[ransomNote[i]]&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>今天出去吃了顿夜宵，晚上刷力扣时间耽搁了，明天补</p><h2 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h2><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h4><p>对于哈希表的应用还是没有头绪，这道题开始也没有想到哈希表的常规作法，然而看了题解才知道哈希表面临去重的问题，对结果向量进行去重会超时，后面这道题还是用了双指针的方法。</p><ol><li>首先要对数组进行排序（这个很关键）</li><li>然后从i&#x3D;0开始遍历，对num[i]进行去重，i&#x3D;1开始，如果相同就跳过这轮循环</li><li>在这轮循环内，分别设置left&#x3D;i+1,right&#x3D;num.length()-1;这是另外两个数的索引，left和right这个区间不断缩小去寻找符合条件的值，同时也要去重，去重是向区间里去重。</li><li>然后进入新的循环，重新寻找符合条件的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    vector&lt;vector&lt;int&gt;&gt; <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">vector&lt;int&gt;&amp; nums</span>) &#123;<br>        <br>        vector&lt;vector&lt;int&gt;&gt; res;<br>        <span class="hljs-title function_">sort</span>(nums.<span class="hljs-title function_">begin</span>(),nums.<span class="hljs-title function_">end</span>());<br>        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-title function_">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>])   <span class="hljs-comment">//这里很关键，tip1</span><br>            <span class="hljs-keyword">continue</span>;<br>            int left=i+<span class="hljs-number">1</span>,right=nums.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    res.<span class="hljs-title function_">push_back</span>(vector&lt;int&gt;&#123;nums[i],nums[left],nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>]) left++;<br>                    right--;<br>                    left++; <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>tip1:</p><blockquote><p>说道去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p><p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p><p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p><p>有同学可能想，这不都一样吗。</p><p>其实不一样！</p><p>都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。</p><p>如果我们的写法是 这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重操作</span><br>   <span class="hljs-keyword">continue</span>;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>   <span class="hljs-keyword">continue</span>;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素</p></blockquote><p>不能有重复的三元组但是三元组内的元素可以重复</p><p>如果判断后一位是否和当前位相同，由于当前位还没有判断是否满足，可能会遗漏三元组中出现重复元素的情况；</p><p>但是如果判断前一位是否相同，由于前一位已经经过了判断，所以可以保证它只是排除了与前一轮放进答案相同的情况。</p><h2 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h2><h2 id="5-4-今天开始加上题目链接"><a href="#5-4-今天开始加上题目链接" class="headerlink" title="5.4(今天开始加上题目链接)"></a>5.4(今天开始加上题目链接)</h2><h3 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="18-四数之和-力扣（Leetcode）"><a href="#18-四数之和-力扣（Leetcode）" class="headerlink" title="18. 四数之和 - 力扣（Leetcode）"></a><a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（Leetcode）</a></h4><p>对于15.三数之和 双指针法就是将原本暴力O(n^3^)的解法，降为O(n^2^)的解法，四数之和的双指针解法就是将原本暴力O(n^4^)的解法，降为O(n^3^)的解法。</p><ul><li>在三数之和的基础上多了一重循环，最后两层循环由双指针法降为O(n)</li><li>target不是固定的数，因此剪枝的逻辑需要改变，仅仅大于target不够，因为负数相加会更小</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    vector&lt;vector&lt;int&gt;&gt; <span class="hljs-title function_">fourSum</span>(<span class="hljs-params">vector&lt;int&gt;&amp; nums, int target</span>) &#123;<br>        vector&lt;vector&lt;int&gt;&gt; res;<br>        <span class="hljs-title function_">sort</span>(nums.<span class="hljs-title function_">begin</span>(),nums.<span class="hljs-title function_">end</span>());<br>        <span class="hljs-keyword">for</span>(int k=<span class="hljs-number">0</span>;k&lt;nums.<span class="hljs-title function_">size</span>();k++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[k]&gt;target&amp;&amp;nums[k]&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-comment">//剪枝</span><br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>&amp;&amp;nums[k]==nums[k-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>(int i=k+<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-title function_">size</span>();i++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[k]+nums[i]&gt;target&amp;&amp;nums[k]+nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i&gt;k+<span class="hljs-number">1</span>&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>])&#123;     <span class="hljs-comment">//这里必须有i&gt;k+1这个判断，否则会有样例无法过，</span><br>                     <span class="hljs-comment">//三数之和a的去重逻辑</span><br>                    <span class="hljs-keyword">continue</span>;                     <span class="hljs-comment">// 如果没有i&gt;k+1,就相当于逻辑变成了          </span><br>                                                   <span class="hljs-comment">// i=k时 i越界与k进行了比较 </span><br>                &#125;<br>                int left=i+<span class="hljs-number">1</span>;<br>                int right=nums.<span class="hljs-title function_">size</span>()-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                    <span class="hljs-keyword">if</span>((long)nums[i]+nums[k]+nums[left]+nums[right]&lt;target)&#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((long)nums[i]+nums[k]+nums[left]+nums[right]&gt;target)&#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        res.<span class="hljs-title function_">push_back</span>(vector&lt;int&gt;&#123;nums[i],nums[k],nums[left],nums[right]&#125;);<br>                        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>]) &#123;<br>                             left++;<br>                        &#125;<br>                        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;(nums[right]==nums[right-<span class="hljs-number">1</span>]))&#123;<br>                             right--;<br>                        &#125;<br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h2><p>今天偷懒了，二叉树的前中后遍历，三道easy</p><h3 id="94-二叉树的中序遍历-力扣（Leetcode）-144-145"><a href="#94-二叉树的中序遍历-力扣（Leetcode）-144-145" class="headerlink" title="94. 二叉树的中序遍历 - 力扣（Leetcode） 144 145"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历 - 力扣（Leetcode）</a> 144 145</h3><p>买一送二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">midtravel</span>(root,result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midtravel</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">midtravel</span>(root-&gt;left,res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">midtravel</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h2><h3 id="递归反转链表"><a href="#递归反转链表" class="headerlink" title="递归反转链表"></a>递归反转链表</h3><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II "></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II </a></h4><p>其实主要是用递归的方法去反转链表的基本思路，写出反转一个链表的递归方法后再逐步优化到选择指定的节点区域反转。</p><p>递归的处理重点是不要跳进递归，用明确的定义来实现算法逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* last = <span class="hljs-built_in">reverse</span>(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点</strong>。</p><p>不用管reverse(head-&gt;next) 里面会怎么样，只要知道这一步返回了剩余部分的反转后的头结点</p><p>如图：</p><p><img src="/image/leetcode-1.PNG"></p><p><img src="/image/leetcode-2.PNG"></p><p>所以，剩下的就是将head-&gt;next 即 2的next 指向1，1的next指向null</p><p>2.在此基础上实现反转前N个节点</p><p>区别：</p><p>1、base case 变为 <code>n == 1</code>，反转一个元素，就是它本身，同时<strong>要记录后驱节点</strong>。</p><p>2、刚才我们直接把 <code>head.next</code> 设置为 null，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 <code>n + 1</code> 个节点），反转之后将 <code>head</code> 连接上。</p><p>3.完成本题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>: ListNode* success=<span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseN</span>(head,right);<br>        &#125;<br>        head-&gt;next=<span class="hljs-built_in">reverseBetween</span>(head-&gt;next,left<span class="hljs-number">-1</span>,right<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseN</span> <span class="hljs-params">(ListNode* head,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            success=head-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* last=<span class="hljs-built_in">reverseN</span>(head-&gt;next,n<span class="hljs-number">-1</span>);<br>        head-&gt;next-&gt;next=head;<br>        head-&gt;next=success;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要注意反转前N个的函数里success即N后面的节点位置要用全局变量</p><h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表 "></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">25. K 个一组翻转链表 </a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;;<br>        ListNode* a,*b;<br>        a=b=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>            b=b-&gt;next;<br>        &#125;<br>        ListNode* newhead=<span class="hljs-built_in">reverse</span>(a,b);<br>        a-&gt;next=<span class="hljs-built_in">reverseKGroup</span>(b,k);<br>        <span class="hljs-keyword">return</span> newhead;<br><br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* a,ListNode* b)</span></span>&#123;<br>        ListNode* pre,*cur,*next;<br>        pre=<span class="hljs-literal">nullptr</span>,cur=a,next=a;<br>        <span class="hljs-keyword">while</span>(cur!=b)&#123;<br>            next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树 "></a><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 </a></h4><p>写递归感觉比以前稍微好那么一点了，还是很受昨天的这句话的启发，”递归的处理重点是不要跳进递归，用明确的定义来实现算法逻辑”。虽然还是很弱，能有一些好的变化还是很开心的。😀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left,root-&gt;right);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);     <br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<span class="hljs-comment">//这两步交换不影响</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><p>传入root,返回值可以不用但是题目要求了</p></li><li><p>节点为空的时候返回</p></li><li><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git--github</title>
    <link href="/2023/05/07/Git--github/"/>
    <url>/2023/05/07/Git--github/</url>
    
    <content type="html"><![CDATA[<h1 id="Git–github"><a href="#Git–github" class="headerlink" title="Git–github"></a>Git–github</h1><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>开源并不意味着完全没有限制，为了限制使用者的使用范围和保护作者的权利，每个开源项目都应该遵守开源许可协议（Open Source License ）。</p><h3 id="常见开源协议"><a href="#常见开源协议" class="headerlink" title="常见开源协议"></a>常见开源协议</h3><p>①BSD（Berkeley Software Distribution）</p><p>② Apache Licence2.0</p><p>③ GPL（GNU General Public License）</p><ul><li>具有传染性的一种开源协议，不允许修改后和衍生的代码做为闭源的商业软件发布和销售</li><li>使用GPL 的最著名的软件项目是：Linux</li></ul><p>④ LGPL（GNULesser General Public License）</p><p>⑤ MIT（Massachusetts Institute ofTechnology, MIT）</p><ul><li>是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息</li><li>使用MIT 的软件项目有：jquery、Node.js</li></ul><h3 id="开源项目托管平台"><a href="#开源项目托管平台" class="headerlink" title="开源项目托管平台"></a>开源项目托管平台</h3><p>专门用于免费存放开源项目源代码的网站，叫做开源项目托管平台。目前世界上比较出名的开源项目托管平台主要有以下3个：</p><ul><li>Github（全球最牛的开源项目托管平台，没有之一）</li><li>Gitlab（对代码私有性支持较好，因此企业用户较多）</li><li>Gitee（又叫做码云，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好）</li></ul><p>注意：以上3个开源项目托管平台，只能托管以Git管理的项目源代码，因此，它们的名字都以Git开头</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>Github是全球最大的开源项目托管平台。因为只支持Git作为唯一的版本控制工具，故名GitHub。</p><p>在Github中，你可以：</p><p>①关注自己喜欢的开源项目，为其点赞打 call</p><p>②为自己喜欢的开源项目做贡献（PullRequest）</p><p>③和开源项目的作者讨论 Bug和提需求（Issues）</p><p>④把喜欢的项目复制一份作为自己的项目进行修改（Fork）</p><p>⑤创建属于自己的开源项目</p><p>⑥etc…</p><h3 id="新建空白远程仓库"><a href="#新建空白远程仓库" class="headerlink" title="新建空白远程仓库"></a>新建空白远程仓库</h3><p><img src="/image/github-1.PNG"></p><p>Github上的远程仓库，有两种访问方式，分别是HTTPS 和 SSH。它们的区别是：</p><p>①HTTPS：零配置；但是每次访问仓库时，需要重复输入Github的账号和密码才能访问成功</p><p>②SSH：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入Github的账号和密码</p><p>注意：在实际开发中，推荐使用SSH的方式访问远程仓库。</p><p>&#x3D;&#x3D;注意，现在github上面的默认主分支为main,下面的图片是未更改前的&#x3D;&#x3D;</p><h3 id="基于HTTPS将远程仓库上传到github"><a href="#基于HTTPS将远程仓库上传到github" class="headerlink" title="基于HTTPS将远程仓库上传到github"></a>基于HTTPS将远程仓库上传到github</h3><p><img src="/image/github-2.PNG"></p><p>完成HTTPS管理之后，后续</p><p>如果本地进行了修改，先将本地仓库维护好，运行git push就能同步</p><h3 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h3><p>SSHkey 的作用：实现本地仓库和Github之间免登录的加密数据传输。</p><p>SSHkey 的好处：免登录身份认证、数据加密传输。</p><p>SSHkey 由两部分组成，分别是：</p><p>①id_rsa（私钥文件，存放于客户端的电脑中即可）</p><p>②id_rsa.pub（公钥文件，需要配置到Github中）</p><h4 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h4><p>①打开 Git Bash</p><p>②粘贴如下的命令，并将 <code>your_email@example.com</code>替换为注册Github账号时填写的邮箱：</p><ul><li><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></li></ul><p>③连续敲击 3 次回车，即可在C:\Users\用户名文件夹.ssh 目录中生成id_rsa 和 id_rsa.pub两个文件</p><h4 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h4><p>①使用记事本打开 id_rsa.pub 文件，复制里面的文本内容</p><p>②在浏览器中登录 Github，点击头像-&gt;Settings-&gt; SSHand GPG Keys -&gt;NewSSH key</p><p>③将 id_rsa.pub 文件中的内容，粘贴到Key对应的文本框中</p><p>④在 Title 文本框中任意填写一个名称，来标识这个Key从何而来</p><h4 id="检测是否配置成功"><a href="#检测是否配置成功" class="headerlink" title="检测是否配置成功"></a>检测是否配置成功</h4><p><img src="/image/github-3.PNG"></p><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h4 id="基于-SSH-将本地仓库上传到-Github"><a href="#基于-SSH-将本地仓库上传到-Github" class="headerlink" title="基于 SSH 将本地仓库上传到 Github"></a>基于 SSH 将本地仓库上传到 Github</h4><p><img src="/image/github-4.PNG"></p><h4 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a>将远程仓库克隆到本地</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">远程仓库的地址</span><br></code></pre></td></tr></table></figure><p>远程仓库的地址通过github获取</p><h2 id="Git-分支-本地主分支还是master"><a href="#Git-分支-本地主分支还是master" class="headerlink" title="Git 分支(本地主分支还是master)"></a>Git 分支(本地主分支还是master)</h2><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。</p><p>不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发</p><p><img src="/image/github-5.PNG"></p><h3 id="master主分支"><a href="#master主分支" class="headerlink" title="master主分支"></a>master主分支</h3><p>在初始化本地Git仓库的时候，Git默认已经帮我们创建了一个名字叫做master 的分支。通常我们把这个master分支叫做主分支。在实际工作中，&#x3D;&#x3D;master 主分支&#x3D;&#x3D;的作用是：用来保存和记录整个项目已完成的功能代码。</p><p>因此，不允许程序员直接在 master分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。</p><h3 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h3><p>由于程序员不能直接在master分支上进行功能的开发，所以就有了功能分支的概念。</p><p>功能分支指的是专门用来开发新功能的分支，它是临时从master主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到master主分支上。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p><code>git branch</code></p><p><img src="/image/github-6.PNG"></p><h3 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h3><p><code>git branch 分支名称</code></p><p>是基于当前所处的分支创建的，新分支中的代码和当前分支完全一样。</p><p><img src="/image/github-7.PNG"></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p><code>git checkout login</code></p><p>切换到login分支</p><h3 id="分支的快速创建和切换"><a href="#分支的快速创建和切换" class="headerlink" title="分支的快速创建和切换"></a>分支的快速创建和切换</h3><p><code>git checkout -b 分支名称</code></p><p>创建新分支并且切换到这个分支上</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到master主分支上：</p><p><img src="/image/github-8.PNG"></p><h3 id="删除功能分支"><a href="#删除功能分支" class="headerlink" title="删除功能分支"></a>删除功能分支</h3><p>当把功能分支的代码合并到master主分支上以后，就可以使用如下的命令，删除对应的功能分支</p><p><img src="/image/github-9.PNG"></p><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git就没法干净的合并它们。<br>此时，我们需要打开这些包含冲突的文件然后手动解决冲突。</p><p><img src="/image/github-10.PNG"></p><h2 id="Git分支（远程分支）"><a href="#Git分支（远程分支）" class="headerlink" title="Git分支（远程分支）"></a>Git分支（远程分支）</h2><h3 id="将本地分支推送到远程仓库"><a href="#将本地分支推送到远程仓库" class="headerlink" title="将本地分支推送到远程仓库"></a>将本地分支推送到远程仓库</h3><p><img src="/image/github-11.PNG"></p><h3 id="查看远程仓库中所有的分支列表"><a href="#查看远程仓库中所有的分支列表" class="headerlink" title="查看远程仓库中所有的分支列表"></a>查看远程仓库中所有的分支列表</h3><p><code>git remote show 远程仓库名称</code>  默认为origin</p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：</p><p><img src="/image/github-12.PNG"></p><p>git checkout pay 下载过来后本地的分支也叫pay</p><h3 id="拉取远程分支最新的代码"><a href="#拉取远程分支最新的代码" class="headerlink" title="拉取远程分支最新的代码"></a>拉取远程分支最新的代码</h3><p>远程分支的中的代码发生改变时，将本地仓库的进行更新</p><p><img src="/image/github-13.PNG"></p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p><img src="/image/github-14.PNG"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/05/05/Git/"/>
    <url>/2023/05/05/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul><li>版本控制软件是一个用来记录文件变化，以便将来查阅特定版本修订情况的系统，因此有时也叫做“版本控制系统”。</li><li>把手工管理文件版本的方式，改为由软件管理文件的版本；这个负责管理文件版本的软件，叫做“版本控制软件”。</li></ul><h2 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h2><p>Git是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。</p><p>Git之所以快速和高效，主要依赖于它的如下两个特性：</p><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>Git快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git<br>不再重新存储该文件，而是只保留一个链接指向之前存储的文件。</p><p>缺点：占用磁盘空间较大</p><p>优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。</p><p>特点：空间换时间</p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>特性：</p><p>①断网后依旧可以在本地对项目进行版本管理</p><p>②联网后，把本地修改的记录同步到云端服务器即可</p><h3 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h3><p>使用Git管理的项目，拥有三个区域，分别是工作区、暂存区、Git仓库。</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>已修改表示修改了文件，但还没将修改的结果放到暂存区</p><p>已暂存表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中</p><p>已提交表示文件已经安全地保存在本地的Git 仓库中</p><h3 id="基本的Git工作流程"><a href="#基本的Git工作流程" class="headerlink" title="基本的Git工作流程"></a>基本的Git工作流程</h3><p>①在工作区中修改文件</p><p>②将你想要下次提交的更改进行暂存</p><p>③提交更新，找到暂存区的文件，将快照永久性存储到 Git仓库</p><h2 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h2><h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><blockquote><p>安装完Git之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过Git对项目进行版本管理的时候，Git需要使用这些基本信息，来记录是谁对项目进行了操作：</p><p>注意：如果使用了–global选项，那么该命令只需要运行一次，即可永久生效。</p></blockquote><p><img src="/image/git-1.PNG"></p><p>通过git config 来对git进行相关配置</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p><img src="/image/git-2.PNG"></p><h3 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h3><p><img src="/image/git-3.PNG"></p><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><h3 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h3><p>获取</p><p>①将尚未进行版本控制的本地目录转换为 Git仓库</p><p>②从其它服务器克隆一个已存在的Git仓库</p><blockquote><p>如果自己有一个尚未进行版本控制的项目目录，想要用Git来控制它，需要执行如下两个步骤：</p><p>①在项目目录中，通过鼠标右键打开“GitBash”</p><p>②执行 git init 命令将当前的目录转化为Git 仓库</p><p>工作区就是git初始化后本地目录下不包括.git目录的文件</p><p>gitinit 命令会创建一个名为 .git的隐藏目录，&#x3D;&#x3D;这个.git 目录就是当前项目的 Git 仓库&#x3D;&#x3D;，里面包含了初始的必要文件，这些文件是Git仓库的必要组成部分。</p><p>暂存区一般存放在在.git目录下的index文件</p></blockquote><h3 id="工作区中文件的4种状态"><a href="#工作区中文件的4种状态" class="headerlink" title="工作区中文件的4种状态"></a>工作区中文件的4种状态</h3><p><img src="/image/git-4.PNG"></p><h3 id="检查文件的状态"><a href="#检查文件的状态" class="headerlink" title="检查文件的状态"></a>检查文件的状态</h3><p>可以使用<code>git status</code> 命令查看文件处于什么状态</p><p>使用git status 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中-s 是–short 的简写形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">status</span> -s<br>git <span class="hljs-built_in">status</span> <span class="hljs-comment">--short</span><br></code></pre></td></tr></table></figure><p>(一般情况下，一个<code>-</code>后面接的是单个字母，两个<code>-</code>后面接的是单词)</p><h3 id="1-跟踪新文件"><a href="#1-跟踪新文件" class="headerlink" title="1.跟踪新文件"></a>1.跟踪新文件</h3><p>使用命令<code>git add</code>开始跟踪一个文件。所以，要跟踪 index.html文件，运行如下的命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git add index.html<br></code></pre></td></tr></table></figure><p>放入暂存区</p><h3 id="2-提交更新"><a href="#2-提交更新" class="headerlink" title="2.提交更新"></a>2.提交更新</h3><p>现在暂存区中有一个index.html文件等待被提交到 Git仓库中进行保存。可以执行<code>git commit</code> 命令进行提交,其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述：</p><p><img src="/image/git-5.PNG"></p><p>操作过程</p><p><img src="/image/git-6.PNG"></p><h3 id="3-对已提交的文件进行修改"><a href="#3-对已提交的文件进行修改" class="headerlink" title="3.对已提交的文件进行修改"></a>3.对已提交的文件进行修改</h3><p>目前，index.html文件已经被Git跟踪，并且工作区和Git仓库中的 index.html文件内容保持一致。当我们修改了工作区中index.html的内容之后，再次运行git status 和git status -s 命令，会看到如下的内容</p><p><img src="/image/git-7.PNG"></p><p>文件 index.html 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。</p><p>注意：修改过的、没有放入暂存区的文件前面有红色的 M 标记。</p><p>​            绿色的Modefied表示已修改被放入暂存区</p><h3 id="4-暂存已修改的文件"><a href="#4-暂存已修改的文件" class="headerlink" title="4.暂存已修改的文件"></a>4.暂存已修改的文件</h3><p>目前，工作区中的index.html文件已被修改，如果要暂存这次修改，需要再次运行gitadd 命令，这个命令是个多功能的命令，主要有如下3个功效：</p><p>①可以用它开始跟踪新文件</p><p>②把已跟踪的、且已修改的文件放到暂存区</p><p>③把有冲突的文件标记为已解决状态</p><h3 id="5-提交已暂存的文件"><a href="#5-提交已暂存的文件" class="headerlink" title="5.提交已暂存的文件"></a>5.提交已暂存的文件</h3><p>再次运行git commit -m “提交消息”命令，即可将暂存区中记录的index.html的快照，提交到 Git仓库中进行保存</p><p>345操作流程</p><p><img src="/image/git-8.PNG"></p><h3 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h3><p>撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成 Git仓库中所保存的版本。</p><p>操作的结果：所有的修改会丢失，且无法恢复！危险性比较高，请慎重操作！</p><p><img src="/image/git-9.PNG"></p><p><code>git checkout --index.html </code></p><p>撤销操作的本质：用 Git仓库中保存的文件，覆盖工作区中指定的文件</p><h3 id="向暂存区中一次添加多个文件"><a href="#向暂存区中一次添加多个文件" class="headerlink" title="向暂存区中一次添加多个文件"></a>向暂存区中一次添加多个文件</h3><p><code>git add .</code></p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p><code>git reset HEAD 要移除的文件名称 </code></p><p><code>git reset HEAD .</code>移除全部</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>Git标准的工作流程是工作区 → 暂存区 → Git仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到Git仓库，这时候Git工作的流程简化为了工作区 → Git仓库。</p><p>Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上-a选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过gitadd 步骤：</p><p><code>git commit -a -m &quot;&quot;</code></p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>从Git仓库中移除文件的方式有两种：</p><p>①从 Git 仓库和工作区中同时移除对应的文件</p><p>②只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p><p><img src="/image/git-10.PNG"></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。</p><p>文件.gitignore的格式规范如下：</p><p>①以 # 开头的是注释</p><p>②以 &#x2F; 结尾的是目录</p><p>③以 &#x2F; 开头防止递归</p><p>④以 ! 开头表示取反</p><p>⑤可以使用 glob模式进行文件和文件夹的匹配（glob指简化了的正则表达式）</p><h4 id="glob模式"><a href="#glob模式" class="headerlink" title="glob模式"></a>glob模式</h4><p>简化了的正则表达式</p><p>①星号 * 匹配零个或多个任意字符</p><p>② [abc] 匹配任何一个列在方括号中的字符（此案例匹配一个a或匹配一个 b或匹配一个c）</p><p>③ 问号 ? 只匹配一个任意字符</p><p>④ 在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9]表示匹配所有0到9的数字）</p><p>⑤ 两个星号 ** 表示匹配任意中间目录（比如a&#x2F;**&#x2F;z可以匹配a&#x2F;z、a&#x2F;b&#x2F;z或a&#x2F;b&#x2F;c&#x2F;z等）</p><p><img src="/image/git-11.PNG"></p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p><code>git log</code></p><p><img src="/image/git-12.PNG"></p><h3 id="回退到指定版本"><a href="#回退到指定版本" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h3><p><img src="/image/git-13.PNG"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax-1-接口</title>
    <link href="/2023/05/04/AJAX/"/>
    <url>/2023/05/04/AJAX/</url>
    
    <content type="html"><![CDATA[<h1 id="AJAX-1"><a href="#AJAX-1" class="headerlink" title="AJAX-1"></a>AJAX-1</h1><h2 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h2><p>服务器：负责存放和对外提供资源的电脑</p><p>客户端：负责获取和消费资源的电脑</p><h2 id="URL地址"><a href="#URL地址" class="headerlink" title="URL地址"></a>URL地址</h2><p>统一资源定位符，用于标识互联网上每个资源的唯一存放位置</p><p>组成部分：</p><ol><li>客户端与服务器之间的通信协议</li><li>存资源的服务器名称</li><li>资源在服务器上具体的存放位置</li></ol><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><ol><li>请求-处理-响应</li></ol><h2 id="服务器对外提供的资源"><a href="#服务器对外提供的资源" class="headerlink" title="服务器对外提供的资源"></a>服务器对外提供的资源</h2><p>网页中的数据也是服务器对外提供的一种资源</p><h3 id="如何请求数据"><a href="#如何请求数据" class="headerlink" title="如何请求数据"></a>如何请求数据</h3><p>请求-处理-响应</p><p>如果要在网页中请求服务器上的数据资源，则需要用到 &#x3D;&#x3D;XMLHttpRequest对象&#x3D;&#x3D;.</p><p>XMLHttpRequest（简称 xhr）是浏览器提供的js 成员，通过它，可以请求服务器上的数据资源。</p><p>最简单的用法 var xhrObj &#x3D; new XMLHttpRequest()</p><h3 id="资源的请求方式"><a href="#资源的请求方式" class="headerlink" title="资源的请求方式"></a>资源的请求方式</h3><blockquote><p>客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为get和post请求。</p><p>get 请求通常用于获取服务端资源（向服务器要资源）</p><p>​      例如：根据 URL地址，从服务器获取HTML文件、css文件、js文件、图片文件、数据资源等</p><p>post 请求通常用于向服务器提交数据（往服务器发送资源）</p><p>​      例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作</p></blockquote><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>Ajax的全称是AsynchronousJavascript And XML（异步 JavaScript和XML）。</p><p>通俗的理解：在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax。</p><p>应用场景：用户名检测，数据增删改查，数据分页</p><h2 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h2><p>浏览器中提供的 XMLHttpRequest 用法比较复杂，所以jQuery对XMLHttpRequest进行了封装，提供了一系列Ajax相关的函数，极大地降低了 Ajax 的使用难度。</p><ul><li>$.get()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">get</span>(url, [data], [callback])<br>data  可选，请求资源需要携带的参数  <br>callback 可选,求成功时的回调函数<br><br>&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnGETINFO&quot;</span>&gt;</span>发起单参数的GET请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      $(<span class="hljs-string">&#x27;#btnGETINFO&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        $.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><ul><li>$.post()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">post</span>(url,[data],[callback])<br>data 要提交的数据  <br>callback 数据提交成功后的回调函数<br><br>&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnPOST&quot;</span>&gt;</span>发起POST请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      $(<span class="hljs-string">&#x27;#btnPOST&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        $.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>, &#123; <span class="hljs-attr">bookname</span>: <span class="hljs-string">&#x27;水浒传&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;施耐庵&#x27;</span>, <span class="hljs-attr">publisher</span>: <span class="hljs-string">&#x27;天津图书出版社&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> <span class="hljs-comment">//res是提交成功后服务器返回的数据</span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D;$.ajax()&#x3D;&#x3D;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;&#x27;</span>,   <span class="hljs-comment">//请求的方式</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,     <span class="hljs-comment">//请求的url地址</span><br>  <span class="hljs-attr">data</span>:&#123;&#125;,      <span class="hljs-comment">//这次请求要携带的数据,没有数据时可以省略</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;&#125;   <span class="hljs-comment">//回调函数</span><br>&#125;)<span class="hljs-comment">//配置对象</span><br><br></code></pre></td></tr></table></figure><p>发起get请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">data</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)<br>&#125;)<br>  <br>&lt;script&gt;<br> $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&#x27;#btnGET&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>,<br>          <span class="hljs-attr">data</span>: &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">1</span><br>          &#125;,<br>          <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>          &#125;<br>        &#125;)<br>      &#125;)<br>&#125;)<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p>发起post请求（一样的逻辑）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnPOST&quot;</span>&gt;</span>发起POST请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      $(<span class="hljs-string">&#x27;#btnPOST&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        $.<span class="hljs-title function_">ajax</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">data</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">bookname</span>: <span class="hljs-string">&#x27;史记&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;司马迁&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">publisher</span>: <span class="hljs-string">&#x27;上海图书出版社&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>使用ajax请求数据时，被请求的URL地址，就叫做数据接口。</li><li>每个接口必须有请求方式。</li></ul><h3 id="接口的请求过程"><a href="#接口的请求过程" class="headerlink" title="接口的请求过程"></a>接口的请求过程</h3><h4 id="1-get"><a href="#1-get" class="headerlink" title="1.get"></a>1.get</h4><p><img src="/image/ajax-1.PNG"></p><h4 id="2-post"><a href="#2-post" class="headerlink" title="2.post"></a>2.post</h4><p>​    <img src="/image/ajax-2.PNG"></p><h3 id="接口的测试工具"><a href="#接口的测试工具" class="headerlink" title="接口的测试工具"></a>接口的测试工具</h3><p>postman</p><h4 id="使用postman测试GET接口"><a href="#使用postman测试GET接口" class="headerlink" title="使用postman测试GET接口"></a>使用postman测试GET接口</h4><p>参数部分选params</p><h4 id="使用postman测试post接口"><a href="#使用postman测试post接口" class="headerlink" title="使用postman测试post接口"></a>使用postman测试post接口</h4><p>参数部分选择body面板并勾选数据格式</p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><p>接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol><li>接口名称</li><li>接口URL</li><li>调用方式</li><li>参数格式</li><li>响应格式</li><li>返回示例</li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax-5-HTTP</title>
    <link href="/2023/05/04/Ajax-5/"/>
    <url>/2023/05/04/Ajax-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax-5"><a href="#Ajax-5" class="headerlink" title="Ajax-5"></a>Ajax-5</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>网页内容又叫做超文本，因此网页内容的传输协议又叫做超文本传输协议（HyperText Transfer Protocol），简称 HTTP协议。</p><p>HTTP协议采用了请求&#x2F;响应 的交互模型。</p><p><img src="/image/ajax-9.PNG"></p><h3 id="HTTP请求消息"><a href="#HTTP请求消息" class="headerlink" title="HTTP请求消息"></a>HTTP请求消息</h3><p>也叫HTTP请求报文</p><p>组成部分</p><p><img src="/image/ajax-10.PNG"></p><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h4><ul><li>请求行由请求方式、URL和 HTTP 协议版本 3个部分组成，他们之间使用空格隔开。</li></ul><h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.请求头部</h4><ul><li><p>请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。</p><p>请求头部由多行键&#x2F;值对 组成，每行的键和值之间用英文的冒号分隔。</p></li></ul><h4 id="3-空行"><a href="#3-空行" class="headerlink" title="3.空行"></a>3.空行</h4><ul><li><p>最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。</p><p>请求消息中的空行，用来分隔请求头部与请求体。</p></li></ul><h4 id="4-请求体"><a href="#4-请求体" class="headerlink" title="4.请求体"></a>4.请求体</h4><ul><li><p>请求体中存放的，是要通过POST 方式提交到服务器的数据。</p><p>(只有POST请求才有请求体)</p></li></ul><h3 id="HTTP响应消息"><a href="#HTTP响应消息" class="headerlink" title="HTTP响应消息"></a>HTTP响应消息</h3><p>响应报文</p><p><img src="/image/ajax-11.PNG"></p><h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><p>状态行由 HTTP协议版本、状态码和状态码的描述文本3 个部分组成，他们之间使用空格隔开;</p><h4 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h4><p>响应头部用来描述服务器的基本信息。响应头部由多行 键&#x2F;值对 组成，每行的键和值之间用英文的冒号分隔。</p><h4 id="3-空行-1"><a href="#3-空行-1" class="headerlink" title="3.空行"></a>3.空行</h4><p>在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。</p><p>响应消息中的空行，用来分隔响应头部与响应体。</p><h4 id="4-响应体"><a href="#4-响应体" class="headerlink" title="4.响应体"></a>4.响应体</h4><p>存放服务器给客户端的响应内容</p><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p><img src="/image/ajax-12.PNG"></p><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p>HTTP 响应状态码（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态</p><p><img src="/image/ajax-13.PNG"></p><h4 id="1-2-成功相关响应状态码"><a href="#1-2-成功相关响应状态码" class="headerlink" title="1.2**成功相关响应状态码"></a>1.2**成功相关响应状态码</h4><table><thead><tr><th>状态码</th><th>英文</th><th>中文描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，一般用于GET或POST</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源，通常用于 POST 或 PUT 请求</td></tr></tbody></table><h4 id="2-3-重定向相关"><a href="#2-3-重定向相关" class="headerlink" title="2.3**重定向相关"></a>2.3**重定向相关</h4><p>表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的3**类型的状态码如下：</p><table><thead><tr><th align="center">状态码</th><th align="center">英文</th><th>中文描述</th></tr></thead><tbody><tr><td align="center">301</td><td align="center">Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">304</td><td align="center">Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><h4 id="3-4-客户端错误相关的响应状态码"><a href="#3-4-客户端错误相关的响应状态码" class="headerlink" title="3.4**客户端错误相关的响应状态码"></a>3.4**客户端错误相关的响应状态码</h4><table><thead><tr><th align="center">状态码</th><th align="center">英文</th><th>中文描述</th></tr></thead><tbody><tr><td align="center">400</td><td align="center">Bad Request</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr><td align="center">408</td><td align="center">Request Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时</td></tr></tbody></table><h4 id="4-5-服务端错误相关的响应状态码"><a href="#4-5-服务端错误相关的响应状态码" class="headerlink" title="4.5**服务端错误相关的响应状态码"></a>4.5**服务端错误相关的响应状态码</h4><table><thead><tr><th align="center">状态码</th><th align="center">英文</th><th>中文描述</th></tr></thead><tbody><tr><td align="center">500</td><td align="center">Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有 GET 和 HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax-3-xhr</title>
    <link href="/2023/05/04/Ajax-3/"/>
    <url>/2023/05/04/Ajax-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax-3"><a href="#Ajax-3" class="headerlink" title="Ajax-3"></a>Ajax-3</h1><h2 id="xhr基本使用"><a href="#xhr基本使用" class="headerlink" title="xhr基本使用"></a>xhr基本使用</h2><p>XMLHttpRequest（简称xhr）是浏览器提供的Javascript对象，通过它，可以请求服务器上的数据资源。之前所学的 jQuery中的Ajax函数，就是基于xhr对象封装出来的。</p><h3 id="使用xhr发起GET请求"><a href="#使用xhr发起GET请求" class="headerlink" title="使用xhr发起GET请求"></a>使用xhr发起GET请求</h3><p>①创建 xhr 对象</p><p>②调用 xhr.open() 函数</p><p>③调用 xhr.send() 函数</p><p>④监听 xhr.onreadystatechange事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 创建 XHR 对象</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. 调用 open 函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. 调用 send 函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-title function_">send</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 4. 监听 onreadystatechange 事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<span class="hljs-comment">//xhr.status不是返回数据中的status</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 获取服务器响应的数据</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><img src="/image/ajax-5.PNG"></p><h4 id="带参数GET请求"><a href="#带参数GET请求" class="headerlink" title="带参数GET请求"></a>带参数GET请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)<br><span class="hljs-variable constant_">URL</span>地址末尾放上参数<br>?键=值&amp;键=值<br></code></pre></td></tr></table></figure><h4 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h4><p>查询字符串（URL参数）是指在URL的末尾加上用于向服务器发送信息的字符串（变量）。</p><p>（get携带参数的本质：无论使用<code>$.ajax()</code>，还是使用$.get()，又或者直接使用xhr对象发起GET请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到URL地址的后面，发送到服务器的。）</p><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>使用英文字符去表示非英文字符</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">浏览器提供了 URL 编码与解码的 API，分别是：<br><span class="hljs-function"><span class="hljs-title">encodeURI</span><span class="hljs-params">()</span></span>  编码的函数<br><span class="hljs-function"><span class="hljs-title">decodeURI</span><span class="hljs-params">()</span></span>  解码的函数<br><span class="hljs-function"><span class="hljs-title">encodeURI</span><span class="hljs-params">(<span class="hljs-string">&#x27;&#x27;</span>)</span></span><span class="hljs-comment">//传字符串参数</span><br><span class="hljs-function"><span class="hljs-title">decodeURI</span><span class="hljs-params">(<span class="hljs-string">&#x27;&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><h3 id="使用xhr发起POST请求"><a href="#使用xhr发起POST请求" class="headerlink" title="使用xhr发起POST请求"></a>使用xhr发起POST请求</h3><p>①创建 xhr 对象</p><p>②调用 xhr.open() 函数</p><p>③设置 Content-Type 属性（固定写法）</p><p>④调用 xhr.send() 函数，同时指定要发送的数据</p><p>⑤监听 xhr.onreadystatechange 事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 创建 xhr 对象</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. 调用 open 函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. 设置 Content-Type 属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 4. 调用 send 函数  也是查询字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=上海图书出版社&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 5. 监听事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h2><h3 id="1-XML"><a href="#1-XML" class="headerlink" title="1.XML"></a>1.XML</h3><ul><li>可扩展标记语言，与HTML类似</li><li>被设计用来传输和储存数据，数据载体</li><li>缺点<ul><li>格式臃肿，体积大，效率低</li><li>在JS中解析较麻烦</li></ul></li></ul><h3 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2.JSON"></a>2.JSON</h3><p>JSON的英文全称是JavaScriptObjectNotation，即“JavaScript对象表示法”。简单来讲，JSON 就是 Javascript对数组组的字符串表示法，它使用文本表示一个JS对象或数组的信息，因此，&#x3D;&#x3D;JSON 的本质是字符串&#x3D;&#x3D;。</p><ul><li>所有的字符串用双引号包裹</li><li>属性名必须用双引号包裹</li><li>不能写注释</li><li>最外层必须是对象或数组格式</li><li>不能使用undefined或函数作为JSON值</li></ul><h4 id="两种结构"><a href="#两种结构" class="headerlink" title="两种结构"></a>两种结构</h4><p>对象：</p><p>对象结构在 JSON中表示为{} 括起来的内容。数据结构为{key: value, key: value, … } 的键值对结构。其中，key<br>必须是使用英文的双引号包裹的字符串，value的数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型。</p><p>数组：</p><p>数组结构在 JSON中表示为[] 括起来的内容。数据结构为[“java”,”javascript”,30, true … ]。数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。</p><h4 id="与js对象"><a href="#与js对象" class="headerlink" title="与js对象"></a>与js对象</h4><p>从JSON字符串到js对象  反序列化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;</span><br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonStr)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br></code></pre></td></tr></table></figure><p>从js对象到JSON字符串   序列化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-literal">false</span> &#125;<br><span class="hljs-keyword">var</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str)<br></code></pre></td></tr></table></figure><h2 id="封装自己的ajax函数"><a href="#封装自己的ajax函数" class="headerlink" title="封装自己的ajax函数"></a>封装自己的ajax函数</h2><p>1.定义options参数选项</p><p>2.处理data参数</p><p>3.定义itheima函数</p><p>4.判断请求的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveData</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">var</span> arr = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-keyword">var</span> str = k + <span class="hljs-string">&#x27;=&#x27;</span> + data[k]<br>    arr.<span class="hljs-title function_">push</span>(str)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// var res = resolveData(&#123; name: &#x27;zs&#x27;, age: 20 &#125;)</span><br><span class="hljs-comment">// console.log(res)</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">itheima</span>(<span class="hljs-params">options</span>) &#123;<span class="hljs-comment">//options是定义的参数选项，接收一个配置对象作为参数</span><br>  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><br>  <span class="hljs-comment">// 把外界传递过来的参数对象，转换为 查询字符串</span><br>  <span class="hljs-keyword">var</span> qs = <span class="hljs-title function_">resolveData</span>(options.<span class="hljs-property">data</span>)<br><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">method</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 发起GET请求</span><br>    xhr.<span class="hljs-title function_">open</span>(options.<span class="hljs-property">method</span>, options.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;?&#x27;</span> + qs)<br>    xhr.<span class="hljs-title function_">send</span>()<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.<span class="hljs-property">method</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 发起POST请求</span><br>    xhr.<span class="hljs-title function_">open</span>(options.<span class="hljs-property">method</span>, options.<span class="hljs-property">url</span>)<br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)<br>    xhr.<span class="hljs-title function_">send</span>(qs)<br>  &#125;<br><br>  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-keyword">var</span> result = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)<br>      options.<span class="hljs-title function_">success</span>(result)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xhr-level2新特性"><a href="#xhr-level2新特性" class="headerlink" title="xhr level2新特性"></a>xhr level2新特性</h2><p>①可以设置 HTTP 请求的时限</p><p>②可以使用 FormData对象管理表单数据</p><p>③可以上传文件</p><p>④可以获得数据传输的进度信息</p><h3 id="设置HTTP请求时限"><a href="#设置HTTP请求时限" class="headerlink" title="设置HTTP请求时限"></a>设置HTTP请求时限</h3><p>新版本的 XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">3000</span><br><span class="hljs-comment">//上面的语句，将最长等待时间设为 3000 毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个 timeout 事件，用来指定回调函数：</span><br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请求超时！&#x27;</span>)<br> &#125;<br><br></code></pre></td></tr></table></figure><h3 id="FormData对象管理表单数据"><a href="#FormData对象管理表单数据" class="headerlink" title="FormData对象管理表单数据"></a>FormData对象管理表单数据</h3><p>提交表单数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1. 创建 FormData 实例</span><br>    <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>    <span class="hljs-comment">// 2. 调用 append 函数，向 fd 中追加数据</span><br>    fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-string">&#x27;zs&#x27;</span>)<br>    fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;upwd&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br><br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)<br>   <span class="hljs-comment">//直接提交fd</span><br>    xhr.<span class="hljs-title function_">send</span>(fd)<br><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>))<br>      &#125;<br>    &#125;<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>获取网页表单的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1. 通过 DOM 操作，获取到 form 表单元素</span><br>    <span class="hljs-keyword">var</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#form1&#x27;</span>)<br><br>    form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-comment">// 阻止表单的默认提交行为</span><br>      e.<span class="hljs-title function_">preventDefault</span>()<br><br>      <span class="hljs-comment">// 2.创建 FormData，快速获取到 form 表单中的数据</span><br>      <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form)<br><br>      <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)<br>      <span class="hljs-comment">//3.将fd传入服务器</span><br>      xhr.<span class="hljs-title function_">send</span>(fd)<br><br>      xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>))<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>新版 XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。</p><p>实现步骤：</p><p>①定义 UI结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-number">1.</span> 文件选择框 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file1&quot;</span> /&gt;</span></span><br>  &lt;!-- <span class="hljs-number">2.</span> 上传文件的按钮 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnUpload&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><br>  &lt;!-- <span class="hljs-number">3.</span> img 标签，来显示上传成功以后的图片 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p>②验证是否选择了文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">var</span> btnUpload = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btnUpload&#x27;</span>)<br>    <span class="hljs-comment">// 2. 为按钮绑定单击事件处理函数</span><br>    btnUpload.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 3. 获取到用户选择的文件列表</span><br>      <span class="hljs-keyword">var</span> files = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#file1&#x27;</span>).<span class="hljs-property">files</span> <span class="hljs-comment">// 对象，length和0都是属性名</span><br>      <span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择要上传的文件！&#x27;</span>)<br>      &#125;<br>   ......<br></code></pre></td></tr></table></figure><p>③向 FormData中追加文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>      <span class="hljs-comment">// 将用户选择的文件，添加到 FormData 中</span><br> fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])     <span class="hljs-comment">//avatar是自定义的值</span><br></code></pre></td></tr></table></figure><p>④使用 xhr发起上传文件的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br> xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>)<br> xhr.<span class="hljs-title function_">send</span>(fd)<br></code></pre></td></tr></table></figure><p>⑤监听 onreadystatechange事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>          <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)<br>          <span class="hljs-keyword">if</span> (data.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-comment">// 上传成功</span><br>            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#img&#x27;</span>).<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006&#x27;</span> + data.<span class="hljs-property">url</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;                                                    <span class="hljs-comment">//根目录+返回的url</span><br>            <span class="hljs-comment">// 上传失败</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;图片上传失败！&#x27;</span> + data.<span class="hljs-property">message</span>)<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;)<br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="显示文件上传进度"><a href="#显示文件上传进度" class="headerlink" title="显示文件上传进度"></a>显示文件上传进度</h3><p>新版本的 XMLHttpRequest对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建 XHR 对象</span><br> <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br> <span class="hljs-comment">// 监听 xhr.upload 的 onprogress 事件</span><br> xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度</span><br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;<br>        <span class="hljs-comment">// e.loaded 已传输的字节</span><br>        <span class="hljs-comment">// e.total  需传输的总字节</span><br>        <span class="hljs-keyword">var</span> percentComplete = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="jQuery实现文件上传"><a href="#jQuery实现文件上传" class="headerlink" title="jQuery实现文件上传"></a>jQuery实现文件上传</h3><p>步骤与xhr上传相同，值得注意的是用$.ajax()上传时有两个新的参数且不可缺少</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 监听到Ajax请求被发起了</span><br>      $(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ajaxStart</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $(<span class="hljs-string">&#x27;#loading&#x27;</span>).<span class="hljs-title function_">show</span>()<br>      &#125;)<br><br>      <span class="hljs-comment">// 监听到 Ajax 完成的事件</span><br>      $(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ajaxStop</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $(<span class="hljs-string">&#x27;#loading&#x27;</span>).<span class="hljs-title function_">hide</span>()<br>      &#125;)<br>      <span class="hljs-comment">//loading效果</span><br>   <br>      $(<span class="hljs-string">&#x27;#btnUpload&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> files = $(<span class="hljs-string">&#x27;#file1&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">files</span><br>        <span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择文件后再上传！&#x27;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>        fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-comment">// 发起 jQuery 的 Ajax 请求，上传文件        </span><br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>          <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>,<br>          <span class="hljs-attr">data</span>: fd,<br>          <span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">//不可省略</span><br>          <span class="hljs-attr">contentType</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">//不可省略</span><br>          <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>          &#125;<br>        &#125;)<br>      &#125;)<br>    &#125;)<br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>注：上传文件只能用$.ajax(),POST方式</li><li>$(document).ajaxStart()函数会监听当前文档内所有的Ajax请求。</li></ul><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>专注于网络数据请求的库</p><p>axios.js</p><h3 id="发起GET请求"><a href="#发起GET请求" class="headerlink" title="发起GET请求"></a>发起GET请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-comment">/*参数*/</span> &#125; &#125;).<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btn1&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span><br>      <span class="hljs-keyword">var</span> paramsObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<br>      axios.<span class="hljs-title function_">get</span>(url, &#123; <span class="hljs-attr">params</span>: paramsObj &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)  <span class="hljs-comment">//res.data才是服务器返回的数据，res是axios封装的对象</span><br>      &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="发起POST请求"><a href="#发起POST请求" class="headerlink" title="发起POST请求"></a>发起POST请求</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">axios.post(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-comment">/*参数*/</span> &#125;).then(callback)  参数直接放一个对象<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btn2&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span><br>      <span class="hljs-keyword">var</span> dataObj = &#123; <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-attr">location</span>: <span class="hljs-string">&#x27;顺义区&#x27;</span> &#125;<br>      axios.<span class="hljs-title function_">post</span>(url, dataObj).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>      &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="直接用axios"><a href="#直接用axios" class="headerlink" title="直接用axios"></a>直接用axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;<br>     <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;请求类型&#x27;</span>,<br>     <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;请求的URL地址&#x27;</span>,<br>     <span class="hljs-attr">data</span>: &#123; <span class="hljs-comment">/* POST数据 */</span> &#125;,<br>     <span class="hljs-attr">params</span>: &#123; <span class="hljs-comment">/* GET参数 */</span> &#125;<br> &#125;) .<span class="hljs-title function_">then</span>(callback)<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btn3&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span><br>      <span class="hljs-keyword">var</span> paramsData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;钢铁侠&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">35</span> &#125;<br>      <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">params</span>: paramsData<br>      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>      &#125;)<br>    &#125;)<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btn4&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>,<br>        <span class="hljs-attr">data</span>: &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;娃哈哈&#x27;</span>,<br>          <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>          <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;女&#x27;</span><br>        &#125;<br>      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>      &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax-2-from-模板引擎</title>
    <link href="/2023/05/04/Ajax-2/"/>
    <url>/2023/05/04/Ajax-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax-2"><a href="#Ajax-2" class="headerlink" title="Ajax-2"></a>Ajax-2</h1><h2 id="from表单的基本使用"><a href="#from表单的基本使用" class="headerlink" title="from表单的基本使用"></a>from表单的基本使用</h2><p>表单在网页中主要负责数据采集功能</p><h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><ul><li>表单标签</li><li>表单域</li><li>表单按钮</li></ul><h3 id="lt-form-gt-标签的属性"><a href="#lt-form-gt-标签的属性" class="headerlink" title="&lt;form&gt;标签的属性"></a><code>&lt;form&gt;</code>标签的属性</h3><p><img src="/image/ajax-3.PNG"></p><p>_blank 在新窗口打开URL</p><p>_self 默认，在相同框架中打开</p><ul><li>get以URL的方式提交数据  ,默认情况下，method的值为get（适合提交少量，简单的数据）</li><li>post以Form Data的方式提交数据，URL地址栏看不到数据（适合于大量复杂的包含文件上传的数据）</li><li>在实际开发中，<code>&lt;form&gt;</code>表单的post提交方式用的最多，很少用get。例如登录、注册、添加数据等表单操作，都需要使用post方式来提交表单。</li></ul><p><img src="/image/ajax-4.PNG"></p><h3 id="表单的同步提交"><a href="#表单的同步提交" class="headerlink" title="表单的同步提交"></a>表单的同步提交</h3><p>通过点击submit按钮，触发表单提交的操作，从而使页面跳转到action URL 的行为，叫做表单的同步提交。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>①<code>&lt;form&gt;</code>表单同步提交后，整个页面会发生跳转，跳转到 action URL 所指向的地址，用户体验很差。</li><li>②<code>&lt;form&gt;</code>表单同步提交后，页面之前的状态和数据会丢失。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>表单只负责采集数据，Ajax负责将数据提交到服务器</p><h2 id="通过ajax提交表单数据"><a href="#通过ajax提交表单数据" class="headerlink" title="通过ajax提交表单数据"></a>通过ajax提交表单数据</h2><h3 id="1-监听表单提交事件"><a href="#1-监听表单提交事件" class="headerlink" title="1.监听表单提交事件"></a>1.监听表单提交事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;f1&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 第一种方式</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// $(&#x27;#f1&#x27;).submit(function () &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//   alert(&#x27;监听到了表单的提交事件&#x27;)</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// &#125;)</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 第二种方式</span></span></span><br><span class="language-javascript"><span class="language-xml">      $(<span class="hljs-string">&#x27;#f1&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  </span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;监听到了表单的提交事件2&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="2-阻止表单默认提交行为"><a href="#2-阻止表单默认提交行为" class="headerlink" title="2.阻止表单默认提交行为"></a>2.阻止表单默认提交行为</h3><p>e.preventDefault()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 第一种方式</span><br>    <span class="hljs-comment">// $(&#x27;#f1&#x27;).submit(function (e) &#123;</span><br>    <span class="hljs-comment">//   alert(&#x27;监听到了表单的提交事件&#x27;)</span><br>    <span class="hljs-comment">//   e.preventDefault()</span><br>    <span class="hljs-comment">// &#125;)</span><br><br>    <span class="hljs-comment">// 第二种方式</span><br>    $(<span class="hljs-string">&#x27;#f1&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;  <br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;监听到了表单的提交事件2&#x27;</span>)<br>      e.<span class="hljs-title function_">preventDefault</span>()<br>    &#125;)<br>  &#125;)<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="3-快速获取表单数据"><a href="#3-快速获取表单数据" class="headerlink" title="3.快速获取表单数据"></a>3.快速获取表单数据</h3><p>1.serialize()函数   jQuery提供</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#form&#x27;</span>).<span class="hljs-title function_">serialize</span>()<br><span class="hljs-comment">// 调用的结果：</span><br><span class="hljs-comment">// username=用户名的值&amp;password=密码的值</span><br><br></code></pre></td></tr></table></figure><p>注意：在使用 serialize() 函数快速获取表单数据时，必须为每个表单元素添加name属性！</p><p>返回值是字符串类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  $(<span class="hljs-string">&#x27;#formAddCmt&#x27;</span>).<span class="hljs-title function_">submit</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>()<br>    <span class="hljs-keyword">var</span> data = $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">serialize</span>()<br>    $.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addcmt&#x27;</span>, data, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> !== <span class="hljs-number">201</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;发表评论失败！&#x27;</span>)<br>      &#125;<br>      <span class="hljs-title function_">getCommentList</span>()<br>      $(<span class="hljs-string">&#x27;#formAddCmt&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">reset</span>()<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>用字符串拼接的形式来渲染UI结构时，如果UI结构比较复杂，则拼接字符串的时候需要格外注意引号之前的嵌套。且一旦需求发生变化，修改起来也非常麻烦。</p><ul><li>模板引擎可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML页面</li></ul><h3 id="art-template"><a href="#art-template" class="headerlink" title="art-template"></a>art-template</h3><p>使用步骤</p><p>①导入 art-template</p><p>②定义数据</p><p>③定义模板</p><p>④调用 template函数</p><p>⑤渲染HTML结构</p><h4 id="标准语法"><a href="#标准语法" class="headerlink" title="标准语法"></a>标准语法</h4><ul><li><code>&#123;&#123;&#125;&#125;,在&#123;&#123;&#125;&#125;内可以进行变量输出，循环数组等操作</code></li><li>原文输出(如果要输出的value值中，包含了HTML标签结构，则需要使用原文输出语法，才能保证HTML标签被正常渲染)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;@ value&#125;&#125;<br></code></pre></td></tr></table></figure><ul><li>条件输出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;<span class="hljs-keyword">if</span> flag === <span class="hljs-number">0</span>&#125;&#125;<br>      flag的值是<span class="hljs-number">0</span><br>      &#123;&#123;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> flag === <span class="hljs-number">1</span>&#125;&#125;<br>      flag的值是<span class="hljs-number">1</span><br> &#123;&#123;/<span class="hljs-keyword">if</span>&#125;&#125;<br></code></pre></td></tr></table></figure><ul><li>循环输出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;each hobby&#125;&#125;  <span class="hljs-comment">//遍历hobby</span><br>      &lt;li&gt;索引是:&#123;&#123;$index&#125;&#125;，循环项是:&#123;&#123;$value&#125;&#125;&lt;/li&gt;<br>  &#123;&#123;/each&#125;&#125; <br></code></pre></td></tr></table></figure><ul><li>过滤器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;value | filterName&#125;&#125;<br></code></pre></td></tr></table></figure><p>定义过滤器的基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">template.<span class="hljs-property">defaults</span>.<span class="hljs-property">imports</span>.<span class="hljs-property">filterName</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/*return 处理结果*/</span>&#125; 过滤器函数一定要返回处理结果<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;news-list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  &lt;!-- 定义模板 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/html&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tpl-news&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name"><span class="hljs-built_in">each</span></span> data&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;news-item&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumb&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;http://www.liulongbin.top:3006&#x27;</span> + $value.img&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-box&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$value.title</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tags&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name"><span class="hljs-built_in">each</span></span> $value.tags&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$value</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            </span><span class="hljs-template-tag">&#123;&#123;/<span class="hljs-name"><span class="hljs-built_in">each</span></span>&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$value.source</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$value.time</span> | dateFormat&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>评论数：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$value.cmtcount</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      </span><span class="hljs-template-tag">&#123;&#123;/<span class="hljs-name"><span class="hljs-built_in">each</span></span>&#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;/body&gt;<br>        <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNewsList</span>(<span class="hljs-params"></span>) &#123;<br>    $.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/news&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> !== <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;获取新闻列表数据失败！&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-comment">// 把每一项的 tags 属性，从字符串改造成字符串的数组</span><br>        res.<span class="hljs-property">data</span>[i].<span class="hljs-property">tags</span> = res.<span class="hljs-property">data</span>[i].<span class="hljs-property">tags</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>)<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>      <span class="hljs-keyword">var</span> htmlStr = <span class="hljs-title function_">template</span>(<span class="hljs-string">&#x27;tpl-news&#x27;</span>, res)<br>      $(<span class="hljs-string">&#x27;#news-list&#x27;</span>).<span class="hljs-title function_">html</span>(htmlStr)<br>    &#125;)<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>1.exec()函数用于检索字符串中的正则匹配，如果字符串中有匹配的值，则返回该匹配值，否则返回 null。</p><p>2.分组：正则表达式中 ( ) 包起来的内容表示一个分组，可以通过分组来提取自己想要的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&#x27;</span><br> <span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;([a-zA-Z]+)&#125;&#125;/</span><br><br> <span class="hljs-keyword">var</span> patternResult = pattern.<span class="hljs-title function_">exec</span>(str)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(patternResult)<br> <span class="hljs-comment">// 得到 name 相关的分组信息</span><br> <span class="hljs-comment">// [&quot;&#123;&#123;name&#125;&#125;&quot;, &quot;name&quot;, index: 7, input: &quot;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&quot;, groups: undefined]</span><br><br></code></pre></td></tr></table></figure><p>3.replace()操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&#x27;</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;([a-zA-Z]+)&#125;&#125;/</span><br><br><span class="hljs-keyword">var</span> patternResult = pattern.<span class="hljs-title function_">exec</span>(str)<br>str = str.<span class="hljs-title function_">replace</span>(patternResult[<span class="hljs-number">0</span>], patternResult[<span class="hljs-number">1</span>]) <span class="hljs-comment">// replace 函数返回值为替换后的新字符串</span><br><span class="hljs-comment">// 输出的内容是：&lt;div&gt;我是name&lt;/div&gt;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br><br></code></pre></td></tr></table></figure><p>4.多次replace()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;\s*([a-zA-Z]+)\s*&#125;&#125;/</span><br><br><span class="hljs-keyword">var</span> patternResult = pattern.<span class="hljs-title function_">exec</span>(str)<br>str = str.<span class="hljs-title function_">replace</span>(patternResult[<span class="hljs-number">0</span>], patternResult[<span class="hljs-number">1</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 输出 &lt;div&gt;name今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;</span><br><br>patternResult = pattern.<span class="hljs-title function_">exec</span>(str)<br>str = str.<span class="hljs-title function_">replace</span>(patternResult[<span class="hljs-number">0</span>], patternResult[<span class="hljs-number">1</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 输出 &lt;div&gt;name今年age岁了&lt;/div&gt;</span><br><br>patternResult = pattern.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(patternResult) <span class="hljs-comment">// 输出 null</span><br><br>改进成<span class="hljs-keyword">while</span>循环<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;\s*([a-zA-Z]+)\s*&#125;&#125;/</span><br><br><span class="hljs-keyword">var</span> patternResult = <span class="hljs-literal">null</span><br><span class="hljs-keyword">while</span>(patternResult = pattern.<span class="hljs-title function_">exec</span>(str)) &#123;<br>   str = str.<span class="hljs-title function_">replace</span>(patternResult[<span class="hljs-number">0</span>], patternResult[<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 输出 &lt;div&gt;name今年age岁了&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>5.replace替换为真值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    var data = &#123; name: &#x27;张三&#x27;, age: 20 &#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    var str = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="language-xml">今年</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><span class="language-xml">岁了<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    var pattern = /</span><span class="hljs-template-variable">&#123;&#123;\<span class="hljs-name">s</span>*(<span class="hljs-name">[a-zA-Z]</span>+)\s*&#125;&#125;</span><span class="language-xml">/</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    var patternResult = null</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    while (patternResult = pattern.exec(str)) &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      str = str.replace(patternResult[0], data[patternResult[1]])</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    &#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    console.log(str)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br><br><br></code></pre></td></tr></table></figure><h3 id="实现简单的模板引擎"><a href="#实现简单的模板引擎" class="headerlink" title="实现简单的模板引擎"></a>实现简单的模板引擎</h3><p>①定义模板结构</p><p>②预调用模板引擎</p><p>③封装 template函数</p><p>④导入并使用自定义的模板引擎</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax-4-同源策略和跨域</title>
    <link href="/2023/05/04/Ajax-4/"/>
    <url>/2023/05/04/Ajax-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax-4"><a href="#Ajax-4" class="headerlink" title="Ajax-4"></a>Ajax-4</h1><h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源。</p><p>下表给出了相对于<code>http://www.test.com/index.html</code>页面的同源检测：</p><p><img src="/image/ajax-6.PNG"></p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略（英文全称Same origin policy）是浏览器提供的一个安全功能。</p><p>通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如：</p><p>①无法读取非同源网页的Cookie、LocalStorage 和 IndexedDB</p><p>②无法接触非同源网页的DOM</p><p>③无法向非同源地址发送Ajax 请求</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>同源指的是两个URL的协议、域名、端口一致，反之，则是跨域。</p><p>出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL之间进行资源的交互。</p><h4 id="浏览器对跨域请求的拦截"><a href="#浏览器对跨域请求的拦截" class="headerlink" title="浏览器对跨域请求的拦截"></a>浏览器对跨域请求的拦截</h4><p><img src="/image/ajax-7.PNG"></p><p>被浏览器的同源策略所拦截</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>是JSON的一种使用模式。可用于解决主流浏览器的跨域数据访问的问题。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote><p>由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是<code>&lt;script&gt;</code>标签不受浏览器同源策略的影响，可以通过src属性，请求非同源的js脚本。</p><p>因此，JSONP的实现原理，就是通过<code>&lt;script&gt;</code>标签的src属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。</p></blockquote><h3 id="实现简单JSONP"><a href="#实现简单JSONP" class="headerlink" title="实现简单JSONP"></a>实现简单JSONP</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params">data</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JSONP响应回来的数据是：&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.liulongbin.top:3006/api/jsonp?callback=abc&amp;name=ls&amp;age=30&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br><br></code></pre></td></tr></table></figure><p>由于JSONP是通过<code>&lt;script&gt;</code>标签的src属性，来实现跨域数据获取的，所以，JSONP只支持GET数据请求，不支持POST请求。</p><p>注意：JSONP 和 Ajax 之间没有任何关系，不能把JSONP请求数据的方式叫做Ajax，因为JSONP没有用到XMLHttpRequest这个对象。</p><h3 id="jQuery中的JSONP"><a href="#jQuery中的JSONP" class="headerlink" title="jQuery中的JSONP"></a>jQuery中的JSONP</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnJSONP&quot;</span>&gt;</span>发起JSONP数据请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      $(<span class="hljs-string">&#x27;#btnJSONP&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        $.<span class="hljs-title function_">ajax</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/jsonp?address=北京&amp;location=顺义&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback&#x3D;jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。</p><p><img src="/image/ajax-8.PNG"></p><ul><li>在发起 JSONP 请求的时候，动态向<code>&lt;header&gt;</code>中append一个<code>&lt;script&gt;</code>标签；</li><li>在 JSONP 请求成功以后，动态从<code>&lt;header&gt;</code>中移除刚才append进去的<code>&lt;script&gt;</code>标签；</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记8（之前忘上传那篇）</title>
    <link href="/2023/05/02/html5%E5%92%8Ccss3%E6%8F%90%E9%AB%98/"/>
    <url>/2023/05/02/html5%E5%92%8Ccss3%E6%8F%90%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<h1 id="html5和css3提高"><a href="#html5和css3提高" class="headerlink" title="html5和css3提高"></a>html5和css3提高</h1><p>html5新增了一些标签，表单，表单属性</p><h2 id="html5新增的语义化标签"><a href="#html5新增的语义化标签" class="headerlink" title="html5新增的语义化标签"></a>html5新增的语义化标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>某个区域<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>侧边栏<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>尾部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>主要针对搜索引擎<br>IE9中要把他们转换为块级元素<br></code></pre></td></tr></table></figure><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">autoplay</span>=<span class="hljs-string">&quot;autoplay&quot;</span> <span class="hljs-attr">muted</span>=<span class="hljs-string">&quot;muted&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&quot;loop&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">audio</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h2><p>新增的input类型</p><p><img src="/image/10.1.jpg"></p><p><img src="/image/10.2.jpg"></p><hr><h2 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h2><h3 id="新增属性选择器"><a href="#新增属性选择器" class="headerlink" title="新增属性选择器"></a>新增属性选择器</h3><p>属性选择器，按照字面意思，都是根据标签中的属性来选择元素</p><p><img src="/image/10.3.jpg"></p><ul><li>属性选择器，按照字面意思，都是根据标签中的属性来选择元素</li><li>属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器</li><li>属性选择器也可以选择出来自定义的属性</li><li><strong>注意：</strong>类选择器、属性选择器、伪类选择器，权重为 10。</li><li>input[type&#x3D;text] 权重为11</li></ul><h3 id="新增结构伪类选择器"><a href="#新增结构伪类选择器" class="headerlink" title="新增结构伪类选择器"></a>新增结构伪类选择器</h3><p><img src="/image/10.4.jpg"></p><p>n可以是数字，关键字和公式</p><ul><li><code>E:nth-child(n)</code>     匹配父元素的第n个子元素E，也就是说，nth-child 对父元素里面所有孩子排序选择（序号是固定的）  先找到第n个孩子，然后看看是否和E匹配</li><li><code>E:nth-of-type(n)</code> 匹配同类型中的第n个同级兄弟元素E，也就是说，对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子</li></ul><h3 id="新增伪元素选择器"><a href="#新增伪元素选择器" class="headerlink" title="新增伪元素选择器"></a>新增伪元素选择器</h3><p>伪元素选择器可以帮助我们使用css创建新标签元素，不需要HTML标签</p><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td>::before</td><td>在元素的前面插入内容</td></tr><tr><td>::after</td><td>在元素的后面插入内容</td></tr></tbody></table><p>注意：</p><ul><li>before 和 after 创建一个元素，但是属于行内元素</li><li>新创建的这个元素在文档树中是找不到的，所以我们称为伪元素</li><li>语法：  element::before {}   </li><li>before 和 after 必须有 content 属性 </li><li>before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素<br>伪元素选择器和标签选择器一样，权重为 1</li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>CSS3 中可以通过 box-sizing 来指定盒模型，有2个值：即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p><p>可以分成两种情况：</p><ul><li>box-sizing: content-box  盒子大小为 width + padding + border  （以前默认的）</li><li>box-sizing: border-box  盒子大小为 width</li></ul><p>如果盒子模型我们改为了box-sizing: border-box  ， 那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）</p><h3 id="图片模糊处理"><a href="#图片模糊处理" class="headerlink" title="图片模糊处理"></a>图片模糊处理</h3><p>css3滤镜filter:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">filter</span>: 函数(); 例 <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>);数值越大越模糊<br></code></pre></td></tr></table></figure><h3 id="calc函数"><a href="#calc函数" class="headerlink" title="calc函数"></a>calc函数</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>:<span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span>-<span class="hljs-number">80px</span>)<br></code></pre></td></tr></table></figure><p>calc() 此CSS函数让你在声明CSS属性值时执行一些计算</p><h3 id="css3过渡"><a href="#css3过渡" class="headerlink" title="css3过渡"></a>css3过渡</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: 要过渡的属性  花费时间  运动曲线  何时开始;<br></code></pre></td></tr></table></figure><ul><li>属性 ： 想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以</li><li>花费时间： 单位是 秒（必须写单位） 比如 0.5s </li><li>运动曲线： 默认是 ease （可以省略）</li><li>何时开始：单位是 秒（必须写单位）可以设置延迟触发时间  默认是 0s  （可以省略）</li><li><strong>后面两个属性可以省略</strong></li><li><strong>记住过渡的使用口诀： 谁做过渡给谁加</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery-2</title>
    <link href="/2023/05/02/jQuery-2/"/>
    <url>/2023/05/02/jQuery-2/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery-2"><a href="#jQuery-2" class="headerlink" title="jQuery-2"></a>jQuery-2</h1><h2 id="jQuery属性操作"><a href="#jQuery属性操作" class="headerlink" title="jQuery属性操作"></a>jQuery属性操作</h2><p>获取元素固有属性</p><ul><li>prop(“属性”)  （获取） </li><li>prop(‘’属性’’, ‘’属性值’’)  （设置）</li></ul><p>获取元素自定义属性</p><ul><li>attr(‘’属性’’)      &#x2F;&#x2F; 类似原生 getAttribute()</li><li>attr(‘’属性’’, ‘’属性值’’)   &#x2F;&#x2F;<br>类似原生 setAttribute()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">//1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&quot;href&quot;</span>));<br>            $(<span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;我们都挺好&quot;</span>);<br>            $(<span class="hljs-string">&quot;input&quot;</span>).<span class="hljs-title function_">change</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&quot;checked&quot;</span>));<br><br>            &#125;);<br>            <span class="hljs-comment">// console.log($(&quot;div&quot;).prop(&quot;index&quot;));</span><br>            <span class="hljs-comment">// 2. 元素的自定义属性 我们通过 attr()</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;index&quot;</span>));<br>            $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;index&quot;</span>, <span class="hljs-number">4</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;data-index&quot;</span>));<br>            <span class="hljs-comment">// 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面</span><br>            $(<span class="hljs-string">&quot;span&quot;</span>).<span class="hljs-title function_">data</span>(<span class="hljs-string">&quot;uname&quot;</span>, <span class="hljs-string">&quot;andy&quot;</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&quot;span&quot;</span>).<span class="hljs-title function_">data</span>(<span class="hljs-string">&quot;uname&quot;</span>));<br>            <span class="hljs-comment">// 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">data</span>(<span class="hljs-string">&quot;index&quot;</span>));<br><br>        &#125;)<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="内容文本值"><a href="#内容文本值" class="headerlink" title="内容文本值"></a>内容文本值</h2><p>1.html()   普通元素内容</p><p>2.text()    普通元素文本内容</p><p>3.val()      表单的值</p><h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>如果想要给同一类元素做不同操作，就要用到遍历</p><p>each()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$&#123;<span class="hljs-string">&quot;div&quot;</span>&#125;.<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">index,domEle</span>)&#123;xxx;&#125;)<br><span class="hljs-comment">//回调函数第一个参数一定是索引号，可以自己指定索引号名称</span><br><span class="hljs-comment">//第二个参数一定是DOM对象</span><br><br></code></pre></td></tr></table></figure><p>$.each()  主要做数据处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">each</span>(object，<span class="hljs-keyword">function</span> (<span class="hljs-params">index, element</span>) &#123; xxx; &#125;）       <br><span class="hljs-number">1.</span> $.<span class="hljs-title function_">each</span>()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象<br><span class="hljs-number">2.</span> 里面的函数有<span class="hljs-number">2</span>个参数：  index 是每个元素的索引号;  element  遍历内容<br><br></code></pre></td></tr></table></figure><h3 id="创建，添加，删除元素"><a href="#创建，添加，删除元素" class="headerlink" title="创建，添加，删除元素"></a>创建，添加，删除元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// 1. 创建元素</span><br>            <span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;</span>);   <span class="hljs-comment">//动态的创建了一个li</span><br>            <span class="hljs-comment">// 2. 添加元素</span><br><br>            <span class="hljs-comment">// (1) 内部添加</span><br>            <span class="hljs-comment">// $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面 </span><br>            $(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-title function_">prepend</span>(li); <span class="hljs-comment">// 内部添加并且放到内容的最前面</span><br><br>            <span class="hljs-comment">// (2) 外部添加</span><br>            <span class="hljs-keyword">var</span> div = $(<span class="hljs-string">&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;</span>);<br>            <span class="hljs-comment">// $(&quot;.test&quot;).after(div);</span><br>            $(<span class="hljs-string">&quot;.test&quot;</span>).<span class="hljs-title function_">before</span>(div);<br>            <span class="hljs-comment">// 3. 删除元素</span><br>            <span class="hljs-comment">// $(&quot;ul&quot;).remove(); 可以删除匹配的元素 本身</span><br>            <span class="hljs-comment">// $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子</span><br>            $(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 可以删除匹配的元素里面的子节点 孩子</span><br><br>        &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="尺寸位置操作"><a href="#尺寸位置操作" class="headerlink" title="尺寸位置操作"></a>尺寸位置操作</h2><p>尺寸</p><p><img src="/image/jquery-8.PNG"></p><p>位置</p><p> 位置主要有三个： offset()、position()、scrollTop()&#x2F;scrollLeft()</p><p>1.①offset() 方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系。</p><p>②该方法有2个属性 left、top 。offset().top  用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。</p><p>③可以设置元素的偏移：offset({top: 10, left: 30 });</p><ol start="2"><li></li></ol><p>①position() 方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。</p><p>②该方法有2个属性 left、top。position().top用于获取距离定位父级顶部的距离，position().left 用于获取距离定位父级左侧的距离。</p><p>③该方法只能获取。</p><ol start="3"><li></li></ol><p>scrollTop()&#x2F;scrollLeft()设置或获取元素被卷去的头部和左侧</p><p>①scrollTop() 方法设置或返回被选元素被卷去的头部。</p><p>②不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部。</p><h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><h3 id="单个事件注册"><a href="#单个事件注册" class="headerlink" title="单个事件注册"></a>单个事件注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.事件(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)       <br>$(“div”).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  事件处理程序 &#125;)       <br><br></code></pre></td></tr></table></figure><p>其他事件和原生基本一致。</p><p>比如mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll 等</p><h3 id="事件处理on-绑定事件"><a href="#事件处理on-绑定事件" class="headerlink" title="事件处理on()绑定事件"></a>事件处理on()绑定事件</h3><p>$(“div”).on()</p><p>on() 方法在匹配元素上绑定一个或多个事件的事件处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$(“div”).<span class="hljs-title function_">on</span>(&#123;<br>  <span class="hljs-attr">mouseover</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;, <br>  <span class="hljs-attr">mouseout</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  <span class="hljs-attr">click</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;);       <br><span class="hljs-comment">//如果事件相同</span><br>$(“div”).<span class="hljs-title function_">on</span>(“mouseover mouseout”, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">toggleClass</span>(“current”);<br>  &#125;);       <br><br><br></code></pre></td></tr></table></figure><p>可以事件委派操作（事件委托）<br>事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"> $(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-number">11</span>);<br>            &#125;);<br>绑定在ul身上，但是触发由li触发<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;可以给动态创建的元素绑定事件&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;ol&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-number">11</span>);<br>            &#125;)<br><span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;</span>);<br>$(<span class="hljs-string">&quot;ol&quot;</span>).<span class="hljs-title function_">append</span>(li);<br></code></pre></td></tr></table></figure><p>可以理解成给ol绑了click，li是e.target</p><h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><p>${“div”}.off()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">off</span>() <span class="hljs-comment">// 解绑p元素所有事件处理程序</span><br><br>$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">off</span>( <span class="hljs-string">&quot;click&quot;</span>)  <span class="hljs-comment">// 解绑p元素上面的点击事件 后面的 foo 是侦听函数名</span><br><br>$(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>);   <span class="hljs-comment">// 解绑事件委托</span><br><br></code></pre></td></tr></table></figure><p>如果有的事件只想触发一次， 可以使用 one()来绑定事件。</p><p>${“p”}.one()</p><h3 id="自动触发事件"><a href="#自动触发事件" class="headerlink" title="自动触发事件"></a>自动触发事件</h3><p>（前提是事件已经注册，有了事件处理程序）</p><ol><li>元素.事件</li></ol><p>${“div”}.click()</p><ol start="2"><li>元素.trigger(“事件”)</li></ol><p>${“div”}.trigger(“click”)</p><ol start="3"><li>元素.triggerHandler(“事件”)     不会触发元素的默认行为</li></ol><p>$(“div”).triggerHandler(“click”)</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">on</span>(events,[selector],<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;&#125;)       <br><br></code></pre></td></tr></table></figure><p>阻止默认行为：event.preventDefault()   或者 return false </p><p>阻止冒泡： event.stopPropagation()      </p><h3 id="jQuery拷贝对象"><a href="#jQuery拷贝对象" class="headerlink" title="jQuery拷贝对象"></a>jQuery拷贝对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">extend</span>([deep], target, object1, [objectN])    <br><br></code></pre></td></tr></table></figure><ol><li>deep: 如果设为true 为深拷贝， 默认为false 浅拷贝 </li><li>target: 要拷贝的目标对象</li><li>object1:待拷贝到第一个对象的对象。</li><li>objectN:待拷贝到第N个对象的对象。</li><li>浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。</li><li>深拷贝，前面加true， 完全克隆(拷贝的对象,而不是地址)，修改目标对象不会影响被拷贝对象。</li></ol><h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">function</span> <span class="hljs-title function_">$</span>(<span class="hljs-params">ele</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(ele);<br>            &#125;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&quot;div&quot;</span>));<br>            <span class="hljs-comment">// 1. 如果$ 符号冲突 我们就使用 jQuery</span><br>            jQuery.<span class="hljs-title function_">each</span>();<br>            <span class="hljs-comment">// 2. 让jquery 释放对$ 控制权 让用自己决定</span><br>            <span class="hljs-keyword">var</span> suibian = jQuery.<span class="hljs-title function_">noConflict</span>();<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suibian</span>(<span class="hljs-string">&quot;span&quot;</span>));<br>            suibian.<span class="hljs-title function_">each</span>();<br>        &#125;)<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery插件完成。</p><p>注意: 这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也称为jQuery插件。</p><p>jQuery 插件常用的网站：</p><ol><li>jQuery 插件库 <a href="http://www.jq22.com/">http://www.jq22.com/</a>     </li><li>jQuery 之家   <a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a></li></ol><p>jQuery 插件使用步骤：</p><ol><li><p>引入相关文件。（jQuery文件 和插件文件）    </p></li><li><p>复制相关html、css、js (调用插件)。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery-1</title>
    <link href="/2023/05/02/jQuery-1/"/>
    <url>/2023/05/02/jQuery-1/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery-1"><a href="#jQuery-1" class="headerlink" title="jQuery-1"></a>jQuery-1</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>js库（对原生js的封装）</p><ul><li>轻量级，大大简化DOM操作</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>入口函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// $(&#x27;div&#x27;).hide();</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 1. 等着页面DOM加载完毕再去执行js 代码</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// $(document).ready(function() &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//     $(&#x27;div&#x27;).hide();</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// &#125;)</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 2.  等着页面DOM加载完毕再去执行js 代码</span></span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">hide</span>();</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/jquery-1.PNG"></p><ul><li>$是jquery的顶级对象也是jquery的别称</li><li>把元素利用$包装成jQuery对象</li></ul><h2 id="jQuery对象和DOM对象"><a href="#jQuery对象和DOM对象" class="headerlink" title="jQuery对象和DOM对象"></a>jQuery对象和DOM对象</h2><ul><li>$(‘div’) 是一个jQuery对象</li><li>本质是利用$对DOM对象包装后产生的对象，本质是伪数组</li><li>jQuery对象只能使用jQuery方法</li></ul><p>两个对象是可以相互转换的</p><p>（想用原生的一些属性和方法需要把jQuery转换）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$&#123;<span class="hljs-variable constant_">DOM</span>对象&#125;  jquery-&gt;dom<br>dom-&gt;jquery<br>$&#123;<span class="hljs-string">&#x27;video&#x27;</span>&#125;[index] index：索引<br>$&#123;<span class="hljs-string">&#x27;video&#x27;</span>&#125;.<span class="hljs-title function_">get</span>(index)<br></code></pre></td></tr></table></figure><h2 id="jQuery-API"><a href="#jQuery-API" class="headerlink" title="jQuery-API"></a>jQuery-API</h2><h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><p>${‘选择器’}  &#x2F;&#x2F;里面选择器直接写CSS选择器，要加引号</p><p>jQuery设置样式</p><p>${‘div’}.css(“background”,”pink”)</p><h3 id="jQuery隐式迭代"><a href="#jQuery隐式迭代" class="headerlink" title="jQuery隐式迭代"></a>jQuery隐式迭代</h3><p>遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。</p><p>简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。</p><h3 id="jQuery筛选选择器"><a href="#jQuery筛选选择器" class="headerlink" title="jQuery筛选选择器"></a>jQuery筛选选择器</h3><p><img src="/image/jquery-2.PNG"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;ul li:first&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;ul li:eq(2)&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;ol li:odd&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;skyblue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;ol li:even&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;pink&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="jQuery筛选方法"><a href="#jQuery筛选方法" class="headerlink" title="jQuery筛选方法"></a>jQuery筛选方法</h3><p><img src="/image/jquery-3.PNG"></p><h3 id="jQuery排他思想"><a href="#jQuery排他思想" class="headerlink" title="jQuery排他思想"></a>jQuery排他思想</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>快速<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 1. 隐式迭代 给所有的按钮都绑定了点击事件</span></span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 2. 当前的元素变化背景颜色</span></span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background&quot;</span>, <span class="hljs-string">&quot;pink&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 3. 其余的兄弟去掉背景颜色 隐式迭代</span></span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">siblings</span>(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>).<span class="hljs-title function_">sibling</span>().<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);     <br><br></code></pre></td></tr></table></figure><h3 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h3><h4 id="操作css"><a href="#操作css" class="headerlink" title="操作css"></a>操作css</h4><p><img src="/image/jquery-4.PNG"></p><p>设置类样式  作用等同于原生的classList</p><p>1.$(“div”).addClass(‘’current’’);  添加类</p><p>2.$(‘div’).removeClass(‘current’) 移除类</p><p>3.$(‘div’).toggleClass(‘current’) 切换类</p><ul><li>jQuery里面的类操作只是对指定类名操作，不会影响原先类名</li></ul><h3 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h3><h4 id="1-显示隐藏效果"><a href="#1-显示隐藏效果" class="headerlink" title="1.显示隐藏效果"></a>1.显示隐藏效果</h4><p><img src="/image/jquery-5.PNG"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>显示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">show</span>(<span class="hljs-number">1000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">hide</span>(<span class="hljs-number">1000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">toggle</span>(<span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 一般情况下，我们都不加参数直接显示隐藏就可以了</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="2-滑动效果"><a href="#2-滑动效果" class="headerlink" title="2.滑动效果"></a>2.滑动效果</h4><p><img src="/image/jquery-6.PNG"></p><p>这些方法的结构都相似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>下拉滑动<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上拉滑动<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>切换滑动<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 下滑动 slideDown()</span></span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">slideDown</span>();</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 上滑动 slideUp()</span></span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">slideUp</span>(<span class="hljs-number">500</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">// 滑动切换 slideToggle()</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">slideToggle</span>(<span class="hljs-number">500</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="3-事件切换"><a href="#3-事件切换" class="headerlink" title="3.事件切换"></a>3.事件切换</h4><p><img src="/image/jquery-7.PNG"></p><h4 id="4-停止动画排队"><a href="#4-停止动画排队" class="headerlink" title="4.停止动画排队"></a>4.停止动画排队</h4><p>stop( )方法用于停止动画排队效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;.nav&gt;li&quot;</span>).<span class="hljs-title function_">hover</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">// stop 方法必须写到动画的前面</span><br>                $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">children</span>(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-title function_">stop</span>().<span class="hljs-title function_">slideToggle</span>();<br>            &#125;);<br></code></pre></td></tr></table></figure><p>谁做动画给谁加stop</p><h4 id="5-淡入淡出效果"><a href="#5-淡入淡出效果" class="headerlink" title="5.淡入淡出效果"></a>5.淡入淡出效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">// 淡入 fadeIn()</span><br>                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">fadeIn</span>(<span class="hljs-number">1000</span>);<br>            &#125;)<br>            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">// 淡出 fadeOut()</span><br>                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">fadeOut</span>(<span class="hljs-number">1000</span>);<br><br>            &#125;)<br>            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">// 淡入淡出切换 fadeToggle()</span><br>                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">fadeToggle</span>(<span class="hljs-number">1000</span>);<br><br>            &#125;);<br>            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">//  修改透明度 fadeTo() 这个速度和透明度要必须写</span><br>                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">fadeTo</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">0.5</span>);<br><br>            &#125;);<br><br><br>        &#125;);<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="6-自定义动画"><a href="#6-自定义动画" class="headerlink" title="6.自定义动画"></a>6.自定义动画</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">animate</span>(params,[speed],[easing],[fn])<br></code></pre></td></tr></table></figure><p>params:想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，<br>如果是复合属性则需要采取驼峰命名法 borderLeft。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>动起来<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        $(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">animate</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">left</span>: <span class="hljs-number">500</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">top</span>: <span class="hljs-number">300</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">opacity</span>: <span class="hljs-number">.4</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">width</span>: <span class="hljs-number">500</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;, <span class="hljs-number">500</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode4.24-30</title>
    <link href="/2023/04/30/leetcode%204.24-4.30/"/>
    <url>/2023/04/30/leetcode%204.24-4.30/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-4-24-4-30"><a href="#leetcode-4-24-4-30" class="headerlink" title="leetcode 4.24-4.30"></a>leetcode 4.24-4.30</h1><h2 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h2><h3 id="5-最长回文子串-双指针"><a href="#5-最长回文子串-双指针" class="headerlink" title="5.最长回文子串 (双指针)"></a>5.最长回文子串 (双指针)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>            string s1=<span class="hljs-built_in">findson</span>(s,i,i);<br>            string s2=<span class="hljs-built_in">findson</span>(s,i,i+<span class="hljs-number">1</span>);<br>            res=res.<span class="hljs-built_in">length</span>()&gt;s1.<span class="hljs-built_in">length</span>()?res:s1;<br>            res=res.<span class="hljs-built_in">length</span>()&gt;s2.<span class="hljs-built_in">length</span>()?res:s2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">findson</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;s.<span class="hljs-built_in">length</span>()&amp;&amp;s[l]==s[r])&#123;<br>            l--;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(l+<span class="hljs-number">1</span>,r-l<span class="hljs-number">-1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>从中间开始向外找，两端不相等时结束，</p><p>从中间往外又有两种情况，一种时123，的2，即奇数串的中间；另一种是1234的2，即偶数串的中间；</p><p>所以判断函数要有两个参数，奇数的时候参数相等，偶数的时候+1</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>86 分隔链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>       ListNode* dummy1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>       ListNode* dummy2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>       ListNode* p1=dummy1,*p2=dummy2;<br>       ListNode* p=head;<br>       <span class="hljs-keyword">while</span>(p)&#123;<br>           <span class="hljs-keyword">if</span>(p-&gt;val&lt;x)&#123;<br>           p1-&gt;next=p;<br>           p1=p1-&gt;next;<br>           &#125;<br>           <span class="hljs-keyword">else</span>&#123;<br>               p2-&gt;next=p;<br>               p2=p2-&gt;next;<br>           &#125;<br>           ListNode* temp=p-&gt;next;<br>           p-&gt;next=<span class="hljs-literal">nullptr</span>;<br>           p=temp;<br>       &#125;<br>       p1-&gt;next=dummy2-&gt;next;<br>       <span class="hljs-keyword">return</span> dummy1-&gt;next;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>23 合并K个升序链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode* res=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.<span class="hljs-built_in">size</span>();i++)&#123;<br>            res=<span class="hljs-built_in">mergetwolist</span>(res,lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergetwolist</span><span class="hljs-params">(ListNode* p1,ListNode* p2)</span></span>&#123;<br>        ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* r=head;<br>        ListNode *ap=p1,*bp=p2;<br>        <span class="hljs-keyword">while</span>(ap&amp;&amp;bp)&#123;<br>            <span class="hljs-keyword">if</span>(ap-&gt;val&lt;bp-&gt;val)&#123;<br>                head-&gt;next=ap;<br>                ap=ap-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                head-&gt;next=bp;<br>                bp=bp-&gt;next;<br>            &#125;<br>            head=head-&gt;next;<br>        &#125;<br>        head-&gt;next=(ap==<span class="hljs-literal">nullptr</span>)?bp:ap;<br>        <span class="hljs-keyword">return</span> r-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用的比较原始的方法，先合并两个链表后，得到新的链表在继续与后面得链表合并，通过循环不断迭代</p><h2 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h2><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* cura=headA;<br>        ListNode* curb=headB;<br>        <span class="hljs-type">int</span> la=<span class="hljs-number">0</span>,lb=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cura)&#123;<br>            la++;<br>            cura=cura-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curb)&#123;<br>            lb++;<br>            curb=curb-&gt;next;<br>        &#125;<br>        cura=headA;<br>        curb=headB;<br>        <span class="hljs-type">int</span> d=la&gt;lb?la-lb:lb-la;<br>        <span class="hljs-keyword">if</span>(la&gt;lb)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(d--)&#123;<br>                cura=cura-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(cura&amp;&amp;curb)&#123;<br>                <span class="hljs-keyword">if</span>(cura==curb)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> cura;<br>                &#125;<br>                cura=cura-&gt;next;<br>                curb=curb-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(d--)&#123;<br>                curb=curb-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(cura&amp;&amp;curb)&#123;<br>                <span class="hljs-keyword">if</span>(cura==curb)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> cura;<br>                &#125;<br>                cura=cura-&gt;next;<br>                curb=curb-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cura;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="143-环形链表"><a href="#143-环形链表" class="headerlink" title="143 环形链表||"></a>143 环形链表||</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">NULL</span>||fast-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        slow=head;<br>        <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h2><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303 区域和检索 - 数组不可变"></a>303 区域和检索 - 数组不可变</h3><p>前缀和数组的方法</p><p>(这道题题目有些特殊，是设计一个类)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        persum.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;persum.<span class="hljs-built_in">size</span>();i++)&#123;<br>            persum[i]=persum[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> persum[right+<span class="hljs-number">1</span>]-persum[left];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; persum;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h2><h3 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304 二维区域和检索 - 矩阵不可变"></a>304 二维区域和检索 - 矩阵不可变</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">private</span>: vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; persum;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>      <br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>||n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        persum=vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; (m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                persum[i][j]=persum[i<span class="hljs-number">-1</span>][j]+persum[i][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]-persum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> persum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-persum[row1][col2+<span class="hljs-number">1</span>]-persum[row2+<span class="hljs-number">1</span>][col1]+persum[row1][col1];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1.有效的字母异位词"></a>1.有效的字母异位词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; a,b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            a[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-built_in">size</span>();i++)&#123;<br>            b[t[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==b)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-29"><a href="#4-29" class="headerlink" title="4.29"></a>4.29</h2><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><p>&#x3D;&#x3D;<strong>什么时候使用哈希法</strong>  ：当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。&#x3D;&#x3D;</p><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h4><p>这道题没看题解用了两个for循环，时间不是很理想，后来看来题解之后分析是没有用到哈希的思想</p><p>先上老版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i]==nums2[j])&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;res.<span class="hljs-built_in">size</span>();k++)&#123;<br>                        <span class="hljs-keyword">if</span>(res[k]==nums2[j])&#123;<br>                            flag=<span class="hljs-number">0</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(flag) res.<span class="hljs-built_in">push_back</span>(nums2[j]);<br>                &#125;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><p>这道题给出了数值范围，因此之间用数组表示hash会更高效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>            <span class="hljs-type">int</span> a[<span class="hljs-number">1001</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>            vector&lt;<span class="hljs-type">int</span>&gt;v;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums1.<span class="hljs-built_in">size</span>();j++)&#123;<br>                a[nums1[j]]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.<span class="hljs-built_in">size</span>();j++)&#123;<br>               <span class="hljs-keyword">if</span>(a[nums2[j]]==<span class="hljs-number">1</span>)&#123;<br>                   v.<span class="hljs-built_in">push_back</span>(nums2[j]);<br>                   a[nums2[j]]++;           <span class="hljs-comment">//通过+1的操作避免重复放入，而且直接用向量就行</span><br>               &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> v;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h4><p>这道题很难和哈希想到一起去。参考了代码随想录的题解，解题的关键在于如果出现了无限循环，那么题目中的sum一定会重复出现，所以只要出现重复的sum，肯定进入了死循环，直接返回false;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; sum;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getsum</span>(n)==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(sum.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">getsum</span>(n)))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    sum.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">getsum</span>(n));<br>                &#125;<br>            &#125;<br>            n=<span class="hljs-built_in">getsum</span>(n);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n=n/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是我有点疑惑，难道不进入循环最终一定能变成1吗 ？</p><p>于是我参考了力扣的官方题解</p><blockquote><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li><p>最终会得到 111。</p></li><li><p>最终会进入循环。</p></li><li><p>值会越来越大，最后接近无穷大。</p><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 111 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><p>DigitsLargestNext<br>1      9 81<br>299162<br>3999243<br>49999324<br>1399999999999991053<br>对于 3位数的数字，它不可能大于 243。这意味着它要么被困在 243以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3位为止。所以我们知道，最坏的情况下，算法可能会在 243以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>​</p></li></ol></blockquote><h4 id="unordered-set用法"><a href="#unordered-set用法" class="headerlink" title="unordered_set用法"></a>unordered_set用法</h4><p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p><p>总的来说，unordered_set 容器具有以下几个特性：</p><p>1.不再以键值对的形式存储数据，而是直接存储数据的值；</p><p>2.容器内部存储的各个元素的值都互不相等，且不能被修改。（即天然去重）</p><p>3.不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关）</p><p>1.声明：</p><p>unordered_set<int> a</int></p><p>2.查找容器中是否有该元素</p><p>a.count(i)   &#x2F;&#x2F;i为查找的元素     如果元素存在于容器中，则此函数返回1，否则返回0。  </p><ol start="3"><li></li></ol><table><thead><tr><th><code>find(key)</code></th><th>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器</th></tr></thead><tbody><tr><td><code>begin()</code></td><td>返回指向容器中第一个元素的正向迭代器</td></tr><tr><td><code>end()</code></td><td>返回指向容器中最后一个元素之后位置的正向迭代器</td></tr><tr><td><code>insert()</code></td><td>向容器中添加新元素</td></tr><tr><td><code>erase()</code></td><td>删除指定元素</td></tr></tbody></table><h4 id="梦开始的地方—-1-两数之和"><a href="#梦开始的地方—-1-两数之和" class="headerlink" title="梦开始的地方—-1.两数之和"></a>梦开始的地方—-1.两数之和</h4><p>第一次做力扣就是这题，用了双重for循环。现在再做，还是想不到别的做法，看了题解才知道这题也可以用哈希表做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(target-nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> &#123;i,map[target-nums[i]]&#125;;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                map[nums[i]]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这道题用到数组，set,map中的map，选择unordered_map,因为涉及到数组的值和索引值，</p><p>map中的存储结构为 {key：数据元素，value：数组元素对应的下标}</p><p>遍历数组，找当前数值对应的值(target-nums[i])是否已经在map中，如果在就可以直接返回索引；不在的话就先把当前遍历的放入map，后续遍历到该值对应的就可以直接返回了。</p><h2 id="4-30"><a href="#4-30" class="headerlink" title="4.30"></a>4.30</h2><h3 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="454-四数相加two"><a href="#454-四数相加two" class="headerlink" title="454.四数相加two"></a>454.四数相加two</h4><p>这道题用的解法是真的想不到，太绝了。</p><p>将两个数组相加可能得到的值放map中，该值表示key，出现次数为value，这样正好表示不同的索引的个数；然后再遍历后面两个数组值相加的情况，只要后面两个值相加的相反数在map中，那么map的value就是后面两个值固定时前面索引变化对应的为0的所有情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; add;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a:nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b:nums2)&#123;<br>                add[a+b]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c:nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d:nums4)&#123;<br>                <span class="hljs-keyword">if</span>(add.<span class="hljs-built_in">count</span>(-c-d))&#123;<br>                    count+=add[-c-d];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>4.30 23:57 五月你好，希望五月会更好。               by JasonWang </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-API-5-BOM</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记10"><a href="#JS学习笔记10" class="headerlink" title="JS学习笔记10"></a>JS学习笔记10</h1><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ul><li><p>BOM是浏览器对象模型</p><p><img src="/../image/js-10-1.jpg"></p><p>​</p><p>​</p></li></ul><ul><li>window对象是一个全局对象，也可以说是JavaScript中的顶级对象</li><li>像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的</li><li>所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li><li>window对象下的属性和方法调用的时候可以省略window</li></ul><h2 id="定时器-延时函数"><a href="#定时器-延时函数" class="headerlink" title="定时器-延时函数"></a>定时器-延时函数</h2><ul><li><p>js中内置的一个用来让代码延迟执行的函数，叫setTimeout</p></li><li><pre><code class="js">setTimeout(回调函数，时间)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>  <span class="hljs-built_in">setTimeout</span> 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略<span class="hljs-variable language_">window</span><br><br>  间歇函数 <span class="hljs-built_in">setInterval</span> : 每隔一段时间就执行一次， , 平时省略<span class="hljs-variable language_">window</span><br><br>* 清楚延时函数<br><br>  <span class="hljs-string">``</span><span class="hljs-string">`js</span><br><span class="hljs-string">  clearTimeout(timerId)</span><br></code></pre></td></tr></table></figure>&gt; 注意点&gt;&gt; 1. 延时函数需要等待,所以后面的代码先执行&gt; 2. 返回值是一个正整数，表示定时器的编号</code></pre></li></ul><h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><p><img src="/image/js-10-2.jpg"></p><p>123</p><h3 id="js的同步和异步"><a href="#js的同步和异步" class="headerlink" title="js的同步和异步"></a>js的同步和异步</h3><p><img src="/image/js-10-3.jpg"></p><p>同步任务都在主线程上执行，形成一个&#x3D;&#x3D;执行栈&#x3D;&#x3D;</p><p><img src="/image/js-10-4.jpg"></p><ol><li><p>先执行&#x3D;&#x3D;执行栈中的同步任务&#x3D;&#x3D;</p></li><li><p>异步任务放到任务队列中</p></li></ol><p><strong>事件循环</strong></p><p>event loop</p><p>同步任务优先执行，异步任务交给浏览器处理，浏览器处理完后添加到任务队列中，同步任务不断检查任务队列</p><p><img src="/../image/js-10-5.jpg"></p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>location (地址) 它拆分并保存了 URL 地址的各个组成部分， 它是一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>搜索<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/music&quot;</span>&gt;</span>音乐<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/download&quot;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reload&quot;</span>&gt;</span>刷新页面<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// location 对象  </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">href</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// location.href = &#x27;http://www.itcast.cn&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. search属性  得到 ? 后面的地址 </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">search</span>)  <span class="hljs-comment">// ?search=笔记本</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. hash属性  得到 # 后面的地址</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 4. reload 方法  刷新页面</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.reload&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// location.reload() // 页面刷新</span></span></span><br><span class="language-javascript"><span class="language-xml">      location.<span class="hljs-title function_">reload</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 强制页面刷新 ctrl+f5</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><ul><li>通过userAgent检测浏览器的版本及平台</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 检测 userAgent（浏览器信息）</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> userAgent = navigator.<span class="hljs-property">userAgent</span><br>  <span class="hljs-comment">// 验证是否为Android或iPhone</span><br>  <span class="hljs-keyword">const</span> android = userAgent.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)<br>  <span class="hljs-keyword">const</span> iphone = userAgent.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(iPhone\sOS)\s([\d_]+)/</span>)<br>  <span class="hljs-comment">// 如果是Android或iPhone，则跳转至移动站点</span><br>  <span class="hljs-keyword">if</span> (android || iphone) &#123;<br>    location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;http://m.itcast.cn&#x27;</span><br>  &#125;&#125;)();<br></code></pre></td></tr></table></figure><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;back&quot;</span>&gt;</span>←后退<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;forward&quot;</span>&gt;</span>前进→<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// histroy对象</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1.前进</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> forward = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.forward&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    forward.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// history.forward() </span></span></span><br><span class="language-javascript"><span class="language-xml">      history.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2.后退</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> back = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.back&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    back.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// history.back()</span></span></span><br><span class="language-javascript"><span class="language-xml">      history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储：将数据存储在本地浏览器中</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ul><li><p>语法</p><p>存储数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key,value)<br></code></pre></td></tr></table></figure><p><strong>作用:</strong> 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失</p><p><strong>特性：</strong>以键值对的形式存储，并且存储的是字符串， 省略了window</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 本地存储 - localstorage 存储的是字符串 </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 存储</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. 获取</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. 删除</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>本地存储只能存储字符串数据类型</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>特性：</p><ul><li>用法跟localStorage基本相同</li><li>区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除</li></ul><h3 id="localStorage-存储复杂数据类型"><a href="#localStorage-存储复杂数据类型" class="headerlink" title="localStorage 存储复杂数据类型"></a>localStorage 存储复杂数据类型</h3><ul><li>存储复杂数据类型，无法直接使用</li></ul><p>解决：需要将复杂数据类型转换成JSON字符串，再存储到本地</p><p>语法：JSON.stringify(obj)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;obj&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))<br></code></pre></td></tr></table></figure><p>JSON对象，属性和值有双引号</p><ul><li>取回来的时候，把JSON字符串转换为对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;obj&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>数组map 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;pink&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 1. 数组 map方法 处理数据并且 返回一个数组</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">ele, index</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// console.log(ele)  // 数组元素</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// console.log(index) // 索引号</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> ele + <span class="hljs-string">&#x27;颜色&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>数组join方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;pink&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 数组 map方法 处理数据并且 返回一个数组</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">ele, index</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// console.log(ele)  // 数组元素</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// console.log(index) // 索引号</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> ele + <span class="hljs-string">&#x27;颜色&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. 数组join方法  把数组转换为字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 小括号为空则逗号分割</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr.<span class="hljs-title function_">join</span>())  <span class="hljs-comment">// red颜色,blue颜色,pink颜色</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 小括号是空字符串，则元素之间没有分隔符</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">//red颜色blue颜色pink颜色</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;|&#x27;</span>))  <span class="hljs-comment">//red颜色|blue颜色|pink颜色</span></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-API-4-日期对象+节点操作</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记9"><a href="#JS学习笔记9" class="headerlink" title="JS学习笔记9"></a>JS学习笔记9</h1><h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date) <span class="hljs-comment">//系统默认时间</span><br>cons date1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2022-5-1 08:30:00&#x27;</span>)<br><span class="hljs-comment">//指定时间</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 实例化</span><br>  <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-comment">// 2. 调用时间对象方法</span><br>  <span class="hljs-comment">// 通过方法分别获取年、月、日，时、分、秒</span><br>  <span class="hljs-keyword">const</span> year = date.<span class="hljs-title function_">getFullYear</span>(); <span class="hljs-comment">// 四位年份</span><br>  <span class="hljs-keyword">const</span> month = date.<span class="hljs-title function_">getMonth</span>(); <span class="hljs-comment">// 0 ~ 11</span><br></code></pre></td></tr></table></figure><p>getFullYear 获取四位年份</p><p>getMonth 获取月份，取值为 0 ~ 11</p><p>getDate 获取月份中的每一天，不同月份取值也不相同</p><p>getDay 获取星期，取值为 0 ~ 6</p><p>getHours 获取小时，取值为 0 ~ 23</p><p>getMinutes 获取分钟，取值为 0 ~ 59</p><p>getSeconds 获取秒，取值为 0 ~ 59</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><ul><li><p>使用场景：如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成</p></li><li><p>算法</p><p>将来的时间戳 - 现在的时间戳 &#x3D; 剩余时间&#x3D;&#x3D;毫秒&#x3D;&#x3D;数</p></li><li><p>三种方法获取时间戳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> date=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>date.<span class="hljs-title function_">getTime</span>()<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><br><span class="hljs-comment">//得到指定时间的时间戳，括号里面加时间</span><br>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2022-4-1 18:30:00&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br></code></pre></td></tr></table></figure><p>​</p></li></ul><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><ul><li>DOM树里面每一个内容都称之为节点</li><li>类型：<ul><li>元素</li><li>属性</li><li>文字</li></ul></li></ul><h3 id="查找节点（默认查元素节点）"><a href="#查找节点（默认查元素节点）" class="headerlink" title="查找节点（默认查元素节点）"></a>查找节点（默认查元素节点）</h3><p>一律用属性查找</p><ul><li>父节点</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> baby=<span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>baby.parentNode<br>baby.parentNode.parentNode<br></code></pre></td></tr></table></figure><ul><li>子节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ul=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>ul.<span class="hljs-property">children</span><span class="hljs-comment">//得到为数组，选择亲儿子 </span><br></code></pre></td></tr></table></figure><ul><li>兄弟节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> li2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul li:nth-child(2)&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(li2.<span class="hljs-property">previousElementSibling</span>)  <span class="hljs-comment">// 上一个兄弟</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(li2.<span class="hljs-property">nextElementSibling</span>)  <span class="hljs-comment">// 下一个兄弟</span><br></code></pre></td></tr></table></figure><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><ol><li>创建节点</li></ol><p>document.createElement(‘div’)</p><p>document.body.appendChild(div)</p><ol start="2"><li>追加节点</li></ol><ul><li>插入到父元素的最后一个子元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ul.<span class="hljs-title function_">appendChild</span>(li)<br></code></pre></td></tr></table></figure><ul><li>插入到父元素中的某个子元素前面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">父元素.<span class="hljs-title function_">insertBefore</span>(要插入的元素，在那个元素前面)<br></code></pre></td></tr></table></figure><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ul.<span class="hljs-title function_">appendChild</span>(ul.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>))<br></code></pre></td></tr></table></figure><p>深克隆：true （li里面的全部内容）</p><p>浅克隆：false（默认，只克隆标签）</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">父元素.<span class="hljs-title function_">removeChild</span>(子元素)<br></code></pre></td></tr></table></figure><h2 id="M端事件（移动端）"><a href="#M端事件（移动端）" class="headerlink" title="M端事件（移动端）"></a>M端事件（移动端）</h2><ol><li>touchstart  触摸开始</li><li>touchend 触摸结束</li><li>touchmove 触摸移动</li></ol><h2 id="SWIPER插件（plugin）"><a href="#SWIPER插件（plugin）" class="headerlink" title="SWIPER插件（plugin）"></a>SWIPER插件（plugin）</h2><p>了解插件的使用方法</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-API-3-事件委托</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记8"><a href="#JS学习笔记8" class="headerlink" title="JS学习笔记8"></a>JS学习笔记8</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。</p><p><img src="/image/js-8-1.jpg"></p><p>如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。</p><p>简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。</p><h3 id="捕获和冒泡"><a href="#捕获和冒泡" class="headerlink" title="捕获和冒泡"></a>捕获和冒泡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>事件流<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 获取嵌套的3个节点</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.outer&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.inner&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// html 元素添加事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;html...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// body 元素添加事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;body...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 外层的盒子添加事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;outer...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 中间的盒子添加事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;inner...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 内层的盒子添加事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？</p><p>结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。</p><p>再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。</p><p>如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。</p><p>如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>事件流<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 获取嵌套的3个节点</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.outer&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.inner&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 外层的盒子</span></span></span><br><span class="language-javascript"><span class="language-xml">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;outer...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">true</span>) <span class="hljs-comment">// true 表示在捕获阶段执行事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 中间的盒子</span></span></span><br><span class="language-javascript"><span class="language-xml">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;inner...&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br><br></code></pre></td></tr></table></figure><ol><li><code>addEventListener</code> 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发</li><li><code>addEventListener</code> 第3个参数为  <code>true</code> 表示捕获阶段触发，<code>false</code> 表示冒泡阶段触发，默认值为 <code>false</code></li><li>事件流只会在父子元素具有相同事件类型时才会产生影响</li><li>绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获）</li></ol><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>默认有冒泡模式，所以容易导致事件影响到父级元素</p><p>借助于事件对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child...&#x27;</span>)<br><br>     <span class="hljs-comment">// 借助事件对象，阻止事件向上冒泡</span><br>     e.<span class="hljs-title function_">stopPropagation</span>()<br>   &#125;)<br></code></pre></td></tr></table></figure><hr><p>阻止默认行为</p><p>某些情况下需要阻止默认行为的发生，如阻止链接的跳转，表单域跳转</p><p><img src="/image/js-8-2.jpg"></p><p>preventDefault()</p><h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><p>L0  btn.onclick&#x3D;null</p><p>L2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">funcition <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>  <br>&#125;<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,fn)<br>btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,fn)<br><br>匿名函数无法解绑<br><br><br></code></pre></td></tr></table></figure><h3 id="鼠标经过事件的区别"><a href="#鼠标经过事件的区别" class="headerlink" title="鼠标经过事件的区别"></a>鼠标经过事件的区别</h3><ul><li>mouseover和mouseout有冒泡</li><li>mouseover和mouseleave没有冒泡事件</li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>利用事件冒泡的特点，减少注册次数，提高程序性能</p><ul><li>给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">应用中需要找到真正触发的元素，e.<span class="hljs-property">target</span><br><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)<br>    ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-comment">// alert(11)</span><br>      <span class="hljs-comment">// this.style.color = &#x27;red&#x27;</span><br>      <span class="hljs-comment">// console.dir(e.target) // 就是我们点击的那个对象</span><br>      <span class="hljs-comment">// e.target.style.color = &#x27;red&#x27;</span><br>      <span class="hljs-comment">// 我的需求，我们只要点击li才会有效果</span><br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;（大写）<br>        e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>      &#125;<br>    &#125;)<br>ul是父元素<br></code></pre></td></tr></table></figure><p>可以用自定义属性来做相同元素的索引号。data-xx&#x3D;’0’;</p><p>对象.dataset.xx</p><h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><ul><li>加载外部资源加载完毕发生的事件</li></ul><p>事件名：load                   (等页面所有资源加载完毕)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <br>&#125;)<br></code></pre></td></tr></table></figure><p>给window添加load事件</p><p>事件名:DOMContentLoaded</p><p>（初始HTML文档加载完成后即可执行）</p><h3 id="元素滚动事件"><a href="#元素滚动事件" class="headerlink" title="元素滚动事件"></a>元素滚动事件</h3><ul><li>滚动条在滚动时持续触发的事件</li><li>事件名:scroll</li><li>监听整个页面滚动(也可以监听有滚动条的DIV)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// xxxxx</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>两个属性</p><p>&#x2F;&#x2F; scrollTop 被卷去的头部</p><p>&#x2F;&#x2F;scrollLeft 被卷去的左部</p><p>这两个值是可读写的（数字型）</p><p>注意：</p><p>获取HTML元素的写法</p><p>document.documentElement</p><p>document.documentElement.scrollTop</p><h3 id="页面尺寸事件"><a href="#页面尺寸事件" class="headerlink" title="页面尺寸事件"></a>页面尺寸事件</h3><ul><li>会在窗口改尺寸的时候触发</li><li>resize</li><li>获取元素可见宽高(包含padding ,不包含border)<ul><li>clientwidth</li><li>clientheight</li></ul></li></ul><h2 id="元素尺寸和位置"><a href="#元素尺寸和位置" class="headerlink" title="元素尺寸和位置"></a>元素尺寸和位置</h2><ul><li>获取宽高<ul><li>获取元素自身宽高，包含border</li><li>offsetWidth,offsetHeight</li><li>取出来的是数值，方便计算</li></ul></li><li>获取位置<ul><li>获取元素距离自己定位父级元素（带有定位的）的左，上距离</li><li>&#x3D;&#x3D;offsetLeft&#x3D;&#x3D;和&#x3D;&#x3D;offsetTop&#x3D;&#x3D;注意是只读属性</li></ul></li></ul><p>​           </p><p>​    element.getBoundingClientRect()</p><p>​    方法返回元素的大小及其相对于视口的位置</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-进阶-拷贝异常节流抖动</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记16"><a href="#JS学习笔记16" class="headerlink" title="JS学习笔记16"></a>JS学习笔记16</h1><h2 id="深浅拷贝（针对引用类型）"><a href="#深浅拷贝（针对引用类型）" class="headerlink" title="深浅拷贝（针对引用类型）"></a>深浅拷贝（针对引用类型）</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>拷贝的是地址</p><p>常见方法：</p><ol><li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li><li>拷贝数组：Array.prototype.concat() 或者 […arr]</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>      <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;jason&#x27;</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>      <span class="hljs-attr">family</span>: &#123;<br>        <span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;1&#x27;</span><br>      &#125;<br>    &#125;<br> <span class="hljs-keyword">const</span> o = &#123;&#125;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(o, obj)<br>    o.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br>    o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;2&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br><span class="hljs-comment">//这里对o.family进行修改，会导致obj里面也修改，因为对象里面的引用类型浅拷贝拷贝了地址</span><br></code></pre></td></tr></table></figure><blockquote><p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>拷贝的是对象，不是地址</p><h4 id="x3D-x3D-通过递归实现深拷贝-x3D-x3D"><a href="#x3D-x3D-通过递归实现深拷贝-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;通过递归实现深拷贝&#x3D;&#x3D;"></a>&#x3D;&#x3D;通过递归实现深拷贝&#x3D;&#x3D;</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj=&#123;<br>  <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;jason&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>]<br>&#125;<span class="hljs-comment">//拷贝对象里有数组对象</span><br><span class="hljs-keyword">const</span> o=&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepcopy</span>(<span class="hljs-params">newobj,oldobj</span>)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldobj)&#123; <span class="hljs-comment">//一定要先写数组，因为数组也是对象会执行第二块内容</span><br>    <span class="hljs-keyword">if</span>(oldobj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)&#123;<br>      newobj[k]=[]<br>      <span class="hljs-title function_">deepcopy</span>(newobj[k],oldobj[k])<br>    &#125;<span class="hljs-comment">//处理里面数组对象的拷贝</span><br>    <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(oldobj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)&#123;<br>      newobj[k]=&#123;&#125;<br>      <span class="hljs-title function_">deepcopy</span>(newobj[k],oldobj[k])<br>    &#125;<span class="hljs-comment">//处理里面对象的拷贝</span><br>    <span class="hljs-keyword">else</span>&#123;<br>      newobj[k]=oldobj[k]<br>    &#125;<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h4><p>js库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  &lt;!-- 先引用 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> obj = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">family</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> o = _.<span class="hljs-title function_">cloneDeep</span>(obj)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)</span></span><br><span class="language-javascript"><span class="language-xml">    o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="利用JSON实现深拷贝"><a href="#利用JSON实现深拷贝" class="headerlink" title="利用JSON实现深拷贝"></a>利用JSON实现深拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> obj = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">family</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        </span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 把对象转换为 JSON 字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// console.log(JSON.stringify(obj))</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)</span></span><br><span class="language-javascript"><span class="language-xml">    o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;123&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>先转换成字符串，再转成对象。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="throw抛异常"><a href="#throw抛异常" class="headerlink" title="throw抛异常"></a>throw抛异常</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!x || !y) &#123;     <span class="hljs-comment">//没有传值就是undefined</span><br>        <span class="hljs-comment">// throw &#x27;没有参数传递进来&#x27;</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;没有参数传递过来&#x27;</span>)<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> x + y<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>())<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>Error对象配合throw使用</li><li>会终止程序</li></ul><h3 id="捕获异常-try-catch-finally"><a href="#捕获异常-try-catch-finally" class="headerlink" title="捕获异常 try catch finally"></a>捕获异常 try catch finally</h3><p>通过try&#x2F;catch捕捉错误信息（浏览器提供的错误信息）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 可能发送错误的代码 要写到 try</span><br>        <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.p&#x27;</span>)<br>        p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span><br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-comment">// 拦截错误，提示浏览器提供的错误信息，但是不中断程序的执行</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;你看看，选择器错误了吧&#x27;</span>)<br>        <span class="hljs-comment">// 需要加return 中断程序</span><br>        <span class="hljs-comment">// return</span><br>      &#125;<br>      <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 不管你程序对不对，一定会执行的代码</span><br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;弹出对话框&#x27;</span>)<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">11</span>)<br>    &#125;<br>    <span class="hljs-title function_">fn</span>()<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="dubugger"><a href="#dubugger" class="headerlink" title="dubugger"></a>dubugger</h3><p>相当于断点，直接在代码里面插入</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>谁调用指向谁</p><p>普通函数没有明确调用者时this值为window,严格模式下没有调用者为undefined</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ol><li>箭头函数会默认帮我们绑定外层this的值 ，箭头函数中this的值和外层的this是一样的</li><li>箭头函数中this引用的就是最近作用域中的this</li><li>向外层作用域中，一层层查找this,直到有this的定义</li></ol><p>箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p><p>原型，构造函数，dom事件函数等等不方便使用箭头函数</p><p>适用需要使用上层this的地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 此处为 window</span><br>  <span class="hljs-comment">// 箭头函数</span><br>  <span class="hljs-keyword">const</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this 一致</span><br>  &#125;<br>  <span class="hljs-comment">// 普通对象</span><br>  <span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this 一致</span><br>    <span class="hljs-attr">walk</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;,<br>    <br>    <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>      <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 该箭头函数中的 this 与 sleep 中的 this 一致</span><br>      &#125;<br>      <span class="hljs-comment">// 调用箭头函数</span><br>      <span class="hljs-title function_">fn</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 动态添加方法</span><br>  user.<span class="hljs-property">sayHi</span> = sayHi<br>  <br>  <span class="hljs-comment">// 函数调用</span><br>  user.<span class="hljs-title function_">sayHi</span>()<br>  user.<span class="hljs-title function_">sleep</span>()<br>  user.<span class="hljs-title function_">walk</span>()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="改变this"><a href="#改变this" class="headerlink" title="改变this"></a>改变this</h3><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>使用call方法调用函数，同时指定被调用函数中this的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fun.<span class="hljs-title function_">call</span>(thisArg,arg1,arg2,...)<br></code></pre></td></tr></table></figure><ul><li>thisArg 在fun运行时指定this的值</li><li>arg1,arg2函数正常的形参</li></ul><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>使用apply方法调用函数，同时指定被调用函数中this的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fun.<span class="hljs-title function_">apply</span>(thisArg,[argsArray])<br></code></pre></td></tr></table></figure><p>argsArray：传递的值，必须包含在数组里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// &#123;age: 18&#125;</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y)<br>    &#125;<br></code></pre></td></tr></table></figure><p>返回值就是函数的返回值</p><h4 id="x3D-x3D-bind-x3D-x3D"><a href="#x3D-x3D-bind-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;bind()&#x3D;&#x3D;"></a>&#x3D;&#x3D;bind()&#x3D;&#x3D;</h4><p>不会调用函数，能改变函数内部this指向，返回值是一个新的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 普通函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  <span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>  &#125;<br>  <span class="hljs-comment">// 调用 bind 指定 this 的值</span><br>  <span class="hljs-keyword">let</span> sayHello = sayHi.<span class="hljs-title function_">bind</span>(user);<br>  <span class="hljs-comment">// 调用使用 bind 创建的新函数</span><br>  <span class="hljs-title function_">sayHello</span>()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul><li>单位时间内，频繁触发事件，只执行最后一次</li></ul><p> 场景：搜索框搜索输入。只需用户最后依次输入完成</p><p>​             手机号，邮箱验证输入检测</p><p>实现：</p><ol><li>lodash提供的防抖处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">_.<span class="hljs-title function_">debounce</span>(func,[wait=<span class="hljs-number">0</span>],[options=])<br></code></pre></td></tr></table></figure><p>2.手写一个防抖函数</p><p>(防抖的核心就是利用setTimeout实现)</p><ol><li>声明定时器变量</li><li>每次鼠标移动时要先判断是否有定时器，有的话清除以前的定时器</li><li>如果没有定时器，则开启</li><li>定时器里面写函数调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;<br>      box.<span class="hljs-property">innerHTML</span> = ++i<br>      <span class="hljs-comment">// 如果里面存在大量操作 dom 的情况，可能会卡顿</span><br>    &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,t</span>)&#123;<br>  <span class="hljs-keyword">let</span> timeId<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">//这里返回匿名函数很关键，相当于形成了一个闭包</span><br>    <span class="hljs-keyword">if</span>(timeId) <span class="hljs-built_in">clearTimeout</span>(timeId)<br>    timeId =<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-title function_">fn</span>();<br>    &#125;,t)<br>  &#125;<br>&#125;<br>box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>,<span class="hljs-title function_">debounce</span>(mouseMove,<span class="hljs-number">500</span>))<br></code></pre></td></tr></table></figure><p>为什么return一个匿名函数？不用行不行？<br>确保事件触发的是匿名函数，不会重新将timer置为null。同时，匿名函数是一个闭包，timer变量不会被回收。这样，就能使用<code>clearTimeout</code>清空上次的定时器了。默默摸摸你</p><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h2><p>单位时间内，频繁触发事件，只执行一次</p><ol><li>lodash提供的节流函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, _.<span class="hljs-title function_">throttle</span>(mouseMove, <span class="hljs-number">500</span>))<br></code></pre></td></tr></table></figure><p>   2.手写节流函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,t</span>)&#123;<br>  <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">if</span>(!timer)&#123;<br>      timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">fn</span>()<br>        timer=<span class="hljs-literal">null</span> <span class="hljs-comment">//这里清空定时器必须用这个方法，因为定时器函数里面无法使用cleartimeout</span><br>      &#125;,t)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-进阶-原型</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记15"><a href="#JS学习笔记15" class="headerlink" title="JS学习笔记15"></a>JS学习笔记15</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>js通过构造函数实现封装</p><ul><li>但是存在浪费内存的问题</li><li>用原型解决构造函数浪费内存的问题</li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul><li>构造函数通过原型分配的函数是所有对象所共享的</li><li>JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，所以我们称为原型对象</li><li>公共的方法写到原型对象身上</li></ul><p>&#x3D;&#x3D;构造函数和原型里面的this都指向实例化的对象&#x3D;&#x3D;</p><h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><p>每个原型对象里面都有一个constructor属性，指向该原型的构造函数</p><p>使用场景：</p><p>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样会覆盖构造函数原型对象原来的内容，即修改后的原型对象失去了constructor,所以需要重新加上。</p><h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><p>对象都会有一个属性<code> __proto__</code> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有<code> __proto__</code> 原型的存在。</p><ul><li><code>__proto__</code>对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数</li></ul><ul><li><code>__proto__ </code>是JS非标准属性</li><li>[[prototype]]和<code>__proto__</code>意义相同</li><li>用来表明当前实例对象指向哪个原型对象prototype</li><li>&#x3D;&#x3D;只要是对象就有这个属性&#x3D;&#x3D;</li></ul><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 继续抽取   公共的部分放到原型上</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const Person1 = &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   eyes: 2,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   head: 1</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const Person2 = &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   eyes: 2,</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   head: 1</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 构造函数  new 出来的对象 结构一样，但是对象不一样</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eyes</span> = <span class="hljs-number">2</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-number">1</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// console.log(new Person)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 女人  构造函数   继承  想要 继承 Person</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Woman</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// Woman 通过原型来继承 Person</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 父构造函数（父类）   子构造函数（子类）</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 子类的原型 =  new 父类  </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Woman</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()   <span class="hljs-comment">// &#123;eyes: 2, head: 1&#125; </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 指回原来的构造函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Woman</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Woman</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 给女人添加一个方法  生孩子</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Woman</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">baby</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;宝贝&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(red)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// console.log(Woman.prototype)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 男人 构造函数  继承  想要 继承 Person</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Man</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 通过 原型继承 Person</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Man</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Man</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Man</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> pink = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pink)</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><ul><li>某些构造函数想要继承某个类的属性，于是就将父类创造的对象赋值给原型，但是赋值的父类的对象不能相同，得用构造函数创造不同的对象，因为相同的对象引用地址相同，会导致给该原型添加方法是，所以引用该原型的子类都会加上那个方法。</li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/image/js-15-1.jpg"></p><p>① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</p><p>② 如果没有就查找它的原型（也就是 <code>__proto__</code>指向的 prototype 原型对象）</p><p>③ 如果还没有就查找原型对象的原型（Object的原型对象）</p><p>④ 依此类推一直找到 Object 为止（null）</p><p>⑤<code> __proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p><p>⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p><p>(数组向上查找到Array.prototype,Array.prototype向上还是Object.prototype)</p><p>可以认为是一种查找路径。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-进阶-构造函数</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记14"><a href="#JS学习笔记14" class="headerlink" title="JS学习笔记14"></a>JS学习笔记14</h1><h2 id="深入对象"><a href="#深入对象" class="headerlink" title="深入对象"></a>深入对象</h2><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ol><li>利用对象字面量创建</li><li>new Object()</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br></code></pre></td></tr></table></figure><h4 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h4><ul><li>是一种特殊的函数，主要用来初始化对象。（创建多个类似的对象）</li><li>命名以大写字母开头</li><li>只能由 new 操作符来执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Pig</span>(<span class="hljs-params">uname,age</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span>=uname;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>(<span class="hljs-string">&#x27;佩奇&#x27;</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><ul><li>new调用函数的行为被称为实例化</li><li>构造函数内部无需写return</li></ul><h4 id="实例化执行过程"><a href="#实例化执行过程" class="headerlink" title="实例化执行过程"></a>实例化执行过程</h4><ol><li>创建新对象</li><li>构造函数执行this指向新对象</li><li>执行构造函数代码，修改this，添加新的属性</li><li>返回新对象</li></ol><h4 id="实例成员-amp-静态成员"><a href="#实例成员-amp-静态成员" class="headerlink" title="实例成员&amp;静态成员"></a>实例成员&amp;静态成员</h4><ul><li><p>通过构造函数创建的对象称为实例对象，实例对象中的属性和方法属于实例成员</p></li><li><p>不同实例之间的实例成员互不影响</p></li><li><p>静态成员：构造函数的属性和方法</p></li><li><p>静态成员写在构造函数身上</p></li></ul><h2 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h2><p>js底层完成，把简单数据类型包装成了引用数据类型的构造函数称为包装类型。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ol><li>Object.keys静态方法获取对象中所有属性名</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">key</span>(o)) 输出一个属性名数组<br></code></pre></td></tr></table></figure><ol start="2"><li>Object.value静态方法获取对象中所有属性值</li></ol><p>输出一个属性值数组</p><ol start="3"><li>Object.assign对象的拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(a,b)<br>把b拷贝给a<br></code></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p> 1.数组常见实例方法</p><p>forEach() 遍历  不返回数组</p><p>filter()   过滤    返回新数组（满足筛选条件的新数组）</p><p>map() 迭代数组 返回新数组（返回处理完后的新数组）</p><p>reduce(function(prev,current){},初始值)  返回一个值，初始值可选 </p><p><img src="/image/js-14-1.jpg"></p><p>2.其他方法</p><p>find() 返回数组中满足提供的测试函数的第一个元素的值，否则返回UNDEFINED</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br>    <span class="hljs-keyword">const</span> re = arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>      <span class="hljs-keyword">return</span> item === <span class="hljs-string">&#x27;blue&#x27;</span><br>    &#125;)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re)<br></code></pre></td></tr></table></figure><p>every() 返回布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>    <span class="hljs-keyword">const</span> flag = arr1.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt;= <span class="hljs-number">20</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag)<br><span class="hljs-comment">// every 每一个是否都符合条件，如果都符合返回 true ，否则返回false</span><br></code></pre></td></tr></table></figure><p>some()返回布尔值，只要有一个符合就是true</p><p>Arrat.from(伪数组) 把伪数组转化为真数组</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>常见实例方法</p><p>   1.split()  把字符串转化为数组</p><p>   2.字符串的截取   substring(开始的索引号[， 结束的索引号]) 中括号表示可选参数</p><ul><li>如果省略结束的索引号，默认取到最后</li><li>结束的索引号不包含想要截取的部分</li></ul><ol start="3"><li>startsWith() 判断是不是以某个字符开头</li><li>includes() 判断某个字符是不是包含在一个字符串里面</li></ol><h4 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed"></a>toFixed</h4><p>让数字保留指定的小数位数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// toFixed 方法可以让数字指定保留的小数位数</span><br>    <span class="hljs-keyword">const</span> num = <span class="hljs-number">10.923</span><br>    <span class="hljs-comment">// console.log(num.toFixed())</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">const</span> num1 = <span class="hljs-number">10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-进阶-函数</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记13"><a href="#JS学习笔记13" class="headerlink" title="JS学习笔记13"></a>JS学习笔记13</h1><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>函数可以在声明之前调用，会把所以函数声明提升到当前作用域的最前面，</p><p>只提升函数声明不提升函数调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 调用函数</span><br>  <span class="hljs-title function_">foo</span>()<br>  <span class="hljs-comment">// 声明函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;声明之前即被调用...&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 不存在提升现象</span><br>  <span class="hljs-title function_">bar</span>()  <span class="hljs-comment">// 错误</span><br>  <span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;函数表达式不存在提升现象...&#x27;</span>)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol><li>函数提升能够使函数的声明调用更灵活</li><li>函数表达式不存在提升的现象</li><li>函数提升出现在相同作用域当中</li></ol><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p><code>arguments</code> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 求生函数，计算所有参数的和</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// console.log(arguments)</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      s += <span class="hljs-variable language_">arguments</span>[i]<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<br>  &#125;<br>  <span class="hljs-comment">// 调用求和函数</span><br>  <span class="hljs-title function_">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">// 两个参数</span><br>  <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 两个参数</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>(当不确定传入多少实参时)</p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><ul><li>…是语法符号，置于最末函数形参之前，用于获取最后的形参</li><li>剩余参数是真数组</li><li>实际开发多用剩余参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">config</span>(<span class="hljs-params">baseURL, ...other</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baseURL) <span class="hljs-comment">// 得到 &#x27;http://baidu.com&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(other)  <span class="hljs-comment">// other  得到 [&#x27;get&#x27;, &#x27;json&#x27;]</span><br>  &#125;<br>  <span class="hljs-comment">// 调用函数</span><br>  <span class="hljs-title function_">config</span>(<span class="hljs-string">&#x27;http://baidu.com&#x27;</span>, <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;json&#x27;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p><code> ...</code>展开运算符用于将数组展开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...arr)<br></code></pre></td></tr></table></figure><ul><li>不会修改原数组</li><li>典型应用：求数组最大值（最小值），合并数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr)<br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...arr)<br>a=[...arr1,...arr2]<br></code></pre></td></tr></table></figure><h3 id="x3D-x3D-箭头函数-x3D-x3D"><a href="#x3D-x3D-箭头函数-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;箭头函数&#x3D;&#x3D;"></a>&#x3D;&#x3D;箭头函数&#x3D;&#x3D;</h3><p>更简短的函数写法并且不绑定this,语法比函数表达式更简洁</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span>=(<span class="hljs-params"></span>) =&gt; &#123;<br>  函数体<br>&#125;<br><span class="hljs-title function_">fn</span>()<br><br></code></pre></td></tr></table></figure><ul><li>只有一个形参的时候，可以省略小括号</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span>= x =&gt;&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>只有一行代码时，可以省略大括号</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span>=(<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ul><li>只有一行代码，可以省略return,直接返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span>= (<span class="hljs-params">x,y</span>)=&gt; x+y <br></code></pre></td></tr></table></figure><ul><li>箭头函数可以直接返回一个对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span>=(<span class="hljs-params">uname</span>)=&gt;(&#123;<span class="hljs-attr">uname</span>: uname&#125;)<br></code></pre></td></tr></table></figure><ol><li>箭头函数属于表达式函数，因此不存在函数提升</li><li>箭头函数只有一个参数时可以省略圆括号 <code>()</code></li><li>箭头函数函数体只有一行代码时可以省略花括号 <code>&#123;&#125;</code>，并自动做为返回值被返回</li><li>加括号的函数体返回对象字面量表达式</li></ol><h4 id="箭头函数参数"><a href="#箭头函数参数" class="headerlink" title="箭头函数参数"></a>箭头函数参数</h4><p>没有arguements,有剩余参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSum</span> = (<span class="hljs-params">...arr</span>) =&gt;&#123;<br>  <span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>    sum+=arr[i]<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h4><p>箭头函数不会创建自己的this,从上层作用域找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">//window</span><br>  &#125;<br>    箭头函数的<span class="hljs-variable language_">this</span>  是上一层作用域的<span class="hljs-variable language_">this</span> 指向<br>     <br>     对象方法箭头函数 <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> obj = &#123;<br>      <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink老师&#x27;</span>,<br>      <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">// this 指向谁？ window</span><br>        <span class="hljs-comment">//window.obj.sayHi</span><br>       &#125;<br>     &#125;<br>     obj.<span class="hljs-title function_">sayHi</span>()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>dom事件的回调函数为了简便，不太推荐用箭头函数</p><p>事件回调函数为this时，指向window</p><h3 id="x3D-x3D-解构赋值-x3D-x3D"><a href="#x3D-x3D-解构赋值-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;解构赋值&#x3D;&#x3D;"></a>&#x3D;&#x3D;解构赋值&#x3D;&#x3D;</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><p>数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法</p><p>基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>[a,b,c]=arr<br><span class="hljs-comment">//交换变量</span><br><span class="hljs-keyword">let</span> a=<span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-number">2</span>;    <span class="hljs-comment">//这里必须加上分号</span><br>[b,a]=[a,b]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b)<br><span class="hljs-comment">//没有分号会识别成这样</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-number">2</span>[b,a]=[a,b]  导致报错<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;加分号的情况还有立即执行函数&#x3D;&#x3D;</p><p>总结：</p><ol><li>赋值运算符 <code>=</code> 左侧的 <code>[]</code> 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量</li><li>变量的顺序对应数组单元值的位置依次进行赋值操作</li><li>变量的数量大于单元值数量时，多余的变量将被赋值为  <code>undefined</code></li><li>变量的数量小于单元值数量时，可以通过 <code>...</code> 获取剩余单元值，但只能置于最末位</li><li>允许初始化变量的默认值，且只有单元值为 <code>undefined</code> 时默认值才会生效</li></ol><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 普通对象</span><br>  <span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>  &#125;;<br>  <span class="hljs-comment">// 批量声明变量 name age</span><br>  <span class="hljs-comment">// 同时将数组单元值 小明  18 依次赋值给变量 name  age</span><br>  <span class="hljs-keyword">const</span> &#123;name, age&#125; = user<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name) <span class="hljs-comment">// 小明</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age) <span class="hljs-comment">// 18</span><br><br> 对象解构的变量名 可以重新改名  旧变量名: 新变量名<br>    <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">uname</span>: username, age &#125; = &#123; <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;jason&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol><li>赋值运算符 <code>=</code> 左侧的 <code>&#123;&#125;</code> 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量</li><li>对象属性的值将被赋值给与属性名相同的变量</li><li>对象中找不到与变量名一致的属性时变量值为 <code>undefined</code></li><li>允许初始化变量的默认值，属性不存在或单元值为 <code>undefined</code> 时默认值才会生效</li></ol><p>多维解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 这是后台传递过来的数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> msg = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;获取新闻列表成功&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-string">&quot;data&quot;</span>: [</span></span><br><span class="language-javascript"><span class="language-xml">        &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;5G商用自己，三大运用商收入下降&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">58</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">2</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;国际媒体头条速览&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">56</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">3</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;乌克兰和俄罗斯持续冲突&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">1669</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      ]</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 需求1： 请将以上msg对象  采用对象解构的方式 只选出  data 方面后面使用渲染页面</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const &#123; data &#125; = msg</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// console.log(data)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const &#123; data &#125; = msg</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// msg 虽然很多属性，但是我们利用解构只要 data值</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">&#123; data &#125;</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// const &#123; data &#125; = arr</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 我们只要 data 数据</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 内部处理</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">render</span>(msg)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">&#123; data: myData &#125;</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 要求将 获取过来的 data数据 更名为 myData</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 内部处理</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myData)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">render</span>(msg)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>forEach(适合遍历数组对象)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;pink&#x27;</span>]<br>    <span class="hljs-keyword">const</span> result = arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)  <span class="hljs-comment">// 数组元素 red  green pink</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index) <span class="hljs-comment">// 索引号</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>filter（筛选数组方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>   <span class="hljs-comment">// const newArr = arr.filter(function (item, index) &#123;</span><br>   <span class="hljs-comment">//   // console.log(item)</span><br>   <span class="hljs-comment">//   // console.log(index)</span><br>   <span class="hljs-comment">//   return item &gt;= 20</span><br>   <span class="hljs-comment">// &#125;)</span><br>   <span class="hljs-comment">// 返回的符合条件的新数组</span><br><br>   <span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt;= <span class="hljs-number">20</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-进阶-作用域-闭包</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记12"><a href="#JS学习笔记12" class="headerlink" title="JS学习笔记12"></a>JS学习笔记12</h1><p>进阶部分</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><ol><li>函数内部声明的变量，在函数外部无法被访问</li><li>函数的参数也是函数内部的局部变量</li><li>不同函数内部声明的变量无法互相访问</li><li>函数执行完毕后，函数内部的变量实际被清空了</li></ol><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>在 JavaScript 中使用 <code>&#123;&#125;</code> 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  &#123;<br>    <span class="hljs-comment">// age 只能在该代码块中被访问</span><br>    <span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 正常</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 超出了 age 的作用域</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age) <span class="hljs-comment">// 报错</span><br>  <br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span>(flag) &#123;<br>    <span class="hljs-comment">// str 只能在该代码块中被访问</span><br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world!&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 正常</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 超出了 age 的作用域</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 报错</span><br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">6</span>; t++) &#123;<br>    <span class="hljs-comment">// t 只能在该代码块中被访问</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t); <span class="hljs-comment">// 正常</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 超出了 t 的作用域</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t); <span class="hljs-comment">// 报错</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol><li><code>let</code> 声明的变量会产生块作用域，<code>var</code> 不会产生块作用域</li><li><code>const</code> 声明的常量也会产生块作用域</li><li>不同代码块之间的变量无法互相访问</li><li>推荐使用 <code>let</code> 或 <code>const</code></li></ol><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p><code>&lt;script&gt;</code> 标签和 <code>.js</code> 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。</p><ol><li>为 <code>window</code> 对象动态添加的属性默认也是全局的，不推荐！</li><li>函数中未使用任何关键字声明的变量为全局变量，不推荐！！！</li><li>尽可能少的声明全局变量，防止全局变量被污染</li></ol><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链本质上是底层的&#x3D;&#x3D;变量查找机制&#x3D;&#x3D;</p><ul><li>在函数被执行时，会优先查找当前函数作用域中查找变量</li><li>如果当前作用域查找不到会依次逐级查找父级作用域直到全局作用域</li></ul><p>总结：</p><ol><li>嵌套关系的作用域串联起来形成了作用域链</li><li>相同作用域链中按着从小到大的规则查找变量</li><li>&#x3D;&#x3D;子作用域能够访问父作用域，父级作用域无法访问子级作用域&#x3D;&#x3D;</li></ol><h2 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h2><p>内存的生命周期</p><ol><li>内存分配</li><li>内存使用</li><li>内存回收</li></ol><ul><li>全局变量一般不会回收（页面关闭）</li><li>一般局部变量的值，不用了，会被自动回收</li></ul><p>算法说明</p><ol><li>栈（操作系统）：由操作系统自动分配释放函数的参数值，局部变量等</li><li>堆（操作系统）：一般由程序员分配释放，程序员不释放，由垃圾回收机制释放</li></ol><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>1.跟踪记录被引用的次数</p><p>2.如果被引用了一次，那么就记录次数1，多次引用会累加</p><p>3.如果减少一个引用就减1</p><p>4.如果引用次数是0，则释放内存</p><p>问题:如果两个对象存在相互引用（嵌套引用），那么生命周期结束后将无法被回收</p><h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><ol><li><p>将不再使用的对象定义为无法达到的对象</p></li><li><p>从根部扫描对象，能查到的就是使用的，查不到的就要回收</p></li></ol><h2 id="x3D-x3D-闭包-x3D-x3D"><a href="#x3D-x3D-闭包-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;闭包&#x3D;&#x3D;"></a>&#x3D;&#x3D;闭包&#x3D;&#x3D;</h2><p>闭包&#x3D;内层函数+外层函数的变量</p><p>有点像私有数据成员通过成员函数去访问的关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 闭包 : 内层函数 + 外层函数变量</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// function outer() &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   const a = 1</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   function f() &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(a)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   f()</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// outer()</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. 闭包的应用： 实现数据的私有。统计函数的调用次数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// let count = 1</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// function fn() &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   count++</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   console.log(`函数被调用$&#123;count&#125;次`)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. 闭包的写法  统计函数的调用次数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        count++</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`函数被调用<span class="hljs-subst">$&#123;count&#125;</span>次`</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> fn                 <span class="hljs-comment">//返回了内层函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> re = <span class="hljs-title function_">outer</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const re = function fn() &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   count++</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   console.log(`函数被调用$&#123;count&#125;次`)</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">re</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">re</span>()</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const fn = function() &#123; &#125;  函数表达式</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 4. 闭包存在的问题： 可能会造成内存泄漏</span></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>2.闭包的作用？</p><ul><li>封闭数据，实现数据私有，外部也可以访问函数内部的变量</li><li>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来</li></ul><p>3.闭包可能引起的问题？</p><ul><li>内存泄漏</li></ul><p>（根据标记清除法的机制，外层函数的变量可能被继续使用，因此可能不被清除）</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>它允许变量在声明之前被访问（var）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 访问变量 str</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str + <span class="hljs-string">&#x27;world!&#x27;</span>);<br><br>  <span class="hljs-comment">// 声明变量 str</span><br>  <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello &#x27;</span>;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;var使str声明放在了全局作用域的最上面，但是只提升声明不赋值&#x3D;&#x3D;</p><p>总结：</p><ol><li>变量在未声明即被访问时会报语法错误</li><li>变量在声明之前即被访问，变量的值为 <code>undefined</code></li><li><code>let</code> 声明的变量不存在变量提升，推荐使用 <code>let</code></li><li>变量提升出现在相同作用域当中</li><li>实际开发中推荐先声明再访问变量</li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-API-6-正则</title>
    <link href="/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011/"/>
    <url>/2023/04/29/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记11"><a href="#JS学习笔记11" class="headerlink" title="JS学习笔记11"></a>JS学习笔记11</h1><h2 id="x3D-x3D-正则表达式-x3D-x3D"><a href="#x3D-x3D-正则表达式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;正则表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;正则表达式&#x3D;&#x3D;</h2><ul><li><p>用于匹配字符串中字符组合的模式。在JS中也是对象。</p></li><li><p>通常用来查找替换那些符合正则表达式的文本</p></li></ul><p>使用场景</p><blockquote><p>验证表单</p><p>过滤敏感词（替换）</p><p>从字符串中获取想要的特定部分（提取）</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li>定义规则</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg=<span class="hljs-regexp">/前端/</span>    <span class="hljs-comment">//不用引号，写什么查什么</span><br></code></pre></td></tr></table></figure><p>其中<code>/   /</code>是正则表达式字面量</p><ol start="2"><li>是否匹配</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">test</span>() 方法用来查看是否匹配<br><br>regObj.<span class="hljs-title function_">test</span>(被检查的字符串)<br>regObj为定义的规则<br><br></code></pre></td></tr></table></figure><p>如果正则表达式与指定的字符串匹配 ，返回<code>true</code>，否则<code>false</code></p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>是一项具有特殊意义的字符，可以极大提高了灵活性和强大的匹配功能</p><ul><li>abcdefg</li><li>换成元字符[a-z]</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><h5 id="边界符（表示位置）"><a href="#边界符（表示位置）" class="headerlink" title="边界符（表示位置）"></a>边界符（表示位置）</h5></li></ul><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本，以谁开头</td></tr><tr><td>$</td><td>表示匹配行末的文本，以谁结尾</td></tr></tbody></table><p>如果 ^ 和 $ 在一起，表示必须是精确匹配</p><ul><li><h5 id="量词（表示重复次数）"><a href="#量词（表示重复次数）" class="headerlink" title="量词（表示重复次数）"></a>量词（表示重复次数）</h5></li></ul><p>用来设定某个模式出现的次数</p><p><img src="/image/js-11-1.jpg"></p><p>注意： 逗号左右两侧千万不要出现空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 元字符之量词</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. * 重复次数 &gt;= 0 次</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/^w*$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ww&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-----------------------&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. + 重复次数 &gt;= 1 次</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg2 = <span class="hljs-regexp">/^w+$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ww&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-----------------------&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. ? 重复次数  0 || 1 </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg3 = <span class="hljs-regexp">/^w?$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ww&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-----------------------&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 4. &#123;n&#125; 重复 n 次</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg4 = <span class="hljs-regexp">/^w&#123;3&#125;$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">// flase</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ww&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;www&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;wwww&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-----------------------&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 5. &#123;n,&#125; 重复次数 &gt;= n </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg5 = <span class="hljs-regexp">/^w&#123;2,&#125;$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ww&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;www&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-----------------------&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 6. &#123;n,m&#125;   n =&lt; 重复次数 &lt;= m</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg6 = <span class="hljs-regexp">/^w&#123;2,4&#125;$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg6.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg6.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ww&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg6.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;www&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg6.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;wwww&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg6.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;wwwww&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5></li></ul><p>[]匹配字符集合(&#x3D;&#x3D;只选一个！&#x3D;&#x3D;)</p><p><img src="/image/js-11-2.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 元字符之范围  []  </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. [abc] 匹配包含的单个字符， 多选1</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/^[abc]$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;b&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;c&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;d&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ab&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. [a-z] 连字符 单个</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg2 = <span class="hljs-regexp">/^[a-z]$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;p&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;0&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;A&#x27;</span>))  <span class="hljs-comment">// false</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 想要包含小写字母，大写字母 ，数字</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg3 = <span class="hljs-regexp">/^[a-zA-Z0-9]$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;B&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;b&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-number">9</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg3.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;,&#x27;</span>))  <span class="hljs-comment">// flase</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg4 = <span class="hljs-regexp">/^[a-zA-Z0-9_]&#123;6,16&#125;$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcd1&#x27;</span>))  <span class="hljs-comment">// false </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcd12&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ABcd12&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ABcd12_&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 3. [^a-z] 取反符</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> reg5 = <span class="hljs-regexp">/^[^a-z]$/</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>))  <span class="hljs-comment">// false </span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;A&#x27;</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg5.<span class="hljs-title function_">test</span>(<span class="hljs-number">8</span>))  <span class="hljs-comment">// true</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h5 id="字符类（等于上面模式的更一步简化）"><a href="#字符类（等于上面模式的更一步简化）" class="headerlink" title="字符类（等于上面模式的更一步简化）"></a>字符类（等于上面模式的更一步简化）</h5><ul><li>某些常见模式的简写方式，区分字母和数字</li></ul><p><img src="/image/11-js-3.jpg"></p><h5 id="修饰符和替换"><a href="#修饰符和替换" class="headerlink" title="修饰符和替换"></a>修饰符和替换</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 替换和修饰符</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 替换  replace  需求：把前端替换为 web</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1.1 replace 返回值是替换完毕的字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个</span></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等</p><ul><li>i 是单词 ignore 的缩写，正则匹配时字母不区分大小写</li><li>g 是单词 global 的缩写，匹配所有满足正则表达式的结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 替换和修饰符</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1. 替换  replace  需求：把前端替换为 web</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 1.1 replace 返回值是替换完毕的字符串</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替换一个</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 2. 修饰符 g 全部替换</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> strEnd = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/前端/g</span>, <span class="hljs-string">&#x27;web&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strEnd) </span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode4.17-23</title>
    <link href="/2023/04/24/Leetcode4.17-4.23/"/>
    <url>/2023/04/24/Leetcode4.17-4.23/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode4-17-4-23"><a href="#Leetcode4-17-4-23" class="headerlink" title="Leetcode4.17-4.23"></a>Leetcode4.17-4.23</h1><h2 id="4-17"><a href="#4-17" class="headerlink" title="4.17"></a>4.17</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h4><p>这个题目有点难理解，意思就是找至多包含两种元素的最长子串，返回其长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">totalFruit</span>(<span class="hljs-params">vector&lt;int&gt;&amp; fruits</span>) &#123;<br>        int i=<span class="hljs-number">0</span>;<br>        int count=<span class="hljs-number">1</span>;<br>        int result=<span class="hljs-number">1</span>;<br>        vector&lt;int&gt; <span class="hljs-title function_">kind</span>(fruits.<span class="hljs-title function_">size</span>(),<span class="hljs-number">0</span>);<br>        kind[fruits[i]]++;<br>        <span class="hljs-keyword">for</span>(int j=<span class="hljs-number">1</span>;j&lt;fruits.<span class="hljs-title function_">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(kind[fruits[j]]==<span class="hljs-number">0</span>)&#123;<br>                kind[fruits[j]]++;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                kind[fruits[j]]++;<span class="hljs-comment">/*注意1*/</span><br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">2</span>)&#123;<br>                kind[fruits[i]]--;<br>                <span class="hljs-keyword">if</span>(!kind[fruits[i]])&#123;<br>                    count--;<br>                &#125;<br>                i++;<br>            &#125;<br>            result=result&gt;(j-i+<span class="hljs-number">1</span>)?<span class="hljs-attr">result</span>:j-i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>滑动窗口加哈希表</p><p>改了两次bug 终于改对了  第一次是没注意已经放入HASH表中的元素遍历过程中对hash表的影响，即kind[fruits[j]]++;</p><p>还有就是我J从1开始，所以result开始时要设置为1；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = fruits.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>            ++cnt[fruits[right]];<br>            <span class="hljs-keyword">while</span> (cnt.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">auto</span> it = cnt.<span class="hljs-built_in">find</span>(fruits[left]);<br>                --it-&gt;second;<br>                <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">0</span>) &#123;<br>                    cnt.<span class="hljs-built_in">erase</span>(it);<br>                &#125;<br>                ++left;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/fruit-into-baskets/solutions/1893352/shui-guo-cheng-lan-by-leetcode-solution-1uyu/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>我是用了一个向量起到了HASH的作用，官方直接用了相应的类，直接调用方法方便多了（unordered_map）</p><h2 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h2><h3 id="滑动算法"><a href="#滑动算法" class="headerlink" title="滑动算法"></a>滑动算法</h3><p>今天看一下labuladong的滑动窗口模板，解决一下这道困扰我很久的问题</p><p><code>unordered_map</code> 就是哈希表（字典），相当于 Java 的 <code>HashMap</code>，它的一个方法 <code>count(key)</code> 相当于 Java 的 <code>containsKey(key)</code> 可以判断键 key 是否存在。</p><h4 id="76最小覆盖字串"><a href="#76最小覆盖字串" class="headerlink" title="76最小覆盖字串"></a>76最小覆盖字串</h4><p>模板框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 滑动窗口算法框架 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-comment">// 用合适的数据结构记录窗口中的数据</span><br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-type">char</span> c = s[right];<br>        winodw.<span class="hljs-built_in">add</span>(c)<br>        <span class="hljs-comment">// 增大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">/*** debug 输出的位置 ***/</span><br>        <span class="hljs-comment">// 注意在最终的解法代码中不要 print</span><br>        <span class="hljs-comment">// 因为 IO 操作很耗时，可能导致超时</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">/********************/</span><br>        <br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-type">char</span> d = s[left];<br>            winodw.<span class="hljs-built_in">remove</span>(d)<br>            <span class="hljs-comment">// 缩小窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>窗口数据的更新</li><li>判断左侧窗口是否收缩的条件</li><li>滑动过程中题目所求的结果确认（最大或者最小）</li></ol><p>（基本都用HASH表作为窗口数据的统计，然后写出判断条件）</p><p>这些点因题而异，但是基本逃不出上面的框架。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>,len=INT_MAX;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; need,window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t) need[c]++;<br>        <span class="hljs-keyword">while</span>(right&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">char</span> c=s[right];<br>            right++;<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>                window[c]++;<br>                <span class="hljs-keyword">if</span>(window[c]==need[c])&#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(count==need.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(right-left&lt;len)&#123;<br>                    len=right-left;<br>                    start=left;<br>                &#125;<br>                <span class="hljs-type">char</span> d=s[left];<br>                left++;<br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>                   <br>                    <span class="hljs-keyword">if</span>(need[d]==window[d])&#123;<br>                        count--;<br>                    &#125;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len==INT_MAX?<span class="hljs-string">&quot;&quot;</span>:s.<span class="hljs-built_in">substr</span>(start,len);<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-19"><a href="#4-19" class="headerlink" title="4.19"></a>4.19</h2><h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; window;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">char</span> c=s[right];<br>            right++;<br>            window[c]++;<br>            <span class="hljs-keyword">while</span>(window[c]&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">char</span> d=s[left];<br>                left++;<br>                window[d]--;<br>            &#125;<br>            result=result&gt;right-left?result:right-left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438 找到字符串中所有字母异位词"></a>438 找到字符串中所有字母异位词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; need,window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:p) need[c]++;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(right&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">char</span> c=s[right];<br>            right++;<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>                window[c]++;<br>                <span class="hljs-keyword">if</span>(need[c]==window[c])&#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(right-left&gt;=p.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(count==need.<span class="hljs-built_in">size</span>())<br>                    result.<span class="hljs-built_in">push_back</span>(left);<br>                <span class="hljs-type">char</span> d=s[left];<br>                left++;<br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>                    <span class="hljs-keyword">if</span>(window[d]==need[d])<br>                    &#123;<br>                        count--;<br>                    &#125;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>两道题都套用了昨天的模板，太爽了，第一次做力扣这么舒服</p><h2 id="4-20"><a href="#4-20" class="headerlink" title="4.20"></a>4.20</h2><p>151.反转字符串中的单词</p><p>这道题如果不用api，单纯的用C++的方式原地反转很复杂</p><p>先整个字符串反转，再分别反转字符串里面的单词</p><p>单词间可能不止一个空格，第一个单词和最后一个单词外面可能还有空格，要对字符串进行相应的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s,<span class="hljs-number">0</span>,s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">removespace</span>(s);<br>        <span class="hljs-keyword">while</span>(j&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-built_in">reverse</span>(s,i,j<span class="hljs-number">-1</span>);<br>                i=j+<span class="hljs-number">1</span>;<br>            &#125;<br>            j++;<br>            <span class="hljs-keyword">if</span>(j==s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-built_in">reverse</span>(s,i,j);<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">return</span> s;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(start&lt;end)&#123;<br>            <span class="hljs-built_in">swap</span>(s[start],s[end]);<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removespace</span><span class="hljs-params">(string&amp; s)</span></span>&#123;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,fast=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(s[fast]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(fast&gt;<span class="hljs-number">0</span>&amp;&amp;s[fast]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;s[fast<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                fast++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> s[slow++]=s[fast++];<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span>(slow&gt;<span class="hljs-number">0</span>&amp;&amp;s[slow<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            slow--;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(slow);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-22"><a href="#4-22" class="headerlink" title="4.22"></a>4.22</h2><h3 id="59螺旋矩阵-II"><a href="#59螺旋矩阵-II" class="headerlink" title="59螺旋矩阵 II"></a>59螺旋矩阵 II</h3><p>这个属于二维数组的花式遍历部分，直接上代码，最近忙项目，代码题解这能轻微带过，希望刷题量还能保持</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> up=<span class="hljs-number">0</span>,low=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(num&lt;=n*n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(up&lt;=low)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=left;j&lt;=right;j++)&#123;<br>                    res[up][j]=num++;<br>                &#125;<br>                up++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&lt;=right)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=up;i&lt;=low;i++)&#123;<br>                    res[i][right]=num++;<br>                &#125;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(up&lt;=low)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=right;j&gt;=left;j--)&#123;<br>                    res[low][j]=num++;<br>                &#125;<br>                low--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&lt;=right)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=low;i&gt;=up;i--)&#123;<br>                    res[i][left]=num++;<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode4.10-16</title>
    <link href="/2023/04/24/Leetcode%204.10-4.16/"/>
    <url>/2023/04/24/Leetcode%204.10-4.16/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-4-10-4-16"><a href="#Leetcode-4-10-4-16" class="headerlink" title="Leetcode 4.10-4.16"></a>Leetcode 4.10-4.16</h1><h2 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h2><p>994 腐烂的橘子</p><p>广度优先搜索，多源</p><p>方法和01矩阵相似，但是不知道为什么出现了bug,代码基本完全一样但是运行报错，找问题找了2个小时还是没有找到问题</p><h2 id="4-11"><a href="#4-11" class="headerlink" title="4.11"></a>4.11</h2><p>70.爬楼梯 </p><p>dp</p><p>这两天开始接触DP相关的题目</p><h2 id="4-12"><a href="#4-12" class="headerlink" title="4.12"></a>4.12</h2><p>198 偷房子</p><p>120 三角形最小路径和</p><h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><p>今天开始按照代码随想录的顺序进行刷题，争取6月前完成1刷</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="69-平方根"><a href="#69-平方根" class="headerlink" title="69.平方根"></a>69.平方根</h4><p>不愧是经典题目，用二分法以为能过，但是没有考虑整数溢出</p><ol><li>mid前面加long long</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=x;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=(right-left)/<span class="hljs-number">2</span>+left;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid*mid==x)<br>            <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid*mid&lt;x)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid*mid&gt;x)&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.没有想到的解法，还是二分做了一个变式，然后用了除法防止溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> j = x;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;=j)&#123;<br>            <span class="hljs-type">int</span> mid = i + (j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// upper bound的形式，因为我们要找的ans要是最接近于x的最大的数，利用upper bound</span><br>            <span class="hljs-keyword">if</span> (mid &lt;= x/mid)&#123;<br>                i = mid +<span class="hljs-number">1</span>;<br>                ans = mid; <span class="hljs-comment">// 只要mid &lt;= x/mid，left左边界就会一直向右移动，ans就会一直更新（变大），直到不在满足mid &lt;= x/mid的条件为止，ans就会停止更新，永远停在满足mid&lt;=x/mid条件下面的最后一次更新，即满足ans * ans &lt;= mid的最大值。</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                j = mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="367"><a href="#367" class="headerlink" title="367"></a>367</h4><p>双指针法，自己想到的是头尾双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(nums[left] == val) &#123; <span class="hljs-comment">//left位置的元素需要移除</span><br>                <span class="hljs-comment">//将right位置的元素移到left（覆盖），right位置移除</span><br>                nums[left] = nums[right];<br>                right--;<br>            &#125;<br>            left++;<br>            <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == val) right--;<br></code></pre></td></tr></table></figure><p>题解算法，自己的头尾双指针写的有漏洞，样例不能全过</p><h2 id="4-16"><a href="#4-16" class="headerlink" title="4.16"></a>4.16</h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844 比较含退格的字符串"></a>844 比较含退格的字符串</h4><p>双指针，对双指针的理解还是不够，这道题在昨天看了评论区的一个方法后，排除了一个越界的bug后成功复现。</p><p>思路</p><p>快指针FAST去遍历，如果没有遇到’#’,将当前的值赋值给SLOW指向的值，然后快慢指针各自向前移动一步；</p><p>如果遇到了’#‘，&#x3D;&#x3D;这里非常巧妙也是关键&#x3D;&#x3D;，将slow–,也就是slow后退一格，那么本来slow指向的值会被后面的新值覆盖，相当于把这个值消除了。还有要注意SLOW&#x3D;0时按上面的逻辑消去会越界的问题，因此要单独讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow1=<span class="hljs-number">0</span>,fast1=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast1&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(s[fast1]!=<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                s[slow1++]=s[fast1++];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                fast1++;<br>                <span class="hljs-keyword">if</span>(slow1&gt;<span class="hljs-number">0</span>)&#123;<br>                 slow1--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> slow2=<span class="hljs-number">0</span>,fast2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast2&lt;t.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(t[fast2]!=<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                t[slow2++]=t[fast2++];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                fast2++;<br>                <span class="hljs-keyword">if</span>(slow2&gt;<span class="hljs-number">0</span>)&#123;<br>                slow2--;<br>                &#125;                <span class="hljs-comment">/*这里很重要，slow=0时，是没有字符给你消除的，slow--会造成</span><br><span class="hljs-comment">                 越界的问题*/</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(slow2!=slow1)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;slow1;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==t[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>双指针的题碰到过不少，但是有时候还是没有想到很好的解法，先继续往下刷，后续持续训练</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>这个点当时也是很迷，希望有所进步。</p><p>也可以说是双指针的一种（还是逃不过双指针），但是解法过程像一个窗口的移动。</p><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=INT32_MAX;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>            sum+=nums[j];<br>            <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>                length=j-i+<span class="hljs-number">1</span>;<br>                result=result&gt;length?length:result;<br>                sum=sum-nums[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result==INT32_MAX?<span class="hljs-number">0</span>:result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-API-2</title>
    <link href="/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/"/>
    <url>/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记7"><a href="#JS学习笔记7" class="headerlink" title="JS学习笔记7"></a>JS学习笔记7</h1><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>事件是编程语言中的术语，它是用来描述程序的行为或状态的，<strong>一旦行为或状态发生改变，便立即调用一个函数。</strong></p><p>例如：用户使用【鼠标点击】网页中的一个按钮、用户使用【鼠标拖拽】网页中的一张图片。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">元素对象.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;事件类型&#x27;</span>,要执行的函数)<br></code></pre></td></tr></table></figure><ol><li>事件源（DOM对象）</li><li>事件类型</li><li>回调函数</li></ol><p>老版本的  事件源.on事件&#x3D;function(){}</p><p>区别： on方式会被覆盖，addEventListener方式可绑定多次，拥有事件更多特性</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>与鼠标操作相关的事件</p><p>1.鼠标经过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;轻轻的我来了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>2.鼠标离开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListenr</span>(<span class="hljs-string">&#x27;mouseleave&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;轻轻的我走了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>keydown   键盘按下触发<br>keyup   键盘抬起触发</p><h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><p>focus  获得焦点</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;focus&#x27;</span>,<span class="hljs-built_in">function</span>()&#123;&#125;)<br></code></pre></td></tr></table></figure><p>blur 失去焦点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;blur&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)<br></code></pre></td></tr></table></figure><h4 id="文本框输入事件"><a href="#文本框输入事件" class="headerlink" title="文本框输入事件"></a>文本框输入事件</h4><p>input  </p><h3 id="x3D-x3D-事件对象-x3D-x3D"><a href="#x3D-x3D-事件对象-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;事件对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;事件对象&#x3D;&#x3D;</h3><p>这个对象里有事件触发时的相关信息</p><ul><li>可以判断用户按下哪个键</li><li>可以判断鼠标点击了哪个元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-comment">// console.log(11)</span><br>      <span class="hljs-comment">// console.log(e.key)</span><br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Enter&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我按下了回车键&#x27;</span>)<br>      &#125;<br>    &#125;)<br>回调函数的第一个参数就是事件对象<br></code></pre></td></tr></table></figure><p>trim方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">str=<span class="hljs-string">&#x27;  i  &#x27;</span><br>str.<span class="hljs-title function_">trim</span>();<br>去除字符串两侧的空格<br></code></pre></td></tr></table></figure><h3 id="x3D-x3D-环境对象-x3D-x3D"><a href="#x3D-x3D-环境对象-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;环境对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>环境对象</strong>&#x3D;&#x3D;</h3><p>函数内部特殊的变量<strong>this</strong>，代表当前函数运行时所处的环境</p><p>弄清楚<strong>this</strong>的指向，可以让代码更简洁</p><p>普通函数里this指向window</p><ul><li>函数的调用方式不同,this指代的对象也不同</li><li>【谁调用，this就是谁】是判断this指向的初略原则</li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>如果将函数A作为参数传递给函数B时，我们称函数A为回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是回调函数...&#x27;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 调用定时器</span><br>  <span class="hljs-built_in">setInterval</span>(fn, <span class="hljs-number">1000</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS-API-1</title>
    <link href="/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06(API)/"/>
    <url>/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06(API)/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记6-API-DOM"><a href="#JS学习笔记6-API-DOM" class="headerlink" title="JS学习笔记6(API-DOM)"></a>JS学习笔记6(API-DOM)</h1><p>前面基础部分笔记较简略，这里开始做细致的记录</p><p>&#x3D;&#x3D;（DOM-获取元素）&#x3D;&#x3D;</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br><br>array.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;d&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>不会报错，因为地址没有修改，改变的是地址指向的内容。</p><p>声明变量优先给const,后续需要修改再改为let</p><p>&#x3D;&#x3D;建议数组和对象使用const声明&#x3D;&#x3D;</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ECMAScript 简称 ES 它提供了一套语言标准规范，如变量、数据类型、表达式、语句、函数等语法规则都是由 ECMAScript 规定的。浏览器将 ECMAScript 大部分的规范加以实现，并且在此基础上又扩展一些实用的功能，这些被扩展出来的内容我们称为 Web APIs。</p><p><img src="/image/js-6-1.jpg" alt="6-1"></p><ul><li>使用JS去操作HTML和浏览器</li><li>分类：DOM(文档对象模型)和BOM(浏览器对象模型)</li></ul><p>DOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。</p><p>简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。</p><h3 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h3><ul><li>将HTML文档以树状结构直观的表现出来，我们称之为文档树或DOM树</li><li>作用：直观的体现了标签与标签之间的关系</li></ul><h3 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h3><p>浏览器根据HTML标签生成的JS对象</p><ul><li>文档树的每一个节点都是一个DOM对象</li></ul><p>核心思想：把网页内容当作对象处理</p><p><strong>&#x3D;&#x3D;document是DOM里最大的对象&#x3D;&#x3D;</strong></p><p><code>document</code> 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，<code>document</code> 是学习 DOM 的核心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// document 是内置的对象</span><br>  <span class="hljs-comment">// console.log(typeof document);</span><br><br>  <span class="hljs-comment">// 1. 通过 document 获取根节点</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>); <span class="hljs-comment">// 对应 html 标签</span><br><br>  <span class="hljs-comment">// 2. 通过 document 节取 body 节点</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>); <span class="hljs-comment">// 对应 body 标签</span><br><br>  <span class="hljs-comment">// 3. 通过 document.write 方法向网页输出内容</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="获取DOM对象"><a href="#获取DOM对象" class="headerlink" title="获取DOM对象"></a>获取DOM对象</h2><p>（根据CSS选择器的方式）</p><h3 id="选中匹配的第一个元素"><a href="#选中匹配的第一个元素" class="headerlink" title="选中匹配的第一个元素"></a>选中匹配的第一个元素</h3><p>querySelsecor() 参数包含一个或多个有效的字符串</p><p>返回选择器匹配的第一个元素，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>)  <span class="hljs-comment">// 获取第一个p元素</span><br>  <span class="hljs-comment">/*引号里面是选择器*/</span><br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="选择匹配的元素集合"><a href="#选择匹配的元素集合" class="headerlink" title="选择匹配的元素集合"></a>选择匹配的元素集合</h3><p>querySelectAll()  </p><p>返回选择器匹配的对象集合，伪数组（有长度有索引，没有pop,push等方法）</p><ul><li>通过for遍历得到每一个对象</li></ul><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p><img src="/image/js-6-2.jpg"></p><h2 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h2><h3 id="操作标签内容"><a href="#操作标签内容" class="headerlink" title="操作标签内容"></a>操作标签内容</h3><ol><li><p>对象.innerText</p><p>只识别文本，不解析标签</p></li><li><p>对象.innerHtml</p><p> 能识别文本，解析标签</p></li></ol><h3 id="操作常用属性"><a href="#操作常用属性" class="headerlink" title="操作常用属性"></a>操作常用属性</h3><p>直接能过属性名修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 1. 获取 img 对应的 DOM 元素</span><br>  <span class="hljs-keyword">const</span> pic = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.pic&#x27;</span>)<br><span class="hljs-comment">// 2. 修改属性</span><br>  pic.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;./images/lion.webp&#x27;</span><br>  pic.<span class="hljs-property">width</span>=<span class="hljs-string">&#x27;400px&#x27;</span><br>  pic.<span class="hljs-property">alt</span> = <span class="hljs-string">&#x27;图片不见了...&#x27;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="操作元素样式属性"><a href="#操作元素样式属性" class="headerlink" title="操作元素样式属性"></a>操作元素样式属性</h3><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p>应用【修改样式】，通过修改行内样式 <code>style</code> 属性，实现对样式的动态修改。</p><p>通过元素节点获得的 <code>style</code> 属性本身的数据类型也是对象，如 <code>box.style.color</code>、<code>box.style.width</code> 分别用来获取元素节点 CSS 样式的 <code>color</code> 和 <code>width</code> 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;练习 - 修改样式&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt;<br>  &lt;script&gt;<br>    // 获取 DOM 节点<br>    const box = document.querySelector(&#x27;.intro&#x27;)<br>    box.style.color = &#x27;red&#x27;<br>    box.style.width = &#x27;300px&#x27;<br>    // css 属性的 - 连接符与 JavaScript 的 减运算符<br>    // 冲突，所以要改成驼峰法<br>    box.style.backgroundColor = &#x27;pink&#x27;<br>  &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>(注意属性名有-，用小驼峰命名)<br></code></pre></td></tr></table></figure><p>修改样式比较少的情况下有优势</p><p>生成的是行内样式表，权重比较高</p><h4 id="className"><a href="#className" class="headerlink" title="className"></a>className</h4><p>如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;练习 - 修改样式&lt;/title&gt;<br>    &lt;style&gt;<br>        .pink &#123;<br>            background: pink;<br>            color: hotpink;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt;<br>  &lt;script&gt;<br>    // 获取 DOM 节点<br>    const box = document.querySelector(&#x27;.box&#x27;)<br>    box.className = &#x27;box pink&#x27;<br>  &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>1.由于class是关键字, 所以使用className去代替</p><p> 2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名’box pink’</p></blockquote><h4 id="x3D-x3D-classList-x3D-x3D"><a href="#x3D-x3D-classList-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;classList&#x3D;&#x3D;"></a>&#x3D;&#x3D;classList&#x3D;&#x3D;</h4><p>为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>        div &#123;<br>            width: 200px;<br>            height: 200px;<br>            background-color: pink;<br>        &#125;<br><br>        .active &#123;<br>            width: 300px;<br>            height: 300px;<br>            background-color: hotpink;<br>            margin-left: 100px;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        // 1.获取元素<br>        // let box = document.querySelector(&#x27;css选择器&#x27;)<br>        let box = document.querySelector(&#x27;div&#x27;)<br>        // add是个方法 添加  追加   类名不加点，并且是字符串<br>        // box.classList.add(&#x27;active&#x27;)<br>        // remove() 移除 类<br>        // box.classList.remove(&#x27;one&#x27;)<br>        // 切换类   原来有这个类就删除，没有就加上<br>        box.classList.toggle(&#x27;one&#x27;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="操作表单元素属性"><a href="#操作表单元素属性" class="headerlink" title="操作表单元素属性"></a>操作表单元素属性</h3><p>表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框</p><p>正常的有属性有取值的跟其他的标签属性没有任何区别</p><p> (得到表单的值用value)</p><p>获取:DOM对象.属性名</p><p>设置:DOM对象.属性名&#x3D; 新值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br><br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;input type=&quot;text&quot; value=&quot;请输入&quot;&gt;<br>    &lt;button disabled&gt;按钮&lt;/button&gt;<br>    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt;<br>    &lt;script&gt;<br>        // 1. 获取元素<br>        let input = document.querySelector(&#x27;input&#x27;)<br>        // 2. 取值或者设置值  得到input里面的值可以用 value<br>        // console.log(input.value)<br>        input.value = &#x27;小米手机&#x27;<br>        input.type = &#x27;password&#x27;<br><br>        // 2. 启用按钮<br>        let btn = document.querySelector(&#x27;button&#x27;)<br>        // disabled 不可用   =  false  这样可以让按钮启用<br>        btn.disabled = false<br>        // 3. 勾选复选框<br>        let checkbox = document.querySelector(&#x27;.agree&#x27;)<br>        checkbox.checked = true<br>    checkbox.checked=&#x27;true&#x27; (也能选中，有默认的隐式转换，除了空字符串是false)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>自定义属性：</p><p>在html5中推出来了专门的data-自定义属性  </p><p>在标签上一律以data-开头</p><p>在DOM对象上一律以dataset对象方式获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br><br>&lt;/head&gt;<br><br>&lt;body&gt;<br>   &lt;div data-id=&quot;1&quot;&gt; 自定义属性 &lt;/div&gt;<br>    &lt;script&gt;<br>        // 1. 获取元素<br>        let div = document.querySelector(&#x27;div&#x27;)<br>        // 2. 获取自定义属性值<br>         console.log(div.dataset.id)<br>      <br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="定时器-间歇函数"><a href="#定时器-间歇函数" class="headerlink" title="定时器-间歇函数"></a>定时器-间歇函数</h2><p>  <code>setInterval</code> 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(函数，间隔时间);<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<span class="hljs-number">1000</span>);单位是ms<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>  <br>&#125;<br><span class="hljs-built_in">setInterval</span>(fn,<span class="hljs-number">1000</span>)  （函数名不需要加括号）<br></code></pre></td></tr></table></figure><p>在某些情况下需要关闭</p><p>let n&#x3D;setInterval</p><p>clearInterval(n)</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在努力了</title>
    <link href="/2023/04/21/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    <url>/2023/04/21/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="先扯点有的没的"><a href="#先扯点有的没的" class="headerlink" title="先扯点有的没的"></a>先扯点有的没的</h2><p>三月份面临考研和就业的抉择，在纠结之后最终还是选择了就业。<br>在过去三年，计算机带给我的更多是痛苦大于喜悦，搞学术写论文目前并没有让我找到兴趣点和获得收获感，因此我如果随大流考研升学，在我看来是一种逃避，也是一种负担；过去的摆烂导致了平庸的GPA和惨淡的竞赛经历，更别提学术论文，因此考研考梦校也是一种幻想，复试那不是必无。</p><p>所以还是选择了就业。三月份投了一堆实习，一个面试也没有，确实，前端基础都没学完，力扣一年没碰了，c艹都忘得差不多了，有面试就怪了。加上整体就业环境的影响，互联网遍地黄金的时代过去了，’’前端已死’’传言盛行，难啊。不过学前端至少让我得到一些获得感，无所谓哥们继续学，<strong>种一棵树，最好的时间是十年前，其次是现在</strong>，希望秋招顺利。</p><p>​2023.4.13</p><p>拿到了一个小厂的实习，但是说好了六月份去，由于小厂口头承诺没有邮件，中间这段时间不知道会不会毁约，近期还是在寻找机会；JS进度这周差不多可以结束，开始系统接触框架；恒生的项目还没有进入开发的周期，但是开发压力很大，所以五月前必须接触前后端结合，后端用Java的项目了；算法这边还是必须得有保证，力扣5月前希望可以破百。由于前期的摆烂，整个计算机大方面的综合能力还是太弱，恒生这边的项目尽全力去做，争取有秋招的终面offer；前端技术栈和算法能力综合的去训练，如果六月去了实习，实习内容的学习和秋招必须兼顾，倘若去不了，必须暑期找一下开源项目同时全力争对秋招。所做的一切，最终还是为了秋招，大厂不抱希望，目标是秋招能进一家中厂，有点想去恒生，做的东西我挺感兴趣。</p><p>​2023.4.21</p><p>小厂的实习毁约了，不过也在意料之中了。力扣倒是破百了，前端慢慢开始有感觉了，这二十天的效率比之前提升了，还是比较满意，下面这段时间好好地把项目做完，希望后端的兄弟给力，我们能把这个项目完整的做好，另外再找找实习的机会，还是希望能去实习，继续这样前端+算法学习的节奏，争取效率进一步提升。</p><p>​         2023.5.11</p>]]></content>
    
    
    <categories>
      
      <category>一点心路历程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础语法4</title>
    <link href="/2023/04/21/JS%E7%AC%94%E8%AE%B04/"/>
    <url>/2023/04/21/JS%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h1 id="JS笔记4"><a href="#JS笔记4" class="headerlink" title="JS笔记4"></a>JS笔记4</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明和调用"><a href="#声明和调用" class="headerlink" title="声明和调用"></a>声明和调用</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">声明（定义）一个完整函数包括关键字、函数名、形式参数、函数体、返回值<span class="hljs-number">5</span>个部分<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">形参</span>)&#123;<br>  <br>  <span class="hljs-keyword">return</span> xx<br>&#125;<br></code></pre></td></tr></table></figure><p>命名规范：</p><ol><li>和变量命名基本一致</li><li>小驼峰</li><li>前缀尽量为动词</li></ol><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>声明（定义）的函数必须调用才会真正被执行，使用 <code>()</code> 调用函数。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>通过向函数传递参数，可以让函数更加灵活多变，参数可以理解成是一个变量。</p><p>声明（定义）一个功能为打招呼的函数</p><ul><li>传入数据列表</li><li>声明这个函数需要传入几个数据</li><li>多个数据用逗号隔开</li></ul><p>形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）</p><p>实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）</p><p>形参可以理解为是在这个函数内声明的变量（比如 num1 &#x3D; 10）实参可以理解为是给这个变量赋值</p><p>开发中尽量保持形参和实参个数一致</p><p>（如果声明了形参但是实际调用时没有给实参，参数为undefined，可以改进一下</p><p>function name(x&#x3D;0,y&#x3D;0）{</p><p>}</p><p>)</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数的本质是封装（包裹），函数体内的逻辑执行完毕后，函数外部如何获得函数内部的执行结果呢？要想获得函数内部逻辑的执行结果，需要通过 <code>return</code> 这个关键字，将内部执行结果传递到函数外部，这个被传递到外部的结果就是返回值。</p><ol><li>在函数体中使用return 关键字能将内部的执行结果交给函数外部使用</li><li>函数内部只能出现1 次 return，并且 return 下一行代码不会再被执行，所以return 后面的数据不要换行写</li><li>return会立即结束当前函数</li><li>函数可以没有return，这种情况默认返回值为 undefined</li></ol><p>要返回多个值</p><p>可以直接返回一个数组</p><p>一些注意点</p><ol><li><p>函数名相同，后面定义的覆盖前面的</p></li><li><p>参数不匹配： </p><ol><li>实参多于形参，多的实参剩下，不参与运算(函数内部有一个arguements)</li><li>形参过多，会自动填上undefined;</li></ol><p>​</p></li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</p><p>作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突</p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件</p><p>处于全局作用域内的变量，称为全局变量</p><h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</p><p>处于局部作用域内的变量称为局部变量</p><blockquote><p>如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐</p><p>但是有一种情况，函数内部的形参可以看做是局部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>  num=<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-title function_">fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<span class="hljs-comment">//这种情况把num当成了全局变量</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x,y</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); 报错因为形参可以看作局部变量，不能在函数外部使用<br></code></pre></td></tr></table></figure></blockquote><h4 id="x3D-x3D-变量访问原则-x3D-x3D"><a href="#x3D-x3D-变量访问原则-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;变量访问原则&#x3D;&#x3D;"></a>&#x3D;&#x3D;变量访问原则&#x3D;&#x3D;</h4><p>能够访问到的情况下先局部，访问不到时逐层向上寻找。</p><h3 id="x3D-x3D-匿名函数-x3D-x3D"><a href="#x3D-x3D-匿名函数-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;匿名函数&#x3D;&#x3D;"></a>&#x3D;&#x3D;匿名函数&#x3D;&#x3D;</h3><p>function(){}</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fn=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>具名函数的调用可以写到任何位置，</p><p>函数表达式只能先声明后使用</p><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><p>（&#x3D;&#x3D;必须加分号&#x3D;&#x3D;）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; xxx  &#125;)();<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;xxxx&#125;());<br></code></pre></td></tr></table></figure><p>可以用来防止变量污染</p><h3 id="逻辑中断"><a href="#逻辑中断" class="headerlink" title="逻辑中断"></a>逻辑中断</h3><p>短路：只存在于&amp;&amp;和||中</p><p>&amp;&amp; 一假则假，后面的语句不执行，都真，以后面的真为准</p><p>|| 一真则真，后面的语句不执行</p><p>​     都假，以后面的假为准</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;pink&#x27;</span>))    <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>))        <span class="hljs-literal">false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>))         <span class="hljs-literal">false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">90</span>))         <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">-1</span>))         <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>))   <span class="hljs-literal">false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>))      <span class="hljs-literal">false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>))    <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>if ()里面会有隐式转换</p><p>null&amp;&amp;1 值是0            null短路，后面不执行，值为null  作为表达式的值不会有转换，进行逻辑判断时有隐式转换</p><p>undefined&amp;&amp;1值是undefined</p><hr><p><img src="/image/js-2.jpg"></p><p>null+1&#x3D;1</p><p>undefined+1&#x3D;NaN+1&#x3D;NaN</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础语法5</title>
    <link href="/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/"/>
    <url>/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记5"><a href="#JS学习笔记5" class="headerlink" title="JS学习笔记5"></a>JS学习笔记5</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote><p>对象是 JavaScript 数据类型的一种，之前已经学习了数值类型、字符串类型、布尔类型、undefined。对象数据类型可以被理解成是一种数据集合。它由属性和方法两部分构成。</p></blockquote><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 声明对象类型变量，使用一对花括号</span><br><span class="hljs-comment">// user 便是一个对象了，目前它是一个空对象</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。</p><ol><li>属性都是成 对出现的，包括属性名和值，它们之间使用英文 <code>:</code> 分隔</li><li>多个属性之间使用英文 <code>,</code> 分隔</li><li>属性就是依附在对象上的变量</li><li>属性名可以使用 <code>&quot;&quot;</code> 或 <code>&#39;&#39;</code>，一般情况下省略，除非名称遇到特殊符号如空格、中横线等</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 通过对象描述一个人的数据信息</span><br>  <span class="hljs-comment">// person 是一个对象，它包含了一个属性 name</span><br>  <span class="hljs-comment">// 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔</span><br>  <span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-comment">// 描述人的姓名</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// 描述人的年龄</span><br>    <span class="hljs-attr">stature</span>: <span class="hljs-number">185</span>, <span class="hljs-comment">// 描述人的身高</span><br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-comment">// 描述人的性别</span><br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>声明对象，并添加了若干属性后，可以使用 <code>.</code> 或 <code>[]</code> 获得对象中属性对应的值(访问)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&#x27;stature&#x27;</span>]) <span class="hljs-comment">// 结果为 185</span><br>因为有的属性名加了引号，以字符串的形式<span class="hljs-string">&#x27;name-product&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="增加和修改"><a href="#增加和修改" class="headerlink" title="增加和修改"></a>增加和修改</h4><p>对象.属性&#x3D;新值</p><p>对象.新属性&#x3D;值</p><p>（没有就是新增，有就是修改）</p><p>注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>delete 对象.属性</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。</p><ol><li>方法是由方法名和函数两部分构成，它们之间使用 : 分隔</li><li>多个属性之间使用英文 <code>,</code> 分隔</li><li>方法是依附在对象中的函数</li><li>方法名可以使用 <code>&quot;&quot;</code> 或 <code>&#39;&#39;</code>，一般情况下省略，除非名称遇到特殊符号如空格、中横线等</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj=&#123;<br>  uname=<span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">sum</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <br>&#125;，<br>  type=<span class="hljs-string">&#x27;&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>方法也可以根据属性类型的方式进行添加</p><h3 id="x3D-x3D-遍历对象-x3D-x3D"><a href="#x3D-x3D-遍历对象-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;遍历对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;遍历对象&#x3D;&#x3D;</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[key])<br>&#125;<br><span class="hljs-keyword">typeof</span> key 返回值是字符串型<br>所以 obj[key]相当于用了第二种访问属性的方式<br></code></pre></td></tr></table></figure><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>console,document,Math</p><h3 id="简单和复杂数据类型"><a href="#简单和复杂数据类型" class="headerlink" title="简单和复杂数据类型"></a>简单和复杂数据类型</h3><p>简单数据类型放栈里，复杂数据类型内容在堆里。定义的变量是放在栈里指向复杂数据类型内容的指针</p><p><img src="/image/js-5-1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础语法3</title>
    <link href="/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记3"><a href="#JS学习笔记3" class="headerlink" title="JS学习笔记3"></a>JS学习笔记3</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在 JavaScript 中并不是新的数据类型，它属于对象类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 1. 语法，使用 [] 来定义一个空数组</span><br>  <span class="hljs-comment">// 定义一个空数组，然后赋值给变量 classes</span><br>  <span class="hljs-comment">// let classes = [];</span><br><br>  <span class="hljs-comment">// 2. 定义非空数组</span><br>  <span class="hljs-keyword">let</span> classes = [<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;小刚&#x27;</span>, <span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;小丽&#x27;</span>, <span class="hljs-string">&#x27;小米&#x27;</span>]<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>undefined+数字是NaN</p><p>数组做为数据的集合，它的单元值可以是任意数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 6. 数组单值类型可以是任意数据类型</span><br><br>  <span class="hljs-comment">// a) 数组单元值的类型为字符类型</span><br>  <span class="hljs-keyword">let</span> list = [<span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>]<br>  <span class="hljs-comment">// b) 数组单元值的类型为数值类型</span><br>  <span class="hljs-keyword">let</span> scores = [<span class="hljs-number">78</span>, <span class="hljs-number">84</span>, <span class="hljs-number">70</span>, <span class="hljs-number">62</span>, <span class="hljs-number">75</span>]<br>  <span class="hljs-comment">// c) 混合多种类型</span><br>  <span class="hljs-keyword">let</span> mixin = [<span class="hljs-literal">true</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="操作数组的方法（增删改查）"><a href="#操作数组的方法（增删改查）" class="headerlink" title="操作数组的方法（增删改查）"></a>操作数组的方法（增删改查）</h3><p>数组做为对象数据类型，不但有 <code>length</code> 属性可以使用，还提供了许多方法：</p><ol><li>push 动态向数组的尾部添加一个单元或多个元素，返回新的长度</li><li>unshift 动态向数组头部添加一个单元,返回新的长度</li><li>pop 删除最后一个单元</li><li>shift 删除第一个单元</li><li>splice 动态删除任意单元</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>  <span class="hljs-comment">// 定义一个数组</span><br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;javascript&#x27;</span>]<br><br>  <span class="hljs-comment">// 1. push 动态向数组的尾部添加一个单元</span><br>  arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Nodejs&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br>  arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Vue&#x27;</span>)<br><br>  <span class="hljs-comment">// 2. unshit 动态向数组头部添加一个单元</span><br>  arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&#x27;VS Code&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br><br>  <span class="hljs-comment">// 3. splice 动态删除任意单元</span><br>  arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 从索引值为2的位置开始删除1个单元,如果没有第二个参数，则删除后面所有的元素</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br><br>  <span class="hljs-comment">// 4. pop 删除最后一个单元</span><br>  arr.<span class="hljs-title function_">pop</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br><br>  <span class="hljs-comment">// 5. shift 删除第一个单元</span><br>  arr.<span class="hljs-title function_">shift</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">sort</span>()<br>里面可以写函数<br>array.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>  <span class="hljs-keyword">return</span> b-a;<br>&#125;)<br>返回增序<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础语法2</title>
    <link href="/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记2"><a href="#JS学习笔记2" class="headerlink" title="JS学习笔记2"></a>JS学习笔记2</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>一元运算符（自增++，自减–，注意前置和后置的小区别，和别的语言相同）</p><p>算术运算符 </p><p>赋值运算符</p><p>比较运算符（与别的语言略有不同）</p><p>逻辑运算符</p><p>运算符优先级</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">注意一个点；<br>数字与字符串比较时，字符串会转换成数字字符,如果字符串为非数字，这个字符串会转换成<span class="hljs-literal">NaN</span>;比较结果均为<span class="hljs-literal">FALSE</span><br><br>如 (<span class="hljs-number">9</span>&lt;<span class="hljs-string">&#x27;10&#x27;</span>) <span class="hljs-literal">true</span><br>   (<span class="hljs-number">9</span>&lt;<span class="hljs-string">&#x27;asd&#x27;</span>) <span class="hljs-literal">false</span><br>   (<span class="hljs-number">9</span>&gt;<span class="hljs-string">&#x27;asd&#x27;</span>) <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h2><h3 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h3><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>分支语句包含：</p><h4 id="if分支语句（重点）"><a href="#if分支语句（重点）" class="headerlink" title="if分支语句（重点）"></a>if分支语句（重点）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 单分支语句</span><br>    <span class="hljs-comment">// if (false) &#123;</span><br>    <span class="hljs-comment">//   console.log(&#x27;执行语句&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// if (3 &gt; 5) &#123;</span><br>    <span class="hljs-comment">//   console.log(&#x27;执行语句&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// if (2 === &#x27;2&#x27;) &#123;</span><br>    <span class="hljs-comment">//   console.log(&#x27;执行语句&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//  1. 除了0 所有的数字都为真</span><br>    <span class="hljs-comment">//   if (0) &#123;</span><br>    <span class="hljs-comment">//     console.log(&#x27;执行语句&#x27;)</span><br>    <span class="hljs-comment">//   &#125;</span><br>    <span class="hljs-comment">// 2.除了 &#x27;&#x27; 所有的字符串都为真 true</span><br>    <span class="hljs-comment">// if (&#x27;pink老师&#x27;) &#123;</span><br>    <span class="hljs-comment">//   console.log(&#x27;执行语句&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// if (&#x27;&#x27;) &#123;</span><br>    <span class="hljs-comment">//   console.log(&#x27;执行语句&#x27;)</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// // if (&#x27;&#x27;) console.log(&#x27;执行语句&#x27;)</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">条件 ? 表达式1 ： 表达式2<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 三元运算符（三元表达式）</span><br><span class="hljs-comment">// 1. 语法格式</span><br><span class="hljs-comment">// 条件 ? 表达式1 : 表达式2 </span><br><br><span class="hljs-comment">// 2. 执行过程 </span><br><span class="hljs-comment">// 2.1 如果条件为真，则执行表达式1</span><br><span class="hljs-comment">// 2.2 如果条件为假，则执行表达式2</span><br><br><span class="hljs-comment">// 3. 验证</span><br><span class="hljs-comment">// 5 &gt; 3 ? &#x27;真的&#x27; : &#x27;假的&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span> &lt; <span class="hljs-number">3</span> ? <span class="hljs-string">&#x27;真的&#x27;</span> : <span class="hljs-string">&#x27;假的&#x27;</span>)<br><br><span class="hljs-comment">// let age = 18 </span><br><span class="hljs-comment">// age = age + 1</span><br><span class="hljs-comment">//  age++</span><br><br><span class="hljs-comment">// 1. 用户输入 </span><br><span class="hljs-keyword">let</span> num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请您输入一个数字:&#x27;</span>)<br><span class="hljs-comment">// 2. 判断输出- 小于10才补0</span><br><span class="hljs-comment">// num = num &lt; 10 ? 0 + num : num</span><br>num = num &gt;= <span class="hljs-number">10</span> ? num : <span class="hljs-number">0</span> + num<br><span class="hljs-title function_">alert</span>(num)<br></code></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>使用场景： 适合于有多个条件的时候，也属于分支语句，大部分情况下和 if多分支语句 功能相同</p><p>注意：</p><ol><li><p>switch case语句一般用于等值判断, if适合于区间判断</p></li><li><p>switchcase一般需要配合break关键字使用 没有break会造成case穿透</p></li><li><p>if 多分支语句开发要比switch更重要，使用也更多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">x</span>:<br>    语句（可以多个语句，无需用一个大括号包围）<br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-attr">y</span>:<br>    语句<br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>    语句<br>  &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`number<span class="hljs-subst">$&#123;i&#125;</span>&lt;br&gt;`</span>);<br>            i++;<br>        &#125;<br>&lt;<span class="hljs-regexp">/script&gt; /</span><span class="hljs-regexp">/&lt;br&gt;标签放在反引号里面，参考document.write()的用法</span><br></code></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">注意<span class="hljs-keyword">for</span>循环语句的执行顺序<br> <span class="hljs-keyword">for</span>(①; ②; ③)&#123;<br><br> ④<br><br>&#125;<br><br>一、执行①<br><br>二、执行②，如果判断结果为<span class="hljs-literal">true</span>,则执行三，如果判断结果为<span class="hljs-literal">false</span>,则执行五<br><br>三、执行 ④<br><br>四、执行③，然后重复执行二<br><br>五、退出循环<br>对于<span class="hljs-keyword">for</span>循环内部的<span class="hljs-keyword">continue</span>,只跳过大括号内此轮循环语句的执行，不影响<span class="hljs-number">3</span>，即不影响i++;与<span class="hljs-keyword">while</span>不同，<span class="hljs-keyword">while</span>要注意i++的语句先后<br></code></pre></td></tr></table></figure><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>1.while(true) 来构造“无限”循环，需要使用break退出循环。（常用）</p><p>2.for(;;) 也可以来构造“无限”循环，同样需要使用break退出循环。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础语法1</title>
    <link href="/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2023/04/21/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="JS学习笔记1"><a href="#JS学习笔记1" class="headerlink" title="JS学习笔记1"></a>JS学习笔记1</h1><h1 id="（基础语法部分笔记简略）"><a href="#（基础语法部分笔记简略）" class="headerlink" title="（基础语法部分笔记简略）"></a>（基础语法部分笔记简略）</h1><h2 id="js输入输出语法"><a href="#js输入输出语法" class="headerlink" title="js输入输出语法"></a>js输入输出语法</h2><h3 id="输出语法"><a href="#输出语法" class="headerlink" title="输出语法"></a>输出语法</h3><ol><li><p>document.write() 页面中打印</p><p>参数解析：</p><p>（1）.expN：可以是一个或者多个参数，如果是多个参数，那么按照顺序写入文档。(如果写入多个参数的话，这些参数会自动换行显示)</p><p>  (2)这里的参数可以是变量，也可以是函数体、函数自执行体，数字等等，也可以进行一些简单的运算</p><p>  (3)参数支持标签属性，写入的时候会按照html进行解析，但是需要用字符串的形式(常用的标签属性就是换行符 <br> &#x3D;&#x3D;Javascript 中只能在 HTML 输出流中使用 document.write，在文档已加载后使用它（比如在函数中），会覆盖整个文档。&#x3D;&#x3D;</p></li><li><p>console.log()  控制台中打印</p><p><strong>参数：</strong>var：变量，可以是数组类型，对象类型，或者字符串类型等。</p></li><li><p>alert() 弹窗</p></li></ol><h3 id="输入语法"><a href="#输入语法" class="headerlink" title="输入语法"></a>输入语法</h3><p>prompt()</p><h2 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h2><ol><li>html文档流顺序</li><li>alert()和prompt( )会跳过页面渲染先被执行</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>let+变量名</p><p> var 已经淘汰</p><p>let不允许重复声明　</p><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p><ol><li>只能是字母、数字、下划线、&#x3D;&#x3D;$&#x3D;&#x3D;，且不能能数字开头</li><li>字母区分大小写，如 Age 和 age 是不同的变量</li><li>JavaScript 内部已占用于单词（关键字或保留字）不允许使用</li><li>尽量保证变量具有一定的语义，见字知义</li></ol><p>小驼峰命名，第一个单词首字母小写，后面单词首字母大写。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>通过 typeof 关键字检测数据类型</p><p>基本数据类型+引用数据类型（object）</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>数字</p><p>字符串</p><p>布尔类型</p><p>undefined(声明变量未赋值)</p><p>null（这个变量将来是对象但是还没有值）</p><hr><p>模板字符串</p><ul><li>拼接字符串和变量</li><li>语法  <ul><li>反引号包含数据</li><li>${变量名}</li></ul></li></ul><p>隐式转换</p><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。</p><p><img src="/image/js-1.jpg"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 基础 - 隐式转换<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">13</span> <span class="hljs-comment">// 数值</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num2 = <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 字符串</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 结果为 132</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 原因是将数值 num 转换成了字符串，相当于 &#x27;13&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 然后 + 将两个字符串拼接到了一起</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num + num2)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 结果为 11</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 原因是将字符串 num2 转换成了数值，相当于 2</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 然后数值 13 减去 数值 2</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num - num2)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一个数字&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请再输入一个数字&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(a + b);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示转换</p><p>Number() </p><p>通过 <code>Number</code> 显示转换成数值类型，当转换失败时结果为 <code>NaN</code>（Not a Number）即不是一个数字</p><p>parseInt()</p><p>parseFloat()</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记2</title>
    <link href="/2023/04/20/css%E7%AC%94%E8%AE%B02/"/>
    <url>/2023/04/20/css%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="css笔记2"><a href="#css笔记2" class="headerlink" title="css笔记2"></a>css笔记2</h1><h2 id="1-Emmet语法"><a href="#1-Emmet语法" class="headerlink" title="1.Emmet语法"></a>1.Emmet语法</h2><p>提高Html&#x2F;css编写速度</p><h3 id="快速生成html语法"><a href="#快速生成html语法" class="headerlink" title="快速生成html语法"></a>快速生成html语法</h3><ol><li><p>标签名+Tab直接生成标签</p></li><li><p>生成多个相同标签  标签名<code>*</code>n  div*3    </p></li><li><p>父子级别关系的标签，用&gt; , ul&gt;li</p></li><li><p>兄弟级别的标签，用+， div+p</p></li><li><p>点+类名，生成带类名的标签；#+id名，生成带id名的标签</p></li><li><p>.demo$*5,生成五个按序排列的div</p></li><li><p>div{内容} ，生成的标签里面显示内容</p></li></ol><hr><h3 id="快速生成css语法"><a href="#快速生成css语法" class="headerlink" title="快速生成css语法"></a>快速生成css语法</h3><ol><li>用属性的缩写可以直接生成属性</li></ol><hr><h2 id="2-快速格式化代码"><a href="#2-快速格式化代码" class="headerlink" title="2.快速格式化代码"></a>2.快速格式化代码</h2><p>vs里面通过右键找到即可</p><p>也可以修改vs的设置，再保存时自动格式化代码</p><hr><h2 id="3-复合选择器（接上一个笔记）"><a href="#3-复合选择器（接上一个笔记）" class="headerlink" title="3.复合选择器（接上一个笔记）"></a>3.复合选择器（接上一个笔记）</h2><p>由两个或多个基本选择器组合形成的</p><h3 id="x3D-x3D-后代选择器-x3D-x3D"><a href="#x3D-x3D-后代选择器-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;后代选择器&#x3D;&#x3D;"></a>&#x3D;&#x3D;后代选择器&#x3D;&#x3D;</h3><p>​后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">元素1 元素2 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  内容</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>元素1 和 元素2 中间用空格隔开</li><li>元素1 是父级，元素2 是子级，最终选择的是元素2（&#x3D;&#x3D;元素1和元素2不能是同级的，元素1和元素2不能选择同一个标签&#x3D;&#x3D;）</li><li>元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可</li><li>元素1 和 元素2 可以是任意基础选择器</li></ul><hr><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><p>子选择器只能选择作为某元素的&#x3D;&#x3D;最近&#x3D;&#x3D;一级子元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav</span>&gt;<span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>元素1 和 元素2 中间用 大于号 隔开</li><li>元素1 是父级，元素2 是子级，最终选择的是元素2</li><li>元素2 必须是亲儿子，其孙子、重孙之类都不归他管. 你也可以叫他 亲儿子选择器</li></ul><hr><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>并集选择器可以选择多组标签，同时为他们定义相同的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">p</span> &#123;<br>  样式声明<br>&#125;<br><span class="hljs-selector-tag">div</span>和<span class="hljs-selector-tag">p</span>都改了同一个样式<br></code></pre></td></tr></table></figure><p>任何形式的选择器都可以作为并集选择器的一部分</p><p>并集选择器喜欢竖着写，最后一个选择器不需要加“,”</p><hr><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p> 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">用冒号表示   :<span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><h4 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>没有点击过的(访问过的)链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>点击过的(访问过的)链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>鼠标经过的那个链接<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>鼠标正在按下还没有弹起鼠标的那个链接<br><br></code></pre></td></tr></table></figure><p>为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active</p><hr><h4 id="focus伪类选择器"><a href="#focus伪类选择器" class="headerlink" title="focus伪类选择器"></a>focus伪类选择器</h4><p>用于选取获得焦点的表单元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">一般&lt;<span class="hljs-selector-tag">input</span>&gt;才能获取焦点(光标)<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-x3D-x3D-css元素显示模式-x3D-x3D"><a href="#4-x3D-x3D-css元素显示模式-x3D-x3D" class="headerlink" title="4.&#x3D;&#x3D;css元素显示模式&#x3D;&#x3D;"></a>4.&#x3D;&#x3D;css元素显示模式&#x3D;&#x3D;</h2><p>元素显示模式就是元素（标签）以什么方式显示。</p><p>html元素一般分为块元素和行内元素两种类型。</p><hr><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>常见的块元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>~<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;特点&#x3D;&#x3D;</p><ul><li>比较霸道，自己独占一行。</li></ul><ul><li>高度，宽度、外边距以及内边距都可以控制。</li><li>宽度默认是容器（父级宽度）的100%。如div没有指定，宽度与上级body一样</li><li>是一个容器及盒子，里面可以放行内或者块级元素。</li></ul><p>&#x3D;&#x3D;文字类的元素内不能使用块级元素&#x3D;&#x3D;</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">p,</span>h等标签内不能放块元素<br></code></pre></td></tr></table></figure><hr><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>常见行内元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span> 最常见</span></p><p>特点:</p><ol><li>相邻行内元素在一行上，一行可以显示多个。</li><li>高、宽直接设置是无效的。(<img>同时具有行内元素，行内块和块级元素的特性，是一种特殊的可替换元素，可以设置，此外还包括表单元素)</li><li>默认宽度就是它本身内容的宽度。</li><li>行内元素只能容纳文本或其他行内元素。</li></ol><p>链接里面不能再放链接</p><pre><code class="hljs">特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换一下块级模式最安全</code></pre><hr><h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><p><code>&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;</code></p><ul><li>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。</li><li>一行可以显示多个（行内元素特点）。</li><li>默认宽度就是它本身内容的宽度（行内元素特点）。</li><li>高度，行高、外边距以及内边距都可以控制（块级元素特点）。</li></ul><hr><h3 id="显示模式的转换"><a href="#显示模式的转换" class="headerlink" title="显示模式的转换"></a>显示模式的转换</h3><p>一个模式的元素需要另一种模式的特性</p><p>比如增加链接<a>的触发范围</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>:block      行内元素转换成块级元素<br>a &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br><br><span class="hljs-attribute">display</span>: inline  块级元素转换成行内元素<br>display: inline-block  转换成行内块元素<br></code></pre></td></tr></table></figure><hr><h2 id="5-snipaste"><a href="#5-snipaste" class="headerlink" title="5.snipaste"></a>5.snipaste</h2><ol><li>F1可以截图，并对图片操作</li><li>F3再桌面置顶显示</li><li>点击图片，ALT可以取色</li><li>按下ESC取消图片显示</li></ol><hr><h2 id="6-单行文字垂直居中"><a href="#6-单行文字垂直居中" class="headerlink" title="6.单行文字垂直居中"></a>6.单行文字垂直居中</h2><p>让文字的行高等于盒子的高度  就可以让文字在当前盒子内垂直居中</p><p><img src="/image/1.jpg" alt="1"></p><p><img src="/image/2.jpg" alt="2"></p><p>​      行高的上空隙和下空隙把文字挤到中间了，</p><p>​如果行高小于盒子高度,文字会偏上，</p><p>​如果行高大于盒子高度,则文字偏下。</p><p>​(文字这个整体靠近盒子左上角)</p><hr><h2 id="7-CSS的背景"><a href="#7-CSS的背景" class="headerlink" title="7.CSS的背景"></a>7.CSS的背景</h2><h3 id="1-背景颜色"><a href="#1-背景颜色" class="headerlink" title="1.背景颜色"></a>1.背景颜色</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">transparent</span>(默认)|color;<br></code></pre></td></tr></table></figure><h3 id="2-背景图片"><a href="#2-背景图片" class="headerlink" title="2.背景图片"></a>2.背景图片</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">常见于logo或者装饰性小图片和超大背景图，便于控制位置<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">none</span>(默认)|url;<br>例： <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">images/glory.jpg</span>)<br></code></pre></td></tr></table></figure><p>背景图片在背景颜色上面</p><p>背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径<strong>不要加引号</strong>。</p><h3 id="3-背景平铺"><a href="#3-背景平铺" class="headerlink" title="3.背景平铺"></a>3.背景平铺</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-repeat</span>:<span class="hljs-built_in">repeat</span>(默认) |no-repeat|repeat-x|repect-y<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>repeat</td><td>默认，横向纵向平铺</td></tr><tr><td>no-repeat</td><td>无平铺</td></tr><tr><td>repeat-x</td><td>横向平铺</td></tr><tr><td>repeat-y</td><td>纵向平铺</td></tr></tbody></table><h3 id="4-背景图片位置"><a href="#4-背景图片位置" class="headerlink" title="4.背景图片位置"></a>4.背景图片位置</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-position</span>:x y;<br><span class="hljs-number">1</span>.参数是方位名词 center <span class="hljs-attribute">top</span><br>  两个值都是方位名词，互换顺序没有影响<br>  如果只写了一个参数，如<span class="hljs-attribute">right</span>,另一个默认是居中<br><br><span class="hljs-number">2</span>.参数是精确单位 <span class="hljs-number">50px</span> <span class="hljs-number">100px</span>; x轴一定在前面，互换顺序有影响<br>  只有一个参数，那个参数为x轴的数据，另一个默认居中<br><br><span class="hljs-number">3</span>.参数是混合单位 center <span class="hljs-number">20px</span>,参数有顺序<br></code></pre></td></tr></table></figure><h3 id="5-背景图像固定（背景附着）"><a href="#5-背景图像固定（背景附着）" class="headerlink" title="5.背景图像固定（背景附着）"></a>5.背景图像固定（背景附着）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-attachment</span> 属性设置背景图像是否固定或者随着页面的其余部分滚动(拉动页面图片也会动)。<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>scroll</td><td>背景图像随页面滚动（默认）</td></tr><tr><td>fixed</td><td>背景图像固定</td></tr></tbody></table><h3 id="6-x3D-x3D-背景复合写法-x3D-x3D"><a href="#6-x3D-x3D-背景复合写法-x3D-x3D" class="headerlink" title="6.&#x3D;&#x3D;背景复合写法&#x3D;&#x3D;"></a>6.&#x3D;&#x3D;背景复合写法&#x3D;&#x3D;</h3><p>background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;</p><p>约定的顺序</p><h3 id="7-背景颜色半透明"><a href="#7-背景颜色半透明" class="headerlink" title="7.背景颜色半透明"></a>7.背景颜色半透明</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>);<br>最后一个参数是alpha透明度，<span class="hljs-number">0</span>-<span class="hljs-number">1</span>之间<br></code></pre></td></tr></table></figure><p>背景色半透明，盒子内容不受任何影响</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记1</title>
    <link href="/2023/04/20/CSS1/"/>
    <url>/2023/04/20/CSS1/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-CSS语法规范和代码风格"><a href="#1-CSS语法规范和代码风格" class="headerlink" title="1.CSS语法规范和代码风格"></a>1.CSS语法规范和代码风格</h2><p>语法规范</p><ul><li>选择器（用于指定CSS样式的HTML标签）</li><li>一条或多条声明(属性和属性值以键值对的形式出现)</li></ul><hr><p>代码风格</p><ul><li><p>小写</p></li><li><p>空格规范</p><ul><li>冒号后保留一个空格</li><li>选择器和{直接留一个空格</li></ul></li><li><p>展开书写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123;<br>  <span class="hljs-attribute">color</span>: pink;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="2-css选择器"><a href="#2-css选择器" class="headerlink" title="2.css选择器"></a>2.css选择器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>根据不同需求选择不同标签</p><hr><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><ol><li><p>标签</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">标签选择器</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    属性：属性值</span><br><span class="hljs-template-variable">    ...</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">属性：属性值...</code></pre><p>}</p></li><li><p>类</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.类名 &#123;<br>    属性<span class="hljs-number">1</span>: 属性值<span class="hljs-number">1</span>;  <br>    ...<br>&#125; <br>结构需要用<span class="hljs-built_in">class</span>属性来调用  <span class="hljs-built_in">class</span>  类的意思<br> &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;类名&quot;</span>&gt; 变红色 &lt;/<span class="hljs-keyword">div</span>&gt;<br><span class="hljs-number">1.</span>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。<br><span class="hljs-number">2.</span>类选择器在 HTML 中以 <span class="hljs-built_in">class</span> 属性表示，在 CSS 中，类选择器以一个点“.”号显示。<br><span class="hljs-number">3.</span>类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。<br><span class="hljs-number">4.</span>可以理解为给这个标签起了一个名字，来表示。<br><span class="hljs-number">5.</span>长名称或词组可以使用中横线来为选择器命名。<br><span class="hljs-number">6.</span>不要使用纯数字、中文等命名，尽量使用英文字母来表示。<br><span class="hljs-number">7.</span>命名要有意义，尽量使别人一眼就知道这个类名的目的。<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs applescript">我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签.<br>简单理解就是一个标签有多个名字. <br><br>多类名的具体使用：<br>    <span class="hljs-number">1.</span> &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;red font20&quot;</span>&gt;亚瑟&lt;/<span class="hljs-keyword">div</span>&gt;<br>注意：<br>    <span class="hljs-number">1.</span>在标签<span class="hljs-built_in">class</span> 属性中写 多个类名<br>    <span class="hljs-number">2.</span>多个类名中间必须用空格分开<br>    <span class="hljs-number">3.</span>这个标签就可以分别具有这些类名的样式<br>   <br>多类名开发中使用场景<br>(<span class="hljs-number">1</span>) 可以把一些标签元素相同的样式(共同的部分)放到一个类里面.<br>(<span class="hljs-number">2</span>) 这些标签都可以调用这个公共的类,然后再调用自己独有的类.<br>(<span class="hljs-number">3</span>) 从而节省CSS代码,统一修改也非常方便<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">案例<br>用 <br><span class="hljs-attribute">background-color</span><br><span class="hljs-attribute">width</span><br><span class="hljs-attribute">height</span> 三个属性修改<span class="hljs-selector-tag">div</span><br></code></pre></td></tr></table></figure><p>​</p></li><li><p>ID</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">html元素以<span class="hljs-built_in">id</span>属性设置选择器，css以<span class="hljs-comment">#+选择器定义</span><br><br></code></pre></td></tr></table></figure><p>id与类选择器区别</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span>只能使用一次，好比身份证号，唯一<br>类可以有好多标签同属一个类<br></code></pre></td></tr></table></figure><p>​</p></li><li><p>通配符</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>选取页面中所有元素</p></li></ol><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><hr><h2 id="3-css字体"><a href="#3-css字体" class="headerlink" title="3.css字体"></a>3.css字体</h2><h3 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>,Arial;<br>设置多个字体时，第一个系统找不到后用第二个，以此类推<br></code></pre></td></tr></table></figure><hr><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>单位px，Google默认<span class="hljs-number">16px</span>;<br>直接对<span class="hljs-selector-tag">body</span>标签设置字体大小时，里面的h标签需要单独设置<br></code></pre></td></tr></table></figure><hr><h3 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>: <span class="hljs-built_in">normal</span>(<span class="hljs-number">400</span>),<span class="hljs-comment">/*默认--&gt;*/</span>,<span class="hljs-built_in">bold</span>(<span class="hljs-number">700</span>),<span class="hljs-built_in">number</span>(<span class="hljs-number">100</span>-<span class="hljs-number">900</span>);<br><span class="hljs-attribute">font-weight</span>:<span class="hljs-number">700</span>; 等价于bold;<br></code></pre></td></tr></table></figure><p>让加粗标签不变粗</p><hr><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-style</span>: italic;倾斜<br></code></pre></td></tr></table></figure><hr><h3 id="字体复合属性"><a href="#字体复合属性" class="headerlink" title="字体复合属性"></a>字体复合属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">字体属性简写的方式,节约代码<br><span class="hljs-attribute">font</span>: font-style font-weight font-size/line-height font-family；<br>不能随意更改顺序，必须有size,family属性<br></code></pre></td></tr></table></figure><h2 id="4-css文本属性"><a href="#4-css文本属性" class="headerlink" title="4.css文本属性"></a>4.css文本属性</h2><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">color</span>: red; 预定义的颜色值<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>; <span class="hljs-number">16</span>进制表示 最常用<br><span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">文本内容水平对齐<br><span class="hljs-attribute">text-align</span> <span class="hljs-attribute">left</span>(默认),center,<span class="hljs-attribute">right</span>;<br>本质是让盒子里的文字水平对齐<br></code></pre></td></tr></table></figure><hr><h3 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>: none;<br><span class="hljs-attribute">text-decoration</span>: underline;<span class="hljs-comment">/*下划线*/</span><br><span class="hljs-attribute">text-decoration</span>: overline;<span class="hljs-comment">/*上划线 */</span><br><span class="hljs-attribute">text-decoration</span>: line-through;<span class="hljs-comment">/*删除线*/</span><br><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;删除链接下划线&#x3D;&#x3D;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br><span class="hljs-attribute">text-indent</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>; 缩进当前元素两个文字大小的距离<br>   <span class="hljs-selector-tag">em</span>相对单位，<span class="hljs-attribute">font-size</span> 一个文字的大小<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>:<br>&#125;<br>上间距+文本高度+下间距=行间距<br></code></pre></td></tr></table></figure><hr><h2 id="5-css引入方式"><a href="#5-css引入方式" class="headerlink" title="5.css引入方式"></a>5.css引入方式</h2><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">把所有css代码放到&lt;style&gt;&lt;/style&gt;标签中，在<span class="hljs-selector-tag">html</span>页面内部<br></code></pre></td></tr></table></figure><h3 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">直接在标签内部写上style属性，如<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;color: red; font-size: 12px&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br></code></pre></td></tr></table></figure><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">开发中使用最多<br>单独写到CSS文件中，再引入HTML文件中<br>1.新建.CSS后缀文件(文件里只有样式没有标签)<br>2.&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;文件路径&quot;</span>&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="6-chrome调试工具"><a href="#6-chrome调试工具" class="headerlink" title="6.chrome调试工具"></a>6.chrome调试工具</h2><ol><li>F12打开</li><li>ctrl+滚轮放大缩小2 ctrl+0 复原浏览器大小</li></ol>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记7</title>
    <link href="/2023/04/20/css%E7%AC%94%E8%AE%B07/"/>
    <url>/2023/04/20/css%E7%AC%94%E8%AE%B07/</url>
    
    <content type="html"><![CDATA[<h1 id="css笔记7"><a href="#css笔记7" class="headerlink" title="css笔记7"></a>css笔记7</h1><h2 id="1-精灵图"><a href="#1-精灵图" class="headerlink" title="1.精灵图"></a>1.精灵图</h2><h3 id="为什么使用精灵图（目的）："><a href="#为什么使用精灵图（目的）：" class="headerlink" title="为什么使用精灵图（目的）："></a><strong>为什么使用精灵图（目的）：</strong></h3><p>​<strong>为了有效地减少服务器接收和发送请求的次数</strong>，<strong>提高</strong>页面的<strong>加载速度</strong>，出现了 <strong>CSS 精灵技术</strong>（也称 CSS Sprites、CSS 雪碧）。</p><h3 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a><strong>核心原理</strong>：</h3><p>​将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。</p><h3 id="精灵图的使用"><a href="#精灵图的使用" class="headerlink" title="精灵图的使用"></a>精灵图的使用</h3><p>使用精灵图核心：</p><ol><li>精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。</li><li>这个大图片也称为 sprites  精灵图  或者 雪碧图</li><li>移动背景图片位置， 此时可以使用 background-position 。</li><li>移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同</li><li>&#x3D;&#x3D;因为一般情况下都是往上往左移动，所以数值是负值。&#x3D;&#x3D;</li><li>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。</li></ol><hr><h2 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2.字体图标"></a>2.字体图标</h2><h3 id="字体图标的产生"><a href="#字体图标的产生" class="headerlink" title="字体图标的产生"></a>字体图标的产生</h3><p>字体图标使用场景：  主要用于显示网页中通用、常用的一些小图标。</p><p>精灵图是有诸多优点的，但是缺点很明显。</p><p>1.图片文件还是比较大的。</p><p>2.图片本身放大和缩小会失真。</p><p>3.一旦图片制作完毕想要更换非常复杂。</p><p>此时，有一种技术的出现很好的解决了以上问题，就是<strong>字体图标 iconfont</strong>。</p><p><strong>字体图标</strong>可以为前端工程师提供一种方便高效的图标使用方式，<strong>展示的是图标，本质属于字体</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>轻量级：一旦字体加载了，很快就行显示出来</li><li>灵活性：本质是文字，方便修改</li><li>兼容性：几乎支持所有的浏览器</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>字体图标下载（icomoon)</p><p>放到根目录中，在css中引入字体文件（字体声明）</p><p>html标签内添加小图标</p><p>给标签指定字体</p><h2 id="3-css三角"><a href="#3-css三角" class="headerlink" title="3.css三角"></a>3.css三角</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>; <br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">border</span>: <span class="hljs-number">50px</span> solid transparent;<br><span class="hljs-attribute">border-color</span>: red green blue black;<br><span class="hljs-attribute">line-height</span>:<span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>我们用css 边框可以模拟三角效果</li><li>宽度高度为0</li><li>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了</li><li>为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</li></ol><h2 id="4-用户界面样式"><a href="#4-用户界面样式" class="headerlink" title="4.用户界面样式"></a>4.用户界面样式</h2><h3 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">cursor</span>: pointer<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>defaut</td><td>默认</td></tr><tr><td>pointer</td><td>小手</td></tr><tr><td>move</td><td>十字架</td></tr><tr><td>text</td><td>文字光标</td></tr><tr><td>not-allowed</td><td>禁止</td></tr></tbody></table><h3 id="轮廓线"><a href="#轮廓线" class="headerlink" title="轮廓线"></a>轮廓线</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline</span>:<span class="hljs-number">0</span> 去掉表单蓝色边框<br></code></pre></td></tr></table></figure><h3 id="防止拖拽文本域"><a href="#防止拖拽文本域" class="headerlink" title="防止拖拽文本域"></a>防止拖拽文本域</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">resize</span>: none;<br></code></pre></td></tr></table></figure><h2 id="5-vertical-align属性"><a href="#5-vertical-align属性" class="headerlink" title="5.vertical-align属性"></a>5.vertical-align属性</h2><p>用于设置一个元素的垂直对齐方式，只能用于行内元素或行内块元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">vertical-align</span> : baseline | top | middle | bottom <br></code></pre></td></tr></table></figure><p>解决图片底部默认空白缝隙问题</p><p>主要解决方法有两种：</p><p>1.<strong>给图片</strong>添加 <strong>vertical-align:middle | top| bottom</strong> 等。 （提倡使用的）</p><p>2.把图片转换为块级元素  <strong>display: block</strong>; </p><h2 id="6-文字溢出省略号显示"><a href="#6-文字溢出省略号显示" class="headerlink" title="6.文字溢出省略号显示"></a>6.文字溢出省略号显示</h2><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*1. 先强制一行内显示文本*/</span><br>  <span class="hljs-attribute">white-space</span>: nowrap;  （ 默认 <span class="hljs-attribute">normal</span> 自动换行）<br>  <br> <span class="hljs-comment">/*2. 超出的部分隐藏*/</span><br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <br> <span class="hljs-comment">/*3. 文字用省略号替代超出的部分*/</span><br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br></code></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><p>多行文本溢出显示省略号，<strong>有较大兼容性问题</strong>，适合于webKit浏览器或移动端</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*1. 超出的部分隐藏 */</span><br><span class="hljs-attribute">overflow</span>: hidden;<br><br><span class="hljs-comment">/*2. 文字用省略号替代超出的部分 */</span><br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><br><span class="hljs-comment">/* 3. 弹性伸缩盒子模型显示 */</span><br><span class="hljs-attribute">display</span>: -webkit-box;<br><br><span class="hljs-comment">/* 4. 限制在一个块元素显示的文本的行数 */</span><br>-webkit-line-clamp: <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */</span><br>-webkit-box-orient: vertical;<br><br></code></pre></td></tr></table></figure><h2 id="7-布局技巧"><a href="#7-布局技巧" class="headerlink" title="7.布局技巧"></a>7.布局技巧</h2><h3 id="margin-负值的应用"><a href="#margin-负值的应用" class="headerlink" title="margin 负值的应用"></a>margin 负值的应用</h3><p>1.两个有边框的盒子挨在一起会导致边框加粗，可以巧妙使用margin</p><p>使一个盒子的边框压住另一个盒子的边框。</p><p>2.在有一边被压住的情况下，鼠标经过时出现边框的变化，鼠标经过某个盒子的时候，给盒子加相对定位或者提高层级。</p><h3 id="文字围绕浮动元素"><a href="#文字围绕浮动元素" class="headerlink" title="文字围绕浮动元素"></a>文字围绕浮动元素</h3><p>巧妙运用浮动元素不会压住文字的特性</p><h3 id="行内块巧妙运用"><a href="#行内块巧妙运用" class="headerlink" title="行内块巧妙运用"></a>行内块巧妙运用</h3><p>利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记6</title>
    <link href="/2023/04/20/css%E7%AC%94%E8%AE%B06/"/>
    <url>/2023/04/20/css%E7%AC%94%E8%AE%B06/</url>
    
    <content type="html"><![CDATA[<h1 id="css笔记6"><a href="#css笔记6" class="headerlink" title="css笔记6"></a>css笔记6</h1><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="1-为什么需要定位"><a href="#1-为什么需要定位" class="headerlink" title="1.为什么需要定位"></a>1.为什么需要定位</h3><p>定位可以让盒子自由的在某个盒子内移动位置或者固定屏幕中的某个位置，并且可以压住某个盒子。</p><h3 id="2-定位组成"><a href="#2-定位组成" class="headerlink" title="2.定位组成"></a>2.定位组成</h3><p>定位&#x3D;定位模式+边偏移</p><p>定位模式用于指定一个元素在文档中的定位模式。边偏移则决定了该元素的最终位置。</p><table><thead><tr><th>值</th><th>语义</th></tr></thead><tbody><tr><td>static</td><td>静态定位</td></tr><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolute</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table><h3 id="3-静态定位"><a href="#3-静态定位" class="headerlink" title="3.静态定位"></a>3.静态定位</h3><p>元素的默认定位方式，无定位的意思</p><p>按照标准流的方式摆放位置</p><h3 id="4-相对定位"><a href="#4-相对定位" class="headerlink" title="4.相对定位"></a>4.相对定位</h3><ol><li><p>元素移动时是相对元素原来的位置来说的</p></li><li><p>元素在标准流的位置中依然占用，后面的盒子仍以原来的方式对待它，不脱标</p><p>position: relative;</p><p>（会显示在浮动和标准流上面）</p></li></ol><h3 id="5-绝对定位"><a href="#5-绝对定位" class="headerlink" title="5.绝对定位"></a>5.绝对定位</h3><p>​     position: absolute;</p><ol><li>绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的</li><li>如果没有父元素或者父元素没有定位，以浏览器为准进行对齐</li><li>如果父元素有定位，以最近一级有定位的父元素为基准</li><li>绝对定位不占有原先位置，脱标</li></ol><h3 id="6-子绝父相"><a href="#6-子绝父相" class="headerlink" title="6.子绝父相"></a>6.子绝父相</h3><p>①子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</p><p>②父盒子需要加定位限制子盒子在父盒子内显示。</p><p>③父盒子布局时，需要占有位置，因此父亲只能是相对定位。</p><h3 id="7-固定定位"><a href="#7-固定定位" class="headerlink" title="7.固定定位"></a>7.固定定位</h3><p> 元素固定于浏览器可视区的位置。</p><p> position: fixed;</p><ol><li><p>以浏览器的可视窗口为参照点移动元素</p><p>与父元素无关</p><p>不随着滚动条滚动而滚动</p></li><li><p>固定定位不占用原来的位置</p></li></ol><p>小技巧：固定在版心右侧位置</p><p>算法：</p><p>   1.left 50%</p><pre><code class="hljs">          2.  margin-left:版心宽度的一半</code></pre><h3 id="8-粘性定位"><a href="#8-粘性定位" class="headerlink" title="8.粘性定位"></a>8.粘性定位</h3><p> 可以被认为是相对定位和固定定位的混合</p><p> position:sticky; top:10px;</p><p>特点：</p><p>1.以浏览器的可视窗口为参照点移动元素（固定定位特点）</p><p>2.粘性定位占有原先的位置（相对定位特点）</p><p>3.必须添加 top 、left、right、bottom <strong>其中一个</strong>才有效</p><p>跟页面滚动搭配使用。 兼容性较差，IE 不支持。</p><h3 id="9-定位叠放次序"><a href="#9-定位叠放次序" class="headerlink" title="9.定位叠放次序"></a>9.定位叠放次序</h3><p>使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序</p><p>z-index:1;</p><p>数值越大，盒子越靠上</p><p>如果属性值相同，按照书写顺序，后来居上</p><p>&#x3D;&#x3D;z-index只能用于相对定位，绝对定位和固定定位的元素&#x3D;&#x3D;</p><h3 id="10-定位的拓展"><a href="#10-定位的拓展" class="headerlink" title="10.定位的拓展"></a>10.定位的拓展</h3><p>1.&#x3D;&#x3D;加了绝对定位或固定定位的盒子不能通过margin:auto水平居中&#x3D;&#x3D;</p><p>2.绝对定位和固定定位也与浮动类似。</p><ol><li>行内元素添加绝对定位和固定定位，可以直接添加高度和宽度</li><li>块级元素添加绝对或者固定定位，如果不给宽高，默认为内容的大小</li><li>脱标的盒子不会有外边距合并</li></ol><p>3.绝对定位和固定定位会完全压住下面的盒子</p><p> （浮动的元素不会压住下面标准流的文字，因为浮动最初的目的是产生文字环绕）</p><p>如果一个盒子既有left 和right ,默认执行left;既有top bottom,默认执行top</p><h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h2><h3 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: none 隐藏对象<br><br>display：block 除了转换为块级元素之外，同时还有显示元素的意思。<br></code></pre></td></tr></table></figure><p>特点： display 隐藏元素后，<strong>不再占</strong>有原来的位置。</p><h3 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h3><p>visibility 隐藏元素后，继续占用原来的位置</p><p>visibility：visible ; 　元素可视</p><p>visibility：hidden; 　  元素隐藏</p><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么</p><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>visible</td><td>默认，不剪切内容也不添加滚动条</td></tr><tr><td>hidden</td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td>scroll</td><td>溢出部分显示滚动条，无论需不需要都添加</td></tr><tr><td>auto</td><td>溢出部分显示滚动条，在需要的时候添加</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记5</title>
    <link href="/2023/04/20/CSS%E7%AC%94%E8%AE%B05/"/>
    <url>/2023/04/20/CSS%E7%AC%94%E8%AE%B05/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS笔记5"><a href="#CSS笔记5" class="headerlink" title="CSS笔记5"></a>CSS笔记5</h1><h2 id="PS切图"><a href="#PS切图" class="headerlink" title="PS切图"></a>PS切图</h2><h3 id="图层切图"><a href="#图层切图" class="headerlink" title="图层切图"></a>图层切图</h3><p>用移动工具选择找到图层，右击图层，快速导出PNG</p><p>有时候要导出得图片为两个图层合并得效果，所以需要将有所需图片的图层合并，选中后ctrl+e</p><h3 id="切片切图"><a href="#切片切图" class="headerlink" title="切片切图"></a>切片切图</h3><p>利用切片选中图片</p><p>导出选中的图片</p><h3 id="ps插件切图"><a href="#ps插件切图" class="headerlink" title="ps插件切图"></a>ps插件切图</h3><p>安装cutterman插件</p><hr><h2 id="css属性书写顺序"><a href="#css属性书写顺序" class="headerlink" title="css属性书写顺序"></a>css属性书写顺序</h2><p>   建议遵循以下顺序：</p><ol><li>布局定位属性：display&#x2F;position&#x2F;float&#x2F;clear&#x2F;visibility&#x2F;overflow</li><li>自身属性：width&#x2F;height&#x2F;margin&#x2F;padding&#x2F;border&#x2F;background</li><li>文本属性：color&#x2F;font&#x2F;text-decoration&#x2F;text-align&#x2F;vertical-align&#x2F;white-space&#x2F;break-word</li><li>其他属性：content&#x2F;cursor&#x2F;border-radius&#x2F;box-shadow&#x2F;text-shadow&#x2F;background:linear-gradient..</li></ol><h2 id="页面布局整体思路"><a href="#页面布局整体思路" class="headerlink" title="页面布局整体思路"></a>页面布局整体思路</h2><ol><li>必须确定页面的版心（可视区），我们测量可得知</li><li>分析页面中的行模块，以及每个行模块的列模块。页面布局第一准则</li><li>一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置。页面布局第二准则</li><li>制作HTML结构。遵循先有结构，后有样式的原则</li><li>先理清楚布局结构，再写代码尤为重要</li></ol><h2 id="案例制作要点"><a href="#案例制作要点" class="headerlink" title="案例制作要点"></a>案例制作要点</h2><p>实际开发中，不会直接用链接a而是用li 包含链接(li+a)的做法</p><p>浮动的盒子不会有外边距合并问题</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记4</title>
    <link href="/2023/04/20/css%E7%AC%94%E8%AE%B04/"/>
    <url>/2023/04/20/css%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h1 id="css笔记4"><a href="#css笔记4" class="headerlink" title="css笔记4"></a>css笔记4</h1><h2 id="1-圆角边框"><a href="#1-圆角边框" class="headerlink" title="1.圆角边框"></a>1.圆角边框</h2><p>在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-attribute">border-radius</span>: length; px或者百分比 <span class="hljs-number">50%</span><br></code></pre></td></tr></table></figure><p>边框相邻两条边的内切圆的半径</p><p><img src="/image/4.1.png"></p><ul><li>如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50%</li><li>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角</li><li>分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius。</li></ul><hr><h2 id="2-盒子阴影"><a href="#2-盒子阴影" class="headerlink" title="2.盒子阴影"></a>2.盒子阴影</h2><p>css3中增加了盒子阴影，可以使用box-shadow属性为盒子添加阴影</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>:      ;<br></code></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必需，水平阴影的位置，可负，px</td></tr><tr><td>v-shadow</td><td>必需，垂直阴影的位置，可负,px</td></tr><tr><td>blur</td><td>可选，模糊距离（阴影的虚实）,px</td></tr><tr><td>spread</td><td>可选，阴影的尺寸,px</td></tr><tr><td>color</td><td>可选，阴影的颜色</td></tr><tr><td>inset</td><td>可选，将外部阴影改为内部阴影</td></tr></tbody></table><p>原先盒子没有影子，当我们鼠标经过盒子时就添加阴影效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>:cover :&#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-文字阴影"><a href="#3-文字阴影" class="headerlink" title="3.文字阴影"></a>3.文字阴影</h2><p>用text-shadow属性将阴影应用于文本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-shadow</span>: h-shadow v-shadow blur color;<br>属性值的含义与盒子阴影相同<br></code></pre></td></tr></table></figure><h2 id="4-x3D-x3D-css浮动-x3D-x3D"><a href="#4-x3D-x3D-css浮动-x3D-x3D" class="headerlink" title="4.&#x3D;&#x3D;css浮动&#x3D;&#x3D;"></a>4.&#x3D;&#x3D;css浮动&#x3D;&#x3D;</h2><h3 id="传统网页布局的三种方式"><a href="#传统网页布局的三种方式" class="headerlink" title="传统网页布局的三种方式"></a>传统网页布局的三种方式</h3><p>&#x3D;&#x3D;普通流（标准流）&#x3D;&#x3D;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">标签按照规定好默认方式排列<br>1.块元素独占一行，从上到下<br>2.行元素按顺序从左到右，碰到边缘自动换行<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;浮动&#x3D;&#x3D;</p><p>&#x3D;&#x3D;定位&#x3D;&#x3D;</p><p>实际开发中，一个页面基本包含这三种布局方式</p><hr><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="为什么需要浮动"><a href="#为什么需要浮动" class="headerlink" title="为什么需要浮动"></a>为什么需要浮动</h4><ol><li>如何让多个div放在一行？</li><li>如何实现两个盒子左右对齐？</li></ol><p>浮动可以改变标签的默认排列方式。</p><p>&#x3D;&#x3D;网页布局第一准则：&#x3D;&#x3D;</p><p><strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</strong></p><hr><h4 id="什么是浮动"><a href="#什么是浮动" class="headerlink" title="什么是浮动"></a>什么是浮动</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器&#123;<br>  <span class="hljs-attribute">float</span>:属性值;<br>&#125;<br><span class="hljs-attribute">none</span> <span class="hljs-attribute">left</span> <span class="hljs-attribute">right</span><br></code></pre></td></tr></table></figure><p>float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p><h4 id="x3D-x3D-浮动特性-x3D-x3D"><a href="#x3D-x3D-浮动特性-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;浮动特性&#x3D;&#x3D;"></a>&#x3D;&#x3D;浮动特性&#x3D;&#x3D;</h4><ol><li><p>浮动的元素会脱离标准流</p><ol><li>脱离标准普通流的控制（浮）移动到指定位置（动），俗称&#x3D;&#x3D;脱标&#x3D;&#x3D;</li></ol><p>​    </p><ol start="2"><li>浮动的盒子不再保留原先的位置</li></ol><p>​</p><p>给盒子设置了浮动，这个盒子会浮起来，下面标准流的盒子会占用浮动盒子原本的位置</p><p><img src="/image/4.2.png"></p><p>​</p><p>​</p></li><li><p>浮动的元素会一行内显示并且元素顶部对齐</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。<br></code></pre></td></tr></table></figure><ol start="3"><li><p>浮动的元素具有&#x3D;&#x3D;行内块元素&#x3D;&#x3D;的特性</p><p>如果行内元素有了浮动，则不需要转换块级&#x2F;行内块元素就可以直接给高度和宽度</p><p>浮动元素的大小根据内容来决定（如果没有设置宽度）</p><p>浮动的盒子中间是没有缝隙的</p></li></ol><h4 id="浮动元素经常和标准流父级搭配使用"><a href="#浮动元素经常和标准流父级搭配使用" class="headerlink" title="浮动元素经常和标准流父级搭配使用"></a>浮动元素经常和标准流父级搭配使用</h4><p>为了约束浮动元素位置, 我们网页布局一般采取的策略是:</p><p>​先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置.  符合网页布局第一准侧。</p><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="浮动布局注意点"><a href="#浮动布局注意点" class="headerlink" title="浮动布局注意点"></a>浮动布局注意点</h4><p>1、<strong>浮动和标准流的父盒子搭配</strong>。</p><p>&#x3D;&#x3D;先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置&#x3D;&#x3D;</p><p>2、<strong>一个元素浮动了，理论上其余的兄弟元素也要浮动</strong>。</p><p>一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。</p><p>&#x3D;&#x3D;浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流.&#x3D;&#x3D;</p><hr><h2 id="5-清除浮动"><a href="#5-清除浮动" class="headerlink" title="5.清除浮动"></a>5.清除浮动</h2><p>在父盒子不方便给高度的情况下，如果子盒子都是浮动排列，由于子盒子不占有位置，所以父盒子的高度会变成0，就会影响下面的标准流盒子。</p><p><img src="/image/4.3.png"></p><h4 id="清除浮动的本质"><a href="#清除浮动的本质" class="headerlink" title="清除浮动的本质"></a>清除浮动的本质</h4><p>清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度</p><p>注意：</p><ul><li>如果父盒子本身有高度，则不需要清除浮动</li><li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。</li><li>父级有了高度，就不会影响下面的标准流了</li></ul><h4 id="清除浮动方法"><a href="#清除浮动方法" class="headerlink" title="清除浮动方法"></a>清除浮动方法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器&#123;<span class="hljs-attribute">clear</span>:属性值;&#125; <br><span class="hljs-attribute">left</span> <span class="hljs-attribute">right</span> both<br>实际 <span class="hljs-attribute">clear</span>:both<br></code></pre></td></tr></table></figure><h5 id="额外标签法："><a href="#额外标签法：" class="headerlink" title="额外标签法："></a>额外标签法：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">clear</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;在最后一个浮动元素后加一个空的标签（必须是块级元素）<br><span class="hljs-selector-class">.clear</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>书写方便，但是结构化较差</p><h5 id="父级添加overflow"><a href="#父级添加overflow" class="headerlink" title="父级添加overflow:"></a>父级添加overflow:</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>:hidden;<br></code></pre></td></tr></table></figure><p>缺点：无法显出溢出的部分</p><h5 id="after伪元素法："><a href="#after伪元素法：" class="headerlink" title="after伪元素法："></a>after伪元素法：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>           <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>           <span class="hljs-attribute">display</span>: block;<br>           <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>           <span class="hljs-attribute">clear</span>: both;<br>           <span class="hljs-attribute">visibility</span>: hidden;<br>       &#125;<br><br> <span class="hljs-selector-class">.clearfix</span> &#123;<br>        <span class="hljs-comment">/* IE6、7 专有 */</span><br>     *zoom: <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>为父元素添加一个新的类名clearfix,类名可以自定义但是父元素必须有这个样式，一般为clearfix</p><h5 id="双伪元素法"><a href="#双伪元素法" class="headerlink" title="双伪元素法:"></a>双伪元素法:</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<br>     <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>         <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>         <span class="hljs-attribute">display</span>: table;<br>     &#125;<br><br>     <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>         <span class="hljs-attribute">clear</span>: both;<br>     &#125;<br><br>     <span class="hljs-selector-class">.clearfix</span> &#123;<br>         *zoom: <span class="hljs-number">1</span>;<br>     &#125;<br></code></pre></td></tr></table></figure><p>为父元素添加一个新的类名clearfix</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记3</title>
    <link href="/2023/04/20/css%E7%AC%94%E8%AE%B03/"/>
    <url>/2023/04/20/css%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h1 id="css笔记3"><a href="#css笔记3" class="headerlink" title="css笔记3"></a>css笔记3</h1><h2 id="1-css三大特性"><a href="#1-css三大特性" class="headerlink" title="1.css三大特性"></a>1.css三大特性</h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>相同选择器给设置相同的样式，此时一个样式就会&#x3D;&#x3D;覆盖&#x3D;&#x3D;另一个冲突的样式。</p><p>样式冲突遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式</p><hr><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>子标签会继承父标签的某些样式，如文本颜色和字号。</p><p>&#x3D;&#x3D;text-，font-，line-&#x3D;&#x3D;这些元素开头的可以继承，以及color属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">行高的继承性（有特殊的写法）<br> <span class="hljs-selector-tag">body</span> &#123;<br>   <span class="hljs-attribute">font</span>:<span class="hljs-number">12px</span>/<span class="hljs-number">1.5</span> Microsoft YaHei；<br> &#125;<br>当前元素文字大小的<span class="hljs-number">1.5</span>倍<br>- 行高可以跟单位也可以不跟单位<br>- 如果子元素没有设置行高，则会继承父元素的行高为 <span class="hljs-number">1.5</span><br>- 此时子元素的行高是：当前子元素的文字大小 * <span class="hljs-number">1.5</span><br>- <span class="hljs-selector-tag">body</span> 行高 <span class="hljs-number">1.5</span>  这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高<br><br></code></pre></td></tr></table></figure><hr><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承  或者*</td><td>0，0，0，0</td></tr><tr><td>元素选择器</td><td>0，0，0，1</td></tr><tr><td>类选择器</td><td>0，0，1，0</td></tr><tr><td>ID选择器</td><td>0，1，0，0</td></tr><tr><td>行内样式style&#x3D;””</td><td>1,0,0,0</td></tr><tr><td>!important 重要的</td><td>无穷大</td></tr></tbody></table><p>&#x3D;&#x3D;color: black!important;&#x3D;&#x3D;</p><p>注意点：</p><ol><li>权重由4位数字组成，不会进位</li><li>等级判断从左到右，如果某一位数值相同比较 下一位</li><li>继承的权重是0，如a标签浏览器默认指定了一个样式，对body指定样式，里面的a不会有变化</li></ol><p>&#x3D;&#x3D;权重叠加&#x3D;&#x3D;</p><p>复合选择器权重叠加（并集选择器除外）</p><ul><li>div ul  li   ——&gt;      0,0,0,3</li><li>.nav ul li   ——&gt;      0,0,1,2</li><li>a:hover      —–—&gt;   0,0,1,1</li><li>.nav a       ——&gt;      0,0,1,1</li></ul><p>不会进位，单个权重分别做加法即可</p><hr><h2 id="2-css盒子模型"><a href="#2-css盒子模型" class="headerlink" title="2.css盒子模型"></a>2.css盒子模型</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>网页布局的核心本质： 就是利用 CSS 摆盒子。</p><p>网页布局过程：</p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子 Box 。</li><li>&#x3D;&#x3D;利用 CSS 设置好盒子样式，然后摆放到相应位置&#x3D;&#x3D;。</li><li>往盒子里面装内容</li></ol><hr><h3 id="盒子模型的组成"><a href="#盒子模型的组成" class="headerlink" title="盒子模型的组成"></a>盒子模型的组成</h3><p>把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</p><p><img src="/image/3.1.jpg" alt="1"></p><h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p>border可以设置元素的边框。边框由三部分组成：宽度，样式，颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-width</span>:    <br>border-style:<span class="hljs-built_in">solid</span>(实线)|<span class="hljs-built_in">dashed</span>(虚线)|<span class="hljs-built_in">dotted</span>(点线)<br>border-color:<br></code></pre></td></tr></table></figure><p>复合写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid pink; (没有顺序但一般为这种写法)<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">分开写法<br><span class="hljs-attribute">border-top</span>: <span class="hljs-number">10px</span> solid pink;<br><span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">10px</span> dashed purple;<br><span class="hljs-attribute">border-right</span><br><span class="hljs-attribute">border-left</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;表格细线边框&#x3D;&#x3D;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: collspace 相邻边框合并到一起<br></code></pre></td></tr></table></figure><p>边框会影响盒子的实际大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">边框会额外增加盒子的实际大小。因此我们有两种方案解决：<br><br>- 测量盒子大小的时候,不量边框。<br>- 如果测量的时候包含了边框,则需要 <span class="hljs-attribute">width</span>/<span class="hljs-attribute">height</span> 减去边框宽度<br><br></code></pre></td></tr></table></figure><hr><h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p>内边距用于设置内容与边框之间的距离。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>padding-left</td><td>左内边距</td></tr><tr><td>padding-top</td><td>上内边距</td></tr><tr><td>padding-right</td><td>右内边距</td></tr><tr><td>padding-bottom</td><td>下内边距</td></tr></tbody></table><p>复合写法</p><p><img src="/image/3.2.jpg" alt="2"></p><p>&#x3D;&#x3D;内边距会影响盒子的实际大小&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在标准的盒子模型中，width和height属性规定的是内容的大小，不包括padding,border，因此整个盒子的大小会受到padding和border的影响。&#x3D;&#x3D;</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">通过<span class="hljs-built_in">box</span>-sizing这个样式我们可以改变这种宽度计算方式，它的属性值有两个：<span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>和<span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>。默认值为<span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>，也就是标准的盒子模型，此时的计算公式为<br><br><span class="hljs-built_in">width</span> = 内容的宽度<br><span class="hljs-built_in">height</span> = 内容的高度<br></code></pre></td></tr></table></figure><p>为了在添加padding后盒子的大小和原本一致，需要修改width和height</p><p>(如何盒子本身没有指定width&#x2F;height属性, 则此时padding不会撑开盒子大小。)</p><hr><h4 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h4><p>margin 属性用于设置外边距，即控制盒子和盒子之间的距离。</p><p>使用方法与padding类似</p><hr><p>外边距应用：</p><p>外边距可以让&#x3D;&#x3D;块级盒子&#x3D;&#x3D;水平居中的两个条件：</p><ul><li>盒子必须指定了宽度（width）。</li><li>盒子左右的外边距都设置为 auto 。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">margin-left</span>: auto;   <span class="hljs-attribute">margin-right</span>: auto;<br><span class="hljs-attribute">margin</span>: auto;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br></code></pre></td></tr></table></figure><p>注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。</p><hr><p>外边距合并</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-number">1</span>、相邻块元素垂直外边距的合并<br>当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-<span class="hljs-built_in">bottom</span>，下面的元素有上外边距 margin-<span class="hljs-built_in">top</span> ，则他们之间的垂直间距不是 margin-<span class="hljs-built_in">bottom</span> 与 margin-<span class="hljs-built_in">top</span> 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。<br><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">2.嵌套块元素垂直外边距的塌陷<br><span class="hljs-code">  这个问题用文字不太好描述，主要是父盒子的子盒子加了外边距会导致父盒子塌陷</span><br><span class="hljs-code">  解决方案：</span><br><br><span class="hljs-bullet">- </span>可以为父元素定义上边框。<br><span class="hljs-bullet">- </span>可以为父元素定义上内边距。<br><span class="hljs-bullet">- </span>可以为父元素添加 overflow:hidden。<br><br></code></pre></td></tr></table></figure><p>清楚内外边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>   <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;   <span class="hljs-comment">/* 清除内边距 */</span><br>   <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;    <span class="hljs-comment">/* 清除外边距 */</span><br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基本使用</title>
    <link href="/2023/04/20/Markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/20/Markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本使用"><a href="#Markdown基本使用" class="headerlink" title="Markdown基本使用"></a>Markdown基本使用</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>使用 # 可以表示标题，一级标题对应一个 # ，二级标题对应两个 # 号，最多至六级标题。在Typora中，# 后要紧接着一个空格才能表示标题，否则就是普通字符。</p><p>在Typora中，也可以使用快捷键Ctrl+1（2，3，4，5，6）表示相对应的标题。Ctrl+0表示段落。标题快捷键信息可在菜单栏中的段落选项下查看。</p><hr><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2><ul><li>用一对星号<code>*</code>括住的文本表示斜体文本，如：<code>*</code>要变斜体的文本<code>*</code>，<em>斜体文本</em> ；</li><li>用两对星号  <code>**</code>表示加粗；</li><li>用三对星号 <code>***</code>表示斜体和加粗；</li></ul><hr><h2 id="3-线"><a href="#3-线" class="headerlink" title="3.线"></a>3.线</h2><ol><li>分割线***</li></ol><hr><ol start="2"><li>删除线<del>22</del></li><li>下划线 <u>2</u></li></ol><p>+++</p><h2 id="4-列表"><a href="#4-列表" class="headerlink" title="4.列表"></a>4.列表</h2><h3 id="4-1无序列表"><a href="#4-1无序列表" class="headerlink" title="4.1无序列表"></a>4.1无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*+空格+列表项</span><br><span class="hljs-emphasis">+ 列表项</span><br><span class="hljs-emphasis">- 列表项</span><br></code></pre></td></tr></table></figure><ul><li>hello world</li><li>abc</li></ul><hr><h3 id="4-2有序列表"><a href="#4-2有序列表" class="headerlink" title="4.2有序列表"></a>4.2有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">数字+.+空格+列表项<br></code></pre></td></tr></table></figure><ol><li>abc</li><li>sd</li></ol><hr><h3 id="4-3嵌套列表"><a href="#4-3嵌套列表" class="headerlink" title="4.3嵌套列表"></a>4.3嵌套列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mark">1. * 进入列表，回车换行生产第二项后按下TAB，第二项变成第一项的子列表，按回车退出当前列表<br><br></code></pre></td></tr></table></figure><ul><li><p>一级</p><ul><li>二级<ul><li>三级</li></ul></li></ul><p>​</p></li></ul><hr><h2 id="5-区块"><a href="#5-区块" class="headerlink" title="5.区块"></a>5.区块</h2><p>当我们想要引用别人的文章内容时，可以将其放在区块内。</p><p>可以使用<code>&gt;</code>加空格来表示区块</p><blockquote><p>区块</p><blockquote><p>二级区块</p><blockquote><p>三级区块</p></blockquote></blockquote></blockquote><p>退出按<code>enter</code></p><h2 id="6-代码块"><a href="#6-代码块" class="headerlink" title="6.代码块"></a>6.代码块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">行内代码<br><span class="hljs-code">`代码`</span><br>代码段<br>​<span class="hljs-code">```+编程语言</span><br></code></pre></td></tr></table></figure><p><code>hello</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7.超链接"></a>7.超链接</h2><p><a href="https://www.baidu.com/">百度</a><br><a href="https://www.baidu.com/">https://www.baidu.com/</a></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[链接文字]</span>(地址)<br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>相对路径和绝对路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">也可以页内跳转<br><span class="hljs-selector-attr">[链接文字]</span>(#标题文字)<br></code></pre></td></tr></table></figure><p><a href="#Markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">回到顶部</a></p><p>​          </p><hr><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><table><thead><tr><th align="left">姓名</th><th align="left">学号</th><th align="left">成绩</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">表头</span>|<span class="hljs-string">表头</span>|<span class="hljs-string">表头</span>|<br>|<span class="hljs-string">---</span>|<span class="hljs-string">---</span>|<span class="hljs-string">----</span>|<br>|<span class="hljs-string">单元格</span>|<span class="hljs-string">单元格</span>|<span class="hljs-string">单元格</span>|<br>|<span class="hljs-string">单元格</span>|<span class="hljs-string">单元格</span>|<span class="hljs-string">单元格</span>|<br></code></pre></td></tr></table></figure><hr><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9.图片"></a>9.图片</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址)<br><br>!<span class="hljs-selector-attr">[alt 属性文本]</span>(图片地址 &quot;可选标题&quot;)<br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/20/Markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/photo/DSC_0541.JPG" alt="图片"></p><hr><h2 id="10-emoji"><a href="#10-emoji" class="headerlink" title="10.emoji"></a>10.emoji</h2><p><code>:emoji:</code></p><p>:grinning:</p><p>:crab:</p><p>:cry:</p><p>:laughing:</p><h2 id="11-上下标和高亮"><a href="#11-上下标和高亮" class="headerlink" title="11.上下标和高亮"></a>11.上下标和高亮</h2><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">在Typora中，可以用一对~将下标括起来，如：H~<span class="hljs-number">2</span>~O表示H2O<br><br>同样，我们也可以用一对^将上标括起来，如：<span class="hljs-keyword">X</span>^<span class="hljs-number">2</span>^表示<span class="hljs-keyword">X</span><span class="hljs-number">2</span><br><br>高亮：==内容==<br></code></pre></td></tr></table></figure><p>h<del>2</del>o</p><p>&#x3D;&#x3D;x^2^&#x3D;&#x3D;</p><hr><p><a href="#markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">回到顶部</a></p><p>未完待续…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/20/hello-world/"/>
    <url>/2023/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
